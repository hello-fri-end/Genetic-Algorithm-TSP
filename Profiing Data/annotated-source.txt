*** File /usr/include/c++/11/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994-2021 Free Software Foundation, Inc.
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
                 *  for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/exception.h>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception
                  {
                  public:
                    bad_alloc() throw() { }
                
                #if __cplusplus >= 201103L
                    bad_alloc(const bad_alloc&) = default;
                    bad_alloc& operator=(const bad_alloc&) = default;
                #endif
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                #if __cplusplus >= 201103L
                  class bad_array_new_length : public bad_alloc
                  {
                  public:
                    bad_array_new_length() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_array_new_length() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                #endif
                
                #if __cpp_aligned_new
                  enum class align_val_t: size_t {};
                #endif
                
                  struct nothrow_t
                  {
                #if __cplusplus >= 201103L
                    explicit nothrow_t() = default;
                #endif
                  };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                
                #if __cplusplus >= 201103L
                  /// Return the current new handler.
                  new_handler get_new_handler() noexcept;
                #endif
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #endif
                _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_aligned_new
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                void operator delete(void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete(void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                void operator delete[](void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #endif // __cpp_sized_deallocation
                #endif // __cpp_aligned_new
                
                // Default placement versions of operator new.
                _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
    22140856 -> { return __p; }
                _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
                { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                //@}
                } // extern "C++"
                
                #if __cplusplus >= 201703L
                #ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER
                namespace std
                {
                #define __cpp_lib_launder 201606
                  /// Pointer optimization barrier [ptr.launder]
                  template<typename _Tp>
                    [[nodiscard]] constexpr _Tp*
                    launder(_Tp* __p) noexcept
                    { return __builtin_launder(__p); }
                
                  // The program is ill-formed if T is a function type or
                  // (possibly cv-qualified) void.
                
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args...) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args......) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                
                  void launder(void*) = delete;
                  void launder(const void*) = delete;
                  void launder(volatile void*) = delete;
                  void launder(const volatile void*) = delete;
                }
                #endif // _GLIBCXX_HAVE_BUILTIN_LAUNDER
                #endif // C++17
                
                #if __cplusplus > 201703L
                namespace std
                {
                  /// Tag type used to declare a class-specific operator delete that can
                  /// invoke the destructor before deallocating the memory.
                  struct destroying_delete_t
                  {
                    explicit destroying_delete_t() = default;
                  };
                  /// Tag variable of type destroying_delete_t.
                  inline constexpr destroying_delete_t destroying_delete{};
                }
                // Only define the feature test macro if the compiler supports the feature:
                #if __cpp_impl_destroying_delete
                # define __cpp_lib_destroying_delete 201806L
                #endif
                #endif // C++20
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      175   22140856

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

 22140856   Total number of line executions
11070428.00   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/./Genetic-Algorithm/Crossover/random_crossover.cpp:
                #include "random_crossover.hpp"
                #include "../Path_representation.hpp"
                #include <cstdlib>
                #include <vector>
                #include <set>
                
                using std::vector;
                using std::set;
                using std::pair;
                
                pair<PathRepresentation, PathRepresentation> RandomCrossover::
       90000 ->       crosslink(const PathRepresentation &A, const PathRepresentation &B) {
                  vector<int> pathA = A.get_order();
                  vector<int> pathB = B.get_order();
                  vector<int> offspring1, offspring2 ;
                
                  set<int> keepTrack1, keepTrack2;
                
                  size_t numPoints = pathA.size();
                
                  // Generate a random index in the range[2, . . ., numPoints -2]
                  unsigned randomIndex1 = (rand() % (numPoints - 3)) + 2;
                  unsigned randomIndex2 = (rand() % (numPoints - 3)) + 2;
                
                  for(unsigned i = 0 ; i < randomIndex1; ++i)
                  {
                    offspring1.push_back(pathA.at(i));
                    keepTrack1.insert(pathA.at(i));
                  }
                
                  for(unsigned i = 0 ; i < randomIndex2; ++i)
                  {
                    offspring2.push_back(pathB.at(i));
                    keepTrack2.insert(pathB.at(i));
                  }
                
                  //crosslinking
                
                  for(const auto &point: pathB ){
                    bool found = keepTrack1.find(point)!= keepTrack1.end();
                    if(!found){
                        offspring1.push_back(point);
                    }
                  }
                
                  for(const auto &point: pathA ){
                    bool found = keepTrack2.find(point)!= keepTrack2.end();
                    if(!found){
                        offspring2.push_back(point);
                    }
                  }
                
                  PathRepresentation Offspring1(offspring1);
                  PathRepresentation Offspring2(offspring2);
                  return pair{Offspring1, Offspring2};
                }


Top 10 Lines:

     Line      Count

       12      90000

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    90000   Total number of line executions
 90000.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_function.h:
                // Functor implementations -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_function.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{functional}
                 */
                
                #ifndef _STL_FUNCTION_H
                #define _STL_FUNCTION_H 1
                
                #if __cplusplus > 201103L
                #include <bits/move.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // 20.3.1 base classes
                  /** @defgroup functors Function Objects
                   * @ingroup utilities
                   *
                   *  Function objects, or @e functors, are objects with an @c operator()
                   *  defined and accessible.  They can be passed as arguments to algorithm
                   *  templates and used in place of a function pointer.  Not only is the
                   *  resulting expressiveness of the library increased, but the generated
                   *  code can be more efficient than what you might write by hand.  When we
                   *  refer to @a functors, then, generally we include function pointers in
                   *  the description as well.
                   *
                   *  Often, functors are only created as temporaries passed to algorithm
                   *  calls, rather than being created as named variables.
                   *
                   *  Two examples taken from the standard itself follow.  To perform a
                   *  by-element addition of two vectors @c a and @c b containing @c double,
                   *  and put the result in @c a, use
                   *  \code
                   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
                   *  \endcode
                   *  To negate every element in @c a, use
                   *  \code
                   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
                   *  \endcode
                   *  The addition and negation functions will be inlined directly.
                   *
                   *  The standard functors are derived from structs named @c unary_function
                   *  and @c binary_function.  These two classes contain nothing but typedefs,
                   *  to aid in generic (template) programming.  If you write your own
                   *  functors, you might consider doing the same.
                   *
                   *  @{
                   */
                  /**
                   *  This is one of the @link functors functor base classes@endlink.
                   */
                  template<typename _Arg, typename _Result>
                    struct unary_function
                    {
                      /// @c argument_type is the type of the argument
                      typedef _Arg 	argument_type;   
                
                      /// @c result_type is the return type
                      typedef _Result 	result_type;  
                    };
                
                  /**
                   *  This is one of the @link functors functor base classes@endlink.
                   */
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    struct binary_function
                    {
                      /// @c first_argument_type is the type of the first argument
                      typedef _Arg1 	first_argument_type; 
                
                      /// @c second_argument_type is the type of the second argument
                      typedef _Arg2 	second_argument_type;
                
                      /// @c result_type is the return type
                      typedef _Result 	result_type;
                    };
                  /** @}  */
                
                  // 20.3.2 arithmetic
                  /** @defgroup arithmetic_functors Arithmetic Classes
                   * @ingroup functors
                   *
                   *  Because basic math often needs to be done during an algorithm,
                   *  the library provides functors for those operations.  See the
                   *  documentation for @link functors the base classes@endlink
                   *  for examples of their use.
                   *
                   *  @{
                   */
                
                #if __cplusplus > 201103L
                  struct __is_transparent;  // undefined
                
                  template<typename _Tp = void>
                    struct plus;
                
                  template<typename _Tp = void>
                    struct minus;
                
                  template<typename _Tp = void>
                    struct multiplies;
                
                  template<typename _Tp = void>
                    struct divides;
                
                  template<typename _Tp = void>
                    struct modulus;
                
                  template<typename _Tp = void>
                    struct negate;
                #endif
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct plus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x + __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct minus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x - __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x * __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct divides : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x / __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct modulus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x % __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct negate : public unary_function<_Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x) const
                      { return -__x; }
                    };
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_transparent_operators 201510
                
                  template<>
                    struct plus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct minus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct multiplies<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct divides<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct modulus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct negate<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(-std::forward<_Tp>(__t)))
                	-> decltype(-std::forward<_Tp>(__t))
                	{ return -std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                  // 20.3.3 comparisons
                  /** @defgroup comparison_functors Comparison Classes
                   * @ingroup functors
                   *
                   *  The library provides six wrapper functors for all the basic comparisons
                   *  in C++, like @c <.
                   *
                   *  @{
                   */
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct equal_to;
                
                  template<typename _Tp = void>
                    struct not_equal_to;
                
                  template<typename _Tp = void>
                    struct greater;
                
                  template<typename _Tp = void>
                    struct less;
                
                  template<typename _Tp = void>
                    struct greater_equal;
                
                  template<typename _Tp = void>
                    struct less_equal;
                #endif
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x == __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x != __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct greater : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x > __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct less : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
    94201451 ->       operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x < __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct greater_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x >= __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct less_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x <= __y; }
                    };
                
                  // Partial specialization of std::greater for pointers.
                  template<typename _Tp>
                    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x > __y))
                #endif
                	  return __x > __y;
                #endif
                	return (__UINTPTR_TYPE__)__x > (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                  // Partial specialization of std::less for pointers.
                  template<typename _Tp>
                    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x < __y))
                #endif
                	  return __x < __y;
                #endif
                	return (__UINTPTR_TYPE__)__x < (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                  // Partial specialization of std::greater_equal for pointers.
                  template<typename _Tp>
                    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x >= __y))
                #endif
                	  return __x >= __y;
                #endif
                	return (__UINTPTR_TYPE__)__x >= (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                  // Partial specialization of std::less_equal for pointers.
                  template<typename _Tp>
                    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x <= __y))
                #endif
                	  return __x <= __y;
                #endif
                	return (__UINTPTR_TYPE__)__x <= (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                #if __cplusplus >= 201402L
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct equal_to<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct not_equal_to<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct greater<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return greater<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator> member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator>(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator> for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator>(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct less<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return less<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator< member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator<(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator< for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator<(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct greater_equal<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return greater_equal<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator>= member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator>=(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator>= for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator>=(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct less_equal<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return less_equal<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator<= member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator<=(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator<= for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator<=(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                #endif // C++14
                  /** @}  */
                
                  // 20.3.4 logical operations
                  /** @defgroup logical_functors Boolean Operations Classes
                   * @ingroup functors
                   *
                   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,
                   *  and @c !.
                   *
                   *  @{
                   */
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct logical_and;
                
                  template<typename _Tp = void>
                    struct logical_or;
                
                  template<typename _Tp = void>
                    struct logical_not;
                #endif
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_and : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x && __y; }
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_or : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x || __y; }
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_not : public unary_function<_Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x) const
                      { return !__x; }
                    };
                
                #if __cplusplus > 201103L
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_and<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_or<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_not<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(!std::forward<_Tp>(__t)))
                	-> decltype(!std::forward<_Tp>(__t))
                	{ return !std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct bit_and;
                
                  template<typename _Tp = void>
                    struct bit_or;
                
                  template<typename _Tp = void>
                    struct bit_xor;
                
                  template<typename _Tp = void>
                    struct bit_not;
                #endif
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 660. Missing Bitwise Operations.
                  template<typename _Tp>
                    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x & __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x | __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x ^ __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_not : public unary_function<_Tp, _Tp>
                    {
                    _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x) const
                      { return ~__x; }
                    };
                
                #if __cplusplus > 201103L
                  template <>
                    struct bit_and<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_or<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_xor<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_not<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(~std::forward<_Tp>(__t)))
                	-> decltype(~std::forward<_Tp>(__t))
                	{ return ~std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                
                  // 20.3.5 negators
                  /** @defgroup negators Negators
                   * @ingroup functors
                   *
                   *  The functions @c not1 and @c not2 each take a predicate functor
                   *  and return an instance of @c unary_negate or
                   *  @c binary_negate, respectively.  These classes are functors whose
                   *  @c operator() performs the stored predicate function and then returns
                   *  the negation of the result.
                   *
                   *  For example, given a vector of integers and a trivial predicate,
                   *  \code
                   *  struct IntGreaterThanThree
                   *    : public std::unary_function<int, bool>
                   *  {
                   *      bool operator() (int x) { return x > 3; }
                   *  };
                   *
                   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
                   *  \endcode
                   *  The call to @c find_if will locate the first index (i) of @c v for which
                   *  <code>!(v[i] > 3)</code> is true.
                   *
                   *  The not1/unary_negate combination works on predicates taking a single
                   *  argument.  The not2/binary_negate combination works on predicates which
                   *  take two arguments.
                   *
                   *  @{
                   */
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    class unary_negate
                    : public unary_function<typename _Predicate::argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                
                    public:
                      _GLIBCXX14_CONSTEXPR
                      explicit
                      unary_negate(const _Predicate& __x) : _M_pred(__x) { }
                
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const typename _Predicate::argument_type& __x) const
                      { return !_M_pred(__x); }
                    };
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    _GLIBCXX14_CONSTEXPR
                    inline unary_negate<_Predicate>
                    not1(const _Predicate& __pred)
                    { return unary_negate<_Predicate>(__pred); }
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    class binary_negate
                    : public binary_function<typename _Predicate::first_argument_type,
                			     typename _Predicate::second_argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                
                    public:
                      _GLIBCXX14_CONSTEXPR
                      explicit
                      binary_negate(const _Predicate& __x) : _M_pred(__x) { }
                
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const typename _Predicate::first_argument_type& __x,
                		 const typename _Predicate::second_argument_type& __y) const
                      { return !_M_pred(__x, __y); }
                    };
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    _GLIBCXX14_CONSTEXPR
                    inline binary_negate<_Predicate>
                    not2(const _Predicate& __pred)
                    { return binary_negate<_Predicate>(__pred); }
                  /** @}  */
                
                  // 20.3.7 adaptors pointers functions
                  /** @defgroup pointer_adaptors Adaptors for pointers to functions
                   * @ingroup functors
                   *
                   *  The advantage of function objects over pointers to functions is that
                   *  the objects in the standard library declare nested typedefs describing
                   *  their argument and result types with uniform names (e.g., @c result_type
                   *  from the base classes @c unary_function and @c binary_function).
                   *  Sometimes those typedefs are required, not just optional.
                   *
                   *  Adaptors are provided to turn pointers to unary (single-argument) and
                   *  binary (double-argument) functions into function objects.  The
                   *  long-winded functor @c pointer_to_unary_function is constructed with a
                   *  function pointer @c f, and its @c operator() called with argument @c x
                   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
                   *  thing, but with a double-argument @c f and @c operator().
                   *
                   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
                   *  an instance of the appropriate functor.
                   *
                   *  @{
                   */
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg, typename _Result>
                    class pointer_to_unary_function : public unary_function<_Arg, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg);
                
                    public:
                      pointer_to_unary_function() { }
                
                      explicit
                      pointer_to_unary_function(_Result (*__x)(_Arg))
                      : _M_ptr(__x) { }
                
                      _Result
                      operator()(_Arg __x) const
                      { return _M_ptr(__x); }
                    };
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg, typename _Result>
                    inline pointer_to_unary_function<_Arg, _Result>
                    ptr_fun(_Result (*__x)(_Arg))
                    { return pointer_to_unary_function<_Arg, _Result>(__x); }
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    class pointer_to_binary_function
                    : public binary_function<_Arg1, _Arg2, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg1, _Arg2);
                
                    public:
                      pointer_to_binary_function() { }
                
                      explicit
                      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
                      : _M_ptr(__x) { }
                
                      _Result
                      operator()(_Arg1 __x, _Arg2 __y) const
                      { return _M_ptr(__x, __y); }
                    };
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
                    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
                    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
                  /** @}  */
                
                  template<typename _Tp>
                    struct _Identity
                    : public unary_function<_Tp, _Tp>
                    {
                      _Tp&
                      operator()(_Tp& __x) const
                      { return __x; }
                
                      const _Tp&
   104816115 ->       operator()(const _Tp& __x) const
                      { return __x; }
                    };
                
                  // Partial specialization, avoids confusing errors in e.g. std::set<const T>.
                  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };
                
                  template<typename _Pair>
                    struct _Select1st
                    : public unary_function<_Pair, typename _Pair::first_type>
                    {
                      typename _Pair::first_type&
                      operator()(_Pair& __x) const
                      { return __x.first; }
                
                      const typename _Pair::first_type&
                      operator()(const _Pair& __x) const
                      { return __x.first; }
                
                #if __cplusplus >= 201103L
                      template<typename _Pair2>
                        typename _Pair2::first_type&
                        operator()(_Pair2& __x) const
                        { return __x.first; }
                
                      template<typename _Pair2>
                        const typename _Pair2::first_type&
                        operator()(const _Pair2& __x) const
                        { return __x.first; }
                #endif
                    };
                
                  template<typename _Pair>
                    struct _Select2nd
                    : public unary_function<_Pair, typename _Pair::second_type>
                    {
                      typename _Pair::second_type&
                      operator()(_Pair& __x) const
                      { return __x.second; }
                
                      const typename _Pair::second_type&
                      operator()(const _Pair& __x) const
                      { return __x.second; }
                    };
                
                  // 20.3.8 adaptors pointers members
                  /** @defgroup memory_adaptors Adaptors for pointers to members
                   * @ingroup functors
                   *
                   *  There are a total of 8 = 2^3 function objects in this family.
                   *   (1) Member functions taking no arguments vs member functions taking
                   *        one argument.
                   *   (2) Call through pointer vs call through reference.
                   *   (3) Const vs non-const member function.
                   *
                   *  All of this complexity is in the function objects themselves.  You can
                   *   ignore it by using the helper function mem_fun and mem_fun_ref,
                   *   which create whichever type of adaptor is appropriate.
                   *
                   *  @{
                   */
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class mem_fun_t : public unary_function<_Tp*, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp* __p) const
                      { return (__p->*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)();
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp* __p) const
                      { return (__p->*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_ref_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp& __r) const
                      { return (__r.*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)();
                  };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp& __r) const
                      { return (__r.*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  // Mem_fun adaptor helper functions.  There are only two:
                  // mem_fun and mem_fun_ref.
                  template<typename _Ret, typename _Tp>
                    inline mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)())
                    { return mem_fun_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline const_mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)())
                    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline const_mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  /** @}  */
                
                #if __cplusplus >= 201402L
                  template<typename _Func, typename _SfinaeType, typename = __void_t<>>
                    struct __has_is_transparent
                    { };
                
                  template<typename _Func, typename _SfinaeType>
                    struct __has_is_transparent<_Func, _SfinaeType,
                				__void_t<typename _Func::is_transparent>>
                    { typedef void type; };
                
                  template<typename _Func, typename _SfinaeType>
                    using __has_is_transparent_t
                      = typename __has_is_transparent<_Func, _SfinaeType>::type;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if (__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED
                # include <backward/binders.h>
                #endif
                
                #endif /* _STL_FUNCTION_H */


Top 10 Lines:

     Line      Count

     1139  104816115
      385   94201451

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

199017566   Total number of line executions
99508783.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_iterator_base_types.h:
                // Types used in iterator implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_types.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility types,
                 *  such as iterator_traits and struct iterator.
                 */
                
                #ifndef _STL_ITERATOR_BASE_TYPES_H
                #define _STL_ITERATOR_BASE_TYPES_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>  // For __void_t, is_convertible
                #endif
                
                #if __cplusplus > 201703L && __cpp_concepts >= 201907L
                # include <bits/iterator_concepts.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @defgroup iterators Iterators
                   *  Abstractions for uniform iterating through various underlying types.
                  */
                  ///@{
                
                  /**
                   *  @defgroup iterator_tags Iterator Tags
                   *  These are empty types, used to distinguish different iterators.  The
                   *  distinction is not made by what they contain, but simply by what they
                   *  are.  Different underlying algorithms can then be used based on the
                   *  different operations supported by different iterator types.
                  */
                  ///@{
                  ///  Marking input iterators.
                  struct input_iterator_tag { };
                
                  ///  Marking output iterators.
                  struct output_iterator_tag { };
                
                  /// Forward iterators support a superset of input iterator operations.
                  struct forward_iterator_tag : public input_iterator_tag { };
                
                  /// Bidirectional iterators support a superset of forward iterator
                  /// operations.
                  struct bidirectional_iterator_tag : public forward_iterator_tag { };
                
                  /// Random-access iterators support a superset of bidirectional
                  /// iterator operations.
                  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
                
                #if __cplusplus > 201703L
                  /// Contiguous iterators point to objects stored contiguously in memory.
                  struct contiguous_iterator_tag : public random_access_iterator_tag { };
                #endif
                  ///@}
                
                  /**
                   *  @brief  Common %iterator class.
                   *
                   *  This class does nothing but define nested typedefs.  %Iterator classes
                   *  can inherit from this class to save some work.  The typedefs are then
                   *  used in specializations and overloading.
                   *
                   *  In particular, there are no default implementations of requirements
                   *  such as @c operator++ and the like.  (How could there be?)
                  */
                  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
                           typename _Pointer = _Tp*, typename _Reference = _Tp&>
                    struct iterator
                    {
                      /// One of the @link iterator_tags tag types@endlink.
                      typedef _Category  iterator_category;
                      /// The type "pointed to" by the iterator.
                      typedef _Tp        value_type;
                      /// Distance between iterators is represented as this type.
                      typedef _Distance  difference_type;
                      /// This type represents a pointer-to-value_type.
                      typedef _Pointer   pointer;
                      /// This type represents a reference-to-value_type.
                      typedef _Reference reference;
                    };
                
                  /**
                   *  @brief  Traits class for iterators.
                   *
                   *  This class does nothing but define nested typedefs.  The general
                   *  version simply @a forwards the nested typedefs from the Iterator
                   *  argument.  Specialized versions for pointers and pointers-to-const
                   *  provide tighter, more correct semantics.
                  */
                  template<typename _Iterator>
                    struct iterator_traits;
                
                #if __cplusplus >= 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14
                  template<typename _Iterator, typename = __void_t<>>
                    struct __iterator_traits { };
                
                #if ! __cpp_lib_concepts
                
                  template<typename _Iterator>
                    struct __iterator_traits<_Iterator,
                			     __void_t<typename _Iterator::iterator_category,
                				      typename _Iterator::value_type,
                				      typename _Iterator::difference_type,
                				      typename _Iterator::pointer,
                				      typename _Iterator::reference>>
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif // ! concepts
                
                  template<typename _Iterator>
                    struct iterator_traits
                    : public __iterator_traits<_Iterator> { };
                
                #else // ! C++11
                  template<typename _Iterator>
                    struct iterator_traits
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif // C++11
                
                #if __cplusplus > 201703L
                  /// Partial specialization for object pointer types.
                  template<typename _Tp>
                #if __cpp_concepts >= 201907L
                    requires is_object_v<_Tp>
                #endif
                    struct iterator_traits<_Tp*>
                    {
                      using iterator_concept  = contiguous_iterator_tag;
                      using iterator_category = random_access_iterator_tag;
                      using value_type	      = remove_cv_t<_Tp>;
                      using difference_type   = ptrdiff_t;
                      using pointer	      = _Tp*;
                      using reference	      = _Tp&;
                    };
                #else
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct iterator_traits<_Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef _Tp*                        pointer;
                      typedef _Tp&                        reference;
                    };
                
                  /// Partial specialization for const pointer types.
                  template<typename _Tp>
                    struct iterator_traits<const _Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef const _Tp*                  pointer;
                      typedef const _Tp&                  reference;
                    };
                #endif
                
                  /**
                   *  This function is not a part of the C++ standard but is syntactic
                   *  sugar for internal library use only.
                  */
                  template<typename _Iter>
                    inline _GLIBCXX_CONSTEXPR
                    typename iterator_traits<_Iter>::iterator_category
      360000 ->     __iterator_category(const _Iter&)
                    { return typename iterator_traits<_Iter>::iterator_category(); }
                
                  ///@}
                
                #if __cplusplus >= 201103L
                  template<typename _Iter>
                    using __iterator_category_t
                      = typename iterator_traits<_Iter>::iterator_category;
                
                  template<typename _InIter>
                    using _RequireInputIter =
                      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
                				   input_iterator_tag>::value>;
                
                  template<typename _It,
                	   typename _Cat = __iterator_category_t<_It>>
                    struct __is_random_access_iter
                      : is_base_of<random_access_iterator_tag, _Cat>
                    {
                      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
                      enum { __value = _Base::value };
                    };
                #else
                  template<typename _It, typename _Traits = iterator_traits<_It>,
                	   typename _Cat = typename _Traits::iterator_category>
                    struct __is_random_access_iter
                    { enum { __value = __is_base_of(random_access_iterator_tag, _Cat) }; };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_TYPES_H */


Top 10 Lines:

     Line      Count

      238     360000

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   360000   Total number of line executions
360000.00   Average executions per line


*** File /usr/include/c++/11/ext/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/alloc_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_ALLOC_TRAITS_H
                #define _EXT_ALLOC_TRAITS_H 1
                
                #pragma GCC system_header
                
                # include <bits/alloc_traits.h>
                #if __cplusplus < 201103L
                # include <bits/allocator.h>  // for __alloc_swap
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                /**
                 * @brief  Uniform interface to C++98 and C++11 allocators.
                 * @ingroup allocators
                */
                template<typename _Alloc, typename = typename _Alloc::value_type>
                  struct __alloc_traits
                #if __cplusplus >= 201103L
                  : std::allocator_traits<_Alloc>
                #endif
                  {
                    typedef _Alloc allocator_type;
                #if __cplusplus >= 201103L
                    typedef std::allocator_traits<_Alloc>           _Base_type;
                    typedef typename _Base_type::value_type         value_type;
                    typedef typename _Base_type::pointer            pointer;
                    typedef typename _Base_type::const_pointer      const_pointer;
                    typedef typename _Base_type::size_type          size_type;
                    typedef typename _Base_type::difference_type    difference_type;
                    // C++11 allocators do not define reference or const_reference
                    typedef value_type&                             reference;
                    typedef const value_type&                       const_reference;
                    using _Base_type::allocate;
                    using _Base_type::deallocate;
                    using _Base_type::construct;
                    using _Base_type::destroy;
                    using _Base_type::max_size;
                
                  private:
                    template<typename _Ptr>
                      using __is_custom_pointer
                	= std::__and_<std::is_same<pointer, _Ptr>,
                		      std::__not_<std::is_pointer<_Ptr>>>;
                
                  public:
                    // overload construct for non-standard pointer types
                    template<typename _Ptr, typename... _Args>
                      static _GLIBCXX14_CONSTEXPR
                      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
                      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
                      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
                					      std::forward<_Args>(__args)...)))
                      {
                	_Base_type::construct(__a, std::__to_address(__p),
                			      std::forward<_Args>(__args)...);
                      }
                
                    // overload destroy for non-standard pointer types
                    template<typename _Ptr>
                      static _GLIBCXX14_CONSTEXPR
                      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
                      destroy(_Alloc& __a, _Ptr __p)
                      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
                      { _Base_type::destroy(__a, std::__to_address(__p)); }
                
     2263615 ->     static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
                    { return _Base_type::select_on_container_copy_construction(__a); }
                
                    static _GLIBCXX14_CONSTEXPR void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    { std::__alloc_on_swap(__a, __b); }
                
     2861942 ->     static constexpr bool _S_propagate_on_copy_assign()
                    { return _Base_type::propagate_on_container_copy_assignment::value; }
                
                    static constexpr bool _S_propagate_on_move_assign()
                    { return _Base_type::propagate_on_container_move_assignment::value; }
                
                    static constexpr bool _S_propagate_on_swap()
                    { return _Base_type::propagate_on_container_swap::value; }
                
       ##### ->     static constexpr bool _S_always_equal()
                    { return _Base_type::is_always_equal::value; }
                
                    static constexpr bool _S_nothrow_move()
                    { return _S_propagate_on_move_assign() || _S_always_equal(); }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
                #else // ! C++11
                
                    typedef typename _Alloc::pointer                pointer;
                    typedef typename _Alloc::const_pointer          const_pointer;
                    typedef typename _Alloc::value_type             value_type;
                    typedef typename _Alloc::reference              reference;
                    typedef typename _Alloc::const_reference        const_reference;
                    typedef typename _Alloc::size_type              size_type;
                    typedef typename _Alloc::difference_type        difference_type;
                
                    _GLIBCXX_NODISCARD static pointer
                    allocate(_Alloc& __a, size_type __n)
                    { return __a.allocate(__n); }
                
                    template<typename _Hint>
                      _GLIBCXX_NODISCARD static pointer
                      allocate(_Alloc& __a, size_type __n, _Hint __hint)
                      { return __a.allocate(__n, __hint); }
                
                    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                    { __a.deallocate(__p, __n); }
                
                    template<typename _Tp>
                      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
                      { __a.construct(__p, __arg); }
                
                    static void destroy(_Alloc& __a, pointer __p)
                    { __a.destroy(__p); }
                
                    static size_type max_size(const _Alloc& __a)
                    { return __a.max_size(); }
                
                    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Alloc::template rebind<_Tp>::other other; };
                #endif // C++11
                  };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

      103    2861942
       97    2263615

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

  5125557   Total number of line executions
1708519.00   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/./Genetic-Algorithm/Crossover/uniform_partially_mapped_crossover.cpp:
                #include "uniform_partially_mapped_crossover.hpp"
                #include "../Path_representation.hpp"
                #include <vector>
                #include <utility>
                #include <cstdlib>
                
                using std::vector;
                using std::pair;
                
                
                pair<PathRepresentation, PathRepresentation> UniformPartiallyMappedCrossover::
                      crosslink(const PathRepresentation &A, const PathRepresentation &B)
       90000 -> {
                
                  vector<int> pathA = A.get_order();
                  vector<int> pathB = B.get_order();
                
                  vector<int> offspring1(pathA);
                  vector<int> offspring2(pathB);
                
                  unsigned numCities = std::min(pathA.size(), pathB.size());
                
                  vector<int> partialMapA(numCities);
                  vector<int> partialMapB(numCities);
                
                  // Initilize the partialmaps
                  for(unsigned i = 0 ; i < numCities; ++i)
                  {
                    partialMapA[pathA[i]] = i;
                    partialMapB[pathB[i]] = i;
                  }
                
                  // Generate random crossover points
                  unsigned randomIndex1;
                  unsigned randomIndex2;
                  do
                  {
                    randomIndex1 = rand() % (numCities);
                    randomIndex2 = rand() % (numCities);
                  }
                  while(randomIndex1 >= randomIndex2);
                
                  for(unsigned i = randomIndex1; i <= randomIndex2; ++i)
                  {
                    // selected values
                    int temp1 = pathA[i];
                    int temp2 = pathB[i];
                
                    std::swap(offspring1[partialMapA[temp2]], offspring1[i]);
                    std::swap(offspring2[partialMapB[temp1]], offspring2[i]);
                
                    // update the maps
                    std::swap(partialMapA[temp1], partialMapA[temp2]);
                    std::swap(partialMapB[temp1], partialMapB[temp2]);
                  }
                
                  PathRepresentation Offspring1(offspring1);
                  PathRepresentation Offspring2(offspring2);
                
                  return pair{Offspring2, Offspring1};
                }


Top 10 Lines:

     Line      Count

       13      90000

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    90000   Total number of line executions
 90000.00   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/Genetic-Algorithm/Crossover/uniform_partially_mapped_crossover.hpp:
                #ifndef UNIFORM_PARTIALLY_MAPPED_CROSSOVER_H
                #define UNIFORM_PARTIALLY_MAPPED_CROSSOVER_H
                /*
                 * @file Crossover/partially_mapped_crossover.hpp
                 * @author Shah Anwaar Khalid
                 *
                 * This class implements partially_mapped_crossover between
                 * two genomes, given their path representation.
                 */
                
                #include "crossover_base.hpp"
                
                class UniformPartiallyMappedCrossover : public Crossover {
                
                  public:
                    
                    //! Constructor
           1 ->     UniformPartiallyMappedCrossover(){};
                
                    //! Destructor
           1 ->     ~UniformPartiallyMappedCrossover(){};
                
                    //! Crossover function
                    std::pair<PathRepresentation, PathRepresentation>
                      crosslink(const PathRepresentation&A, const PathRepresentation& B);
                
                };
                #endif


Top 10 Lines:

     Line      Count

       18          1
       21          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/c++/11/ext/aligned_buffer.h:
                // Aligned memory buffer -*- C++ -*-
                
                // Copyright (C) 2013-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/aligned_buffer.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _ALIGNED_BUFFER_H
                #define _ALIGNED_BUFFER_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #else
                # include <bits/c++0x_warning.h>
                #endif
                
                namespace __gnu_cxx
                {
                  // A utility type containing a POD object that can hold an object of type
                  // _Tp initialized via placement new or allocator_traits::construct.
                  // Intended for use as a data member subobject, use __aligned_buffer for
                  // complete objects.
                  template<typename _Tp>
                    struct __aligned_membuf
                    {
                      // Target macro ADJUST_FIELD_ALIGN can produce different alignment for
                      // types when used as class members. __aligned_membuf is intended
                      // for use as a class member, so align the buffer as for a class member.
                      // Since GCC 8 we could just use alignof(_Tp) instead, but older
                      // versions of non-GNU compilers might still need this trick.
                      struct _Tp2 { _Tp _M_t; };
                
                      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
                
                      __aligned_membuf() = default;
                
                      // Can be used to avoid value-initialization zeroing _M_storage.
                      __aligned_membuf(std::nullptr_t) { }
                
                      void*
    10794664 ->       _M_addr() noexcept
                      { return static_cast<void*>(&_M_storage); }
                
                      const void*
    94201451 ->       _M_addr() const noexcept
                      { return static_cast<const void*>(&_M_storage); }
                
                      _Tp*
    10794664 ->       _M_ptr() noexcept
                      { return static_cast<_Tp*>(_M_addr()); }
                
                      const _Tp*
    94201451 ->       _M_ptr() const noexcept
                      { return static_cast<const _Tp*>(_M_addr()); }
                    };
                
                #if _GLIBCXX_INLINE_VERSION
                  template<typename _Tp>
                    using __aligned_buffer = __aligned_membuf<_Tp>;
                #else
                  // Similar to __aligned_membuf but aligned for complete objects, not members.
                  // This type is used in <forward_list>, <future>, <bits/shared_ptr_base.h>
                  // and <bits/hashtable_policy.h>, but ideally they would use __aligned_membuf
                  // instead, as it has smaller size for some types on some targets.
                  // This type is still used to avoid an ABI change.
                  template<typename _Tp>
                    struct __aligned_buffer
                    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
                    {
                      typename
                	std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
                
                      __aligned_buffer() = default;
                
                      // Can be used to avoid value-initialization
                      __aligned_buffer(std::nullptr_t) { }
                
                      void*
                      _M_addr() noexcept
                      {
                        return static_cast<void*>(&_M_storage);
                      }
                
                      const void*
                      _M_addr() const noexcept
                      {
                        return static_cast<const void*>(&_M_storage);
                      }
                
                      _Tp*
                      _M_ptr() noexcept
                      { return static_cast<_Tp*>(_M_addr()); }
                
                      const _Tp*
                      _M_ptr() const noexcept
                      { return static_cast<const _Tp*>(_M_addr()); }
                    };
                #endif
                
                } // namespace
                
                #endif /* _ALIGNED_BUFFER_H */


Top 10 Lines:

     Line      Count

       68   94201451
       76   94201451
       64   10794664
       72   10794664

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

209992230   Total number of line executions
52498057.50   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/Genetic-Algorithm/Crossover/random_crossover.hpp:
                #ifndef RANDOM_CROSSOVER_H
                #define RANDOM_CROSSOVER_H
                
                /*
                 * @file Crossover/random_crossover.hpp
                 * @author Shah Anwaar Khalid
                 *
                 * This class represents random_crossover between two genomes,
                 * given their path representation.
                 */
                
                #include "crossover_base.hpp"
                
                class RandomCrossover : public Crossover {
                
                  public:
                
                    //! Constructor
           1 ->     RandomCrossover() {};
                
                    //! Destructor
           1 ->     ~RandomCrossover() {};
                
                    //! Crossover function
                    std::pair<PathRepresentation, PathRepresentation>
                        crosslink(const PathRepresentation &A, const PathRepresentation &B);
                };
                
                #endif


Top 10 Lines:

     Line      Count

       19          1
       22          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/Genetic-Algorithm/Crossover/crossover_base.hpp:
                #ifndef CROSSOVER_BASE_H
                #define CROSSOVER_BASE_H
                
                /*
                 * @file Crossover/crossover_base.hpp
                 * @author Shah Anwaar Khalid
                 *
                 * This abstract class represents a crossover between two genomes,
                 * given their path represenation.
                 */
                
                // Forward Declaration of PathRepresentation Class.
                class PathRepresentation;
                
                #include <utility>
                
                class Crossover{
                  public:
                    //! Constructor
           3 ->     Crossover() {};
                    
                    //! Destructor
           3 ->     ~Crossover() {};
                
                    //! Performs crossover of two genomes
                    virtual std::pair<PathRepresentation, PathRepresentation> crosslink
                           (const PathRepresentation &A, const PathRepresentation & B)  = 0;
                };
                
                #endif


Top 10 Lines:

     Line      Count

       20          3
       23          3

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     3.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _STL_PAIR_H
                #define _STL_PAIR_H 1
                
                #include <bits/move.h> // for std::move / std::forward, and std::swap
                
                #if __cplusplus >= 201103L
                # include <type_traits> // for std::__decay_and_strip, std::is_reference_v
                #endif
                #if __cplusplus > 201703L
                # include <compare>
                # define __cpp_lib_constexpr_utility 201811L
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                #if __cplusplus >= 201103L
                  /// Tag type for piecewise construction of std::pair objects.
                  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
                
                  /// Tag for piecewise construction of std::pair objects.
                  _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =
                    piecewise_construct_t();
                
                  /// @cond undocumented
                
                  // Forward declarations.
                  template<typename...>
                    class tuple;
                
                  template<size_t...>
                    struct _Index_tuple;
                
                  // Concept utility functions, reused in conditionally-explicit
                  // constructors.
                  // See PR 70437, don't look at is_constructible or
                  // is_convertible if the types are the same to
                  // avoid querying those properties for incomplete types.
                  template <bool, typename _T1, typename _T2>
                    struct _PCC
                    {
                      template <typename _U1, typename _U2>
                      static constexpr bool _ConstructiblePair()
                      {
                	return __and_<is_constructible<_T1, const _U1&>,
                		      is_constructible<_T2, const _U2&>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyConvertiblePair()
                      {
                	return __and_<is_convertible<const _U1&, _T1>,
                		      is_convertible<const _U2&, _T2>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _MoveConstructiblePair()
                      {
                	return __and_<is_constructible<_T1, _U1&&>,
                		      is_constructible<_T2, _U2&&>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyMoveConvertiblePair()
                      {
                	return __and_<is_convertible<_U1&&, _T1>,
                		      is_convertible<_U2&&, _T2>>::value;
                      }
                
                      template <bool __implicit, typename _U1, typename _U2>
                      static constexpr bool _CopyMovePair()
                      {
                	using __do_converts = __and_<is_convertible<const _U1&, _T1>,
                				  is_convertible<_U2&&, _T2>>;
                	using __converts = typename conditional<__implicit,
                				       __do_converts,
                				       __not_<__do_converts>>::type;
                	return __and_<is_constructible<_T1, const _U1&>,
                		      is_constructible<_T2, _U2&&>,
                		      __converts
                		      >::value;
                      }
                
                      template <bool __implicit, typename _U1, typename _U2>
                      static constexpr bool _MoveCopyPair()
                      {
                	using __do_converts = __and_<is_convertible<_U1&&, _T1>,
                				  is_convertible<const _U2&, _T2>>;
                	using __converts = typename conditional<__implicit,
                				       __do_converts,
                				       __not_<__do_converts>>::type;
                	return __and_<is_constructible<_T1, _U1&&>,
                		      is_constructible<_T2, const _U2&&>,
                		      __converts
                		      >::value;
                      }
                  };
                
                  template <typename _T1, typename _T2>
                    struct _PCC<false, _T1, _T2>
                    {
                      template <typename _U1, typename _U2>
                      static constexpr bool _ConstructiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyConvertiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _MoveConstructiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyMoveConvertiblePair()
                      {
                	return false;
                      }
                  };
                #endif // C++11
                
                  template<typename _U1, typename _U2> class __pair_base
                  {
                #if __cplusplus >= 201103L
                    template<typename _T1, typename _T2> friend struct pair;
                    __pair_base() = default;
                    ~__pair_base() = default;
                    __pair_base(const __pair_base&) = default;
                    __pair_base& operator=(const __pair_base&) = delete;
                #endif // C++11
                  };
                
                  /// @endcond
                
                 /**
                   *  @brief Struct holding two objects of arbitrary type.
                   *
                   *  @tparam _T1  Type of first object.
                   *  @tparam _T2  Type of second object.
                   *
                   *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                   */
                  template<typename _T1, typename _T2>
      270000 ->     struct pair
                    : private __pair_base<_T1, _T2>
                    {
                      typedef _T1 first_type;    ///< The type of the `first` member
                      typedef _T2 second_type;   ///< The type of the `second` member
                
                      _T1 first;                 ///< The first member
                      _T2 second;                ///< The second member
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                #if __cplusplus >= 201103L
                      template <typename _U1 = _T1,
                                typename _U2 = _T2,
                                typename enable_if<__and_<
                                                     __is_implicitly_default_constructible<_U1>,
                                                     __is_implicitly_default_constructible<_U2>>
                                                   ::value, bool>::type = true>
                #endif
                      _GLIBCXX_CONSTEXPR pair()
                      : first(), second() { }
                
                #if __cplusplus >= 201103L
                      template <typename _U1 = _T1,
                                typename _U2 = _T2,
                                typename enable_if<__and_<
                                       is_default_constructible<_U1>,
                                       is_default_constructible<_U2>,
                                       __not_<
                                         __and_<__is_implicitly_default_constructible<_U1>,
                                                __is_implicitly_default_constructible<_U2>>>>
                                                   ::value, bool>::type = false>
                      explicit constexpr pair()
                      : first(), second() { }
                #endif
                
                #if __cplusplus < 201103L
                      /// Two objects may be passed to a @c pair constructor to be copied.
                      pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                #else
                      // Shortcut for constraining the templates that don't take pairs.
                      /// @cond undocumented
                      using _PCCP = _PCC<true, _T1, _T2>;
                      /// @endcond
                
                      /// Construct from two const lvalues, allowing implicit conversions.
                      template<typename _U1 = _T1, typename _U2=_T2, typename
                	       enable_if<_PCCP::template
                			   _ConstructiblePair<_U1, _U2>()
                	                 && _PCCP::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
                      constexpr pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                      /// Construct from two const lvalues, disallowing implicit conversions.
                       template<typename _U1 = _T1, typename _U2=_T2, typename
                		enable_if<_PCCP::template
                			    _ConstructiblePair<_U1, _U2>()
                	                  && !_PCCP::template
                			    _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                      explicit constexpr pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                #endif
                
                #if __cplusplus < 201103L
                      /// There is also a templated constructor to convert from other pairs.
                      template<typename _U1, typename _U2>
                	pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #else
                      // Shortcut for constraining the templates that take pairs.
                      /// @cond undocumented
                      template <typename _U1, typename _U2>
                        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
                			    || !is_same<_T2, _U2>::value,
                			    _T1, _T2>;
                      /// @endcond
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _ConstructiblePair<_U1, _U2>()
                	                 && _PCCFP<_U1, _U2>::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                			  bool>::type=true>
                        constexpr pair(const pair<_U1, _U2>& __p)
                        : first(__p.first), second(__p.second) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _ConstructiblePair<_U1, _U2>()
                			 && !_PCCFP<_U1, _U2>::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #endif
                
                #if __cplusplus >= 201103L
                      constexpr pair(const pair&) = default;	///< Copy constructor
                      constexpr pair(pair&&) = default;		///< Move constructor
                
                      // DR 811.
                      template<typename _U1, typename
                	       enable_if<_PCCP::template
                			   _MoveCopyPair<true, _U1, _T2>(),
                                         bool>::type=true>
       ##### ->        constexpr pair(_U1&& __x, const _T2& __y)
                       : first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<typename _U1, typename
                	       enable_if<_PCCP::template
                			   _MoveCopyPair<false, _U1, _T2>(),
                                         bool>::type=false>
                       explicit constexpr pair(_U1&& __x, const _T2& __y)
                       : first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<typename _U2, typename
                	       enable_if<_PCCP::template
                			   _CopyMovePair<true, _T1, _U2>(),
                                         bool>::type=true>
                       constexpr pair(const _T1& __x, _U2&& __y)
                       : first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U2, typename
                	       enable_if<_PCCP::template
                			   _CopyMovePair<false, _T1, _U2>(),
                                         bool>::type=false>
                       explicit pair(const _T1& __x, _U2&& __y)
                       : first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCP::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && _PCCP::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
    16461996 -> 	constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCP::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && !_PCCP::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && _PCCFP<_U1, _U2>::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
                	constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && !_PCCFP<_U1, _U2>::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename... _Args1, typename... _Args2>
                	_GLIBCXX20_CONSTEXPR
                        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
                
                      _GLIBCXX20_CONSTEXPR pair&
                      operator=(typename conditional<
                		__and_<is_copy_assignable<_T1>,
                		       is_copy_assignable<_T2>>::value,
                		const pair&, const __nonesuch&>::type __p)
                      {
                	first = __p.first;
                	second = __p.second;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR pair&
                      operator=(typename conditional<
                		__and_<is_move_assignable<_T1>,
                		       is_move_assignable<_T2>>::value,
                		pair&&, __nonesuch&&>::type __p)
                      noexcept(__and_<is_nothrow_move_assignable<_T1>,
                		      is_nothrow_move_assignable<_T2>>::value)
                      {
                	first = std::forward<first_type>(__p.first);
                	second = std::forward<second_type>(__p.second);
                	return *this;
                      }
                
                      template<typename _U1, typename _U2>
                	_GLIBCXX20_CONSTEXPR
                	typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
                				  is_assignable<_T2&, const _U2&>>::value,
                			   pair&>::type
                	operator=(const pair<_U1, _U2>& __p)
                	{
                	  first = __p.first;
                	  second = __p.second;
                	  return *this;
                	}
                
                      template<typename _U1, typename _U2>
                	_GLIBCXX20_CONSTEXPR
                	typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
                				  is_assignable<_T2&, _U2&&>>::value,
                			   pair&>::type
                	operator=(pair<_U1, _U2>&& __p)
                	{
                	  first = std::forward<_U1>(__p.first);
                	  second = std::forward<_U2>(__p.second);
                	  return *this;
                	}
                
                      /// Swap the first members and then the second members.
                      _GLIBCXX20_CONSTEXPR void
                      swap(pair& __p)
                      noexcept(__and_<__is_nothrow_swappable<_T1>,
                                      __is_nothrow_swappable<_T2>>::value)
                      {
                	using std::swap;
                	swap(first, __p.first);
                	swap(second, __p.second);
                      }
                
                    private:
                      template<typename... _Args1, size_t... _Indexes1,
                	       typename... _Args2, size_t... _Indexes2>
                	_GLIBCXX20_CONSTEXPR
                        pair(tuple<_Args1...>&, tuple<_Args2...>&,
                	     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
                #endif // C++11
                    };
                
                  /// @relates pair @{
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
                #endif
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                #if __cpp_lib_three_way_comparison && __cpp_lib_concepts
                  template<typename _T1, typename _T2>
                    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>,
                					   __detail::__synth3way_t<_T2>>
                    operator<=>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    {
                      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
                	return __c;
                      return __detail::__synth3way(__x.second, __y.second);
                    }
                #else
                  /** Defines a lexicographical order for pairs.
                   *
                   * For two pairs of the same type, `P` is ordered before `Q` if
                   * `P.first` is less than `Q.first`, or if `P.first` and `Q.first`
                   * are equivalent (neither is less than the other) and `P.second` is less
                   * than `Q.second`.
                  */
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                #endif // !(three_way_comparison && concepts)
                
                #if __cplusplus >= 201103L
                  /** Swap overload for pairs. Calls std::pair::swap().
                   *
                   * @note This std::swap overload is not declared in C++03 mode,
                   * which has performance implications, e.g. see https://gcc.gnu.org/PR38466
                  */
                  template<typename _T1, typename _T2>
                    _GLIBCXX20_CONSTEXPR inline
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                    // Constrained free swap overload, see p0185r1
                    typename enable_if<__and_<__is_swappable<_T1>,
                                              __is_swappable<_T2>>::value>::type
                #else
                    void
                #endif
                    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                  template<typename _T1, typename _T2>
                    typename enable_if<!__and_<__is_swappable<_T1>,
                			       __is_swappable<_T2>>::value>::type
                    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
                #endif
                #endif // __cplusplus >= 201103L
                
                  /// @} relates pair
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  __x  The first object.
                   *  @param  __y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The C++98 standard says the objects are passed by reference-to-const,
                   *  but C++03 says they are passed by value (this was LWG issue #181).
                   *
                   *  Since C++11 they have been passed by forwarding reference and then
                   *  forwarded to the new members of the pair. To create a pair with a
                   *  member of reference type, pass a `reference_wrapper` to this function.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                #if __cplusplus >= 201103L
                  // NB: DR 706.
                  template<typename _T1, typename _T2>
                    constexpr pair<typename __decay_and_strip<_T1>::__type,
                                   typename __decay_and_strip<_T2>::__type>
                    make_pair(_T1&& __x, _T2&& __y)
                    {
                      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
                      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
                      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
                      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
                    }
                #else
                  template<typename _T1, typename _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                #endif
                
                  /// @}
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_PAIR_H */


Top 10 Lines:

     Line      Count

      352   16461996
      211     270000

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

 16731996   Total number of line executions
5577332.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                #include <bits/stl_algobase.h>    // copy
                #include <ext/alloc_traits.h>     // __alloc_traits
                
                #if __cplusplus >= 201703L
                #include <bits/stl_pair.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /** @addtogroup memory
                   *  @{
                   */
                
                  /// @cond undocumented
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
          80 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, (void)++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
     2803615 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /// @endcond
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
     2803695 ->     uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::copy
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
                	  "result type must be constructible from value type of input range");
                
                      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
                      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
                      // Trivial types can have deleted assignment, so using std::copy
                      // would be ill-formed. Require assignability before using std::copy:
                      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
                #endif
                
                      return std::__uninitialized_copy<__is_trivial(_ValueType1)
                				       && __is_trivial(_ValueType2)
                				       && __assignable>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                  /// @cond undocumented
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /// @endcond
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill
                      // would be ill-formed. Require assignability before using std::fill:
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                  /// @cond undocumented
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { return std::fill_n(__first, __n, __x); }
                    };
                
                  /// @endcond
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 1339. uninitialized_fill_n should return the end of its range
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
                    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      // Trivial types do not need a constructor to begin their lifetime,
                      // so try to use std::fill_n to benefit from its memmove optimization.
                      // For arbitrary class types and floating point types we can't assume
                      // that __n > 0 and std::__size_to_integer(__n) > 0 are equivalent,
                      // so only use std::fill_n when _Size is already an integral type.
                #if __cplusplus < 201103L
                      const bool __can_fill = __is_integer<_Size>::__value;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill_n
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill_n
                      // would be ill-formed. Require assignability before using std::fill_n:
                      constexpr bool __can_fill
                	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
                #endif
                      return __uninitialized_fill_n<__is_trivial(_ValueType) && __can_fill>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  /// @cond undocumented
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, (void)++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
     2803695 ->     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
          80 ->     __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { return std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  /// @endcond
                
                #if __cplusplus >= 201103L
                  /// @cond undocumented
                
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  if (__first == __last)
                	    return;
                
                	  typename iterator_traits<_ForwardIterator>::value_type* __val
                	    = std::__addressof(*__first);
                	  std::_Construct(__val);
                	  if (++__first != __last)
                	    std::fill(__first, __last, *__val);
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
      360000 ->         __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  if (__n > 0)
                	    {
                	      typename iterator_traits<_ForwardIterator>::value_type* __val
                		= std::__addressof(*__first);
                	      std::_Construct(__val);
                	      ++__first;
                	      __first = std::fill_n(__first, __n - 1, *__val);
                	    }
                	  return __first;
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with value-initialized value_types.
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)
                				     && __assignable>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with value-initialized value_types.
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
      360000 ->     __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // See uninitialized_fill_n for the conditions for using std::fill_n.
                      constexpr bool __can_fill
                	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
                
                      return __uninitialized_default_n_1<__is_trivial(_ValueType)
                					 && __can_fill>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with value_types constructed by the allocator
                  // alloc, with no arguments passed to the construct call.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with value_types constructed by the allocator
                  // alloc, with no arguments passed to the construct call.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_default_n_a specialization for std::allocator,
                  // which ignores the allocator and value-initializes the elements.
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
      360000 ->     __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { return std::__uninitialized_default_n(__first, __n); }
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_1
                    {
                      template<typename _ForwardIterator>
                	static void
                	__uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{ return std::next(__first, __n); }
                    };
                
                  // __uninitialized_default_novalue
                  // Fills [first, last) with default-initialized value_types.
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default_novalue(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_default_novalue_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue(__first, __last);
                    }
                
                  // __uninitialized_default_novalue_n
                  // Fills [first, first + n) with default-initialized value_types.
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      return __uninitialized_default_novalue_n_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue_n(__first, __n);
                    }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return {__first, __cur};
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline pair<_RandomAccessIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    {
                      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
                      auto __first_res = std::next(__first, __n);
                      return {__first_res, __second_res};
                    }
                
                  /// @endcond
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                
                  /// @cond undocumented
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			      _ForwardIterator __result)
                    {
                      return
                	std::__uninitialized_copy_n_pair(__first, __n, __result,
                					 std::__iterator_category(__first));
                    }
                  /// @endcond
                #endif
                
                #if __cplusplus >= 201703L
                # define __cpp_lib_raw_memory_algorithms 201606L
                
                  /**
                   *  @brief Default-initializes objects in the range [first,last).
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                  */
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_default_construct(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      __uninitialized_default_novalue(__first, __last);
                    }
                
                  /**
                   *  @brief Default-initializes objects in the range [first,first+count).
                   *  @param  __first  A forward iterator.
                   *  @param  __count  The number of objects to construct.
                   *  @return   __first + __count
                  */
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_novalue_n(__first, __count);
                    }
                
                  /**
                   *  @brief Value-initializes objects in the range [first,last).
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                  */
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_value_construct(_ForwardIterator __first,
                				  _ForwardIterator __last)
                    {
                      return __uninitialized_default(__first, __last);
                    }
                
                  /**
                   *  @brief Value-initializes objects in the range [first,first+count).
                   *  @param  __first  A forward iterator.
                   *  @param  __count  The number of objects to construct.
                   *  @return   __result + __count
                  */
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_n(__first, __count);
                    }
                
                  /**
                   *  @brief Move-construct from the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                  */
                  template <typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_move(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      return std::uninitialized_copy
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_ITERATOR(__last), __result);
                    }
                
                  /**
                   *  @brief Move-construct from the range [first,first+count) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __count  The number of objects to initialize.
                   *  @param  __result An output iterator.
                   *  @return  __result + __count
                  */
                  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    uninitialized_move_n(_InputIterator __first, _Size __count,
                			 _ForwardIterator __result)
                    {
                      auto __res = std::__uninitialized_copy_n_pair
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 __count, __result);
                      return {__res.first.base(), __res.second};
                    }
                #endif // C++17
                
                #if __cplusplus >= 201103L
                  /// @cond undocumented
                
                  template<typename _Tp, typename _Up, typename _Allocator>
                    inline void
                    __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
                			_Allocator& __alloc)
                    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
                			 __dest, std::move(*__orig)))
                	     && noexcept(std::allocator_traits<_Allocator>::destroy(
                			    __alloc, std::__addressof(*__orig))))
                    {
                      typedef std::allocator_traits<_Allocator> __traits;
                      __traits::construct(__alloc, __dest, std::move(*__orig));
                      __traits::destroy(__alloc, std::__addressof(*__orig));
                    }
                
                  // This class may be specialized for specific types.
                  // Also known as is_trivially_relocatable.
                  template<typename _Tp, typename = void>
                    struct __is_bitwise_relocatable
                    : is_trivial<_Tp> { };
                
                  template <typename _Tp, typename _Up>
                    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
     2562000 ->     __relocate_a_1(_Tp* __first, _Tp* __last,
                		   _Tp* __result, allocator<_Up>&) noexcept
                    {
                      ptrdiff_t __count = __last - __first;
                      if (__count > 0)
                	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
                      return __result + __count;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
                    __relocate_a_1(_InputIterator __first, _InputIterator __last,
                		   _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
                					       std::addressof(*__first),
                					       __alloc)))
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                      static_assert(std::is_same<_ValueType, _ValueType2>::value,
                	  "relocation is only possible for values of the same type");
                      _ForwardIterator __cur = __result;
                      for (; __first != __last; ++__first, (void)++__cur)
                	std::__relocate_object_a(std::__addressof(*__cur),
                				 std::__addressof(*__first), __alloc);
                      return __cur;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
     2562000 ->     __relocate_a(_InputIterator __first, _InputIterator __last,
                		 _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
                				     std::__niter_base(__last),
                				     std::__niter_base(__result), __alloc)))
                    {
                      return __relocate_a_1(std::__niter_base(__first),
                			    std::__niter_base(__last),
                			    std::__niter_base(__result), __alloc);
                    }
                
                  /// @endcond
                #endif
                
                  /// @} group memory
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

      126    2803695
      331    2803695
      108    2803615
     1006    2562000
     1040    2562000
      595     360000
      630     360000
      702     360000
       85         80
      349         80

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

 14615165   Total number of line executions
1461516.50   Average executions per line


*** File /usr/include/c++/11/bits/cpp_type_traits.h:
                // The  -*- C++ -*- type traits classes for internal use in libstdc++
                
                // Copyright (C) 2000-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/cpp_type_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{ext/type_traits}
                 */
                
                // Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
                
                #ifndef _CPP_TYPE_TRAITS_H
                #define _CPP_TYPE_TRAITS_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                //
                // This file provides some compile-time information about various types.
                // These representations were designed, on purpose, to be constant-expressions
                // and not types as found in <bits/type_traits.h>.  In particular, they
                // can be used in control structures and the optimizer hopefully will do
                // the obvious thing.
                //
                // Why integral expressions, and not functions nor types?
                // Firstly, these compile-time entities are used as template-arguments
                // so function return values won't work:  We need compile-time entities.
                // We're left with types and constant  integral expressions.
                // Secondly, from the point of view of ease of use, type-based compile-time
                // information is -not- *that* convenient.  One has to write lots of
                // overloaded functions and to hope that the compiler will select the right
                // one. As a net effect, the overall structure isn't very clear at first
                // glance.
                // Thirdly, partial ordering and overload resolution (of function templates)
                // is highly costly in terms of compiler-resource.  It is a Good Thing to
                // keep these resource consumption as least as possible.
                //
                // See valarray_array.h for a case use.
                //
                // -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
                //
                // Update 2005: types are also provided and <bits/type_traits.h> has been
                // removed.
                //
                
                extern "C++" {
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  struct __true_type { };
                  struct __false_type { };
                
                  template<bool>
                    struct __truth_type
                    { typedef __false_type __type; };
                
                  template<>
                    struct __truth_type<true>
                    { typedef __true_type __type; };
                
                  // N.B. The conversions to bool are needed due to the issue
                  // explained in c++/19404.
                  template<class _Sp, class _Tp>
                    struct __traitor
                    {
                      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
                      typedef typename __truth_type<__value>::__type __type;
                    };
                
                  // Compare for equality of types.
                  template<typename, typename>
                    struct __are_same
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __are_same<_Tp, _Tp>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  // Holds if the template-argument is a void type.
                  template<typename _Tp>
                    struct __is_void
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_void<void>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Integer types
                  //
                  template<typename _Tp>
                    struct __is_integer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Thirteen specializations (yes there are eleven standard integer
                  // types; <em>long long</em> and <em>unsigned long long</em> are
                  // supported as extensions).  Up to four target-specific __int<N>
                  // types are supported as well.
                  template<>
                    struct __is_integer<bool>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                # ifdef __WCHAR_TYPE__
                  template<>
                    struct __is_integer<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                # endif
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct __is_integer<char8_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __is_integer<char16_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char32_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<>
                    struct __is_integer<short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #define __INT_N(TYPE) 			\
                  template<>				\
                    struct __is_integer<TYPE>		\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };					\
                  template<>				\
                    struct __is_integer<unsigned TYPE>	\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };
                
                #ifdef __GLIBCXX_TYPE_INT_N_0
                __INT_N(__GLIBCXX_TYPE_INT_N_0)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_1
                __INT_N(__GLIBCXX_TYPE_INT_N_1)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_2
                __INT_N(__GLIBCXX_TYPE_INT_N_2)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_3
                __INT_N(__GLIBCXX_TYPE_INT_N_3)
                #endif
                
                #undef __INT_N
                
                  //
                  // Floating point types
                  //
                  template<typename _Tp>
                    struct __is_floating
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // three specializations (float, double and 'long double')
                  template<>
                    struct __is_floating<float>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<long double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Pointer types
                  //
                  template<typename _Tp>
                    struct __is_pointer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __is_pointer<_Tp*>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // An arithmetic type is an integer type or a floating point type
                  //
                  template<typename _Tp>
                    struct __is_arithmetic
                    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
                    { };
                
                  //
                  // A scalar type is an arithmetic type or a pointer type
                  // 
                  template<typename _Tp>
                    struct __is_scalar
                    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
                    { };
                
                  //
                  // For use in std::copy and std::find overloads for streambuf iterators.
                  //
                  template<typename _Tp>
                    struct __is_char
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_char<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #ifdef __WCHAR_TYPE__
                  template<>
                    struct __is_char<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<typename _Tp>
                    struct __is_byte
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_byte<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #if __cplusplus >= 201703L
                  enum class byte : unsigned char;
                
                  template<>
                    struct __is_byte<byte>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif // C++17
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct __is_byte<char8_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<typename> struct iterator_traits;
                
                  // A type that is safe for use with memcpy, memmove, memcmp etc.
                  template<typename _Tp>
                    struct __is_nonvolatile_trivially_copyable
                    {
                      enum { __value = __is_trivially_copyable(_Tp) };
                    };
                
                  // Cannot use memcpy/memmove/memcmp on volatile types even if they are
                  // trivially copyable, so ensure __memcpyable<volatile int*, volatile int*>
                  // and similar will be false.
                  template<typename _Tp>
                    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
                    {
                      enum { __value = 0 };
                    };
                
                  // Whether two iterator types can be used with memcpy/memmove.
                  template<typename _OutputIter, typename _InputIter>
                    struct __memcpyable
                    {
                      enum { __value = 0 };
                    };
                
                  template<typename _Tp>
                    struct __memcpyable<_Tp*, _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __memcpyable<_Tp*, const _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  // Whether two iterator types can be used with memcmp.
                  // This trait only says it's well-formed to use memcmp, not that it
                  // gives the right answer for a given algorithm. So for example, std::equal
                  // needs to add additional checks that the types are integers or pointers,
                  // because other trivially copyable types can overload operator==.
                  template<typename _Iter1, typename _Iter2>
                    struct __memcmpable
                    {
                      enum { __value = 0 };
                    };
                
                  // OK to use memcmp with pointers to trivially copyable types.
                  template<typename _Tp>
                    struct __memcmpable<_Tp*, _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __memcmpable<const _Tp*, _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __memcmpable<_Tp*, const _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  // Whether memcmp can be used to determine ordering for a type
                  // e.g. in std::lexicographical_compare or three-way comparisons.
                  // True for unsigned integer-like types where comparing each byte in turn
                  // as an unsigned char yields the right result. This is true for all
                  // unsigned integers on big endian targets, but only unsigned narrow
                  // character types (and std::byte) on little endian targets.
                  template<typename _Tp, bool _TreatAsBytes =
                #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
                	__is_integer<_Tp>::__value
                #else
                	__is_byte<_Tp>::__value
                #endif
                    >
                    struct __is_memcmp_ordered
                    {
                      static const bool __value = _Tp(-1) > _Tp(1); // is unsigned
                    };
                
                  template<typename _Tp>
                    struct __is_memcmp_ordered<_Tp, false>
                    {
                      static const bool __value = false;
                    };
                
                  // Whether two types can be compared using memcmp.
                  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
                    struct __is_memcmp_ordered_with
                    {
                      static const bool __value = __is_memcmp_ordered<_Tp>::__value
                	&& __is_memcmp_ordered<_Up>::__value;
                    };
                
                  template<typename _Tp, typename _Up>
                    struct __is_memcmp_ordered_with<_Tp, _Up, false>
                    {
                      static const bool __value = false;
                    };
                
                #if __cplusplus >= 201703L
                #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
                  // std::byte is not an integer, but it can be compared using memcmp.
                  template<>
                    struct __is_memcmp_ordered<std::byte, false>
                    { static constexpr bool __value = true; };
                #endif
                
                  // std::byte can only be compared to itself, not to other types.
                  template<>
                    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
                    { static constexpr bool __value = true; };
                
                  template<typename _Tp, bool _SameSize>
                    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
                    { static constexpr bool __value = false; };
                
                  template<typename _Up, bool _SameSize>
                    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
                    { static constexpr bool __value = false; };
                #endif
                
                  //
                  // Move iterator type
                  //
                  template<typename _Tp>
                    struct __is_move_iterator
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the move_iterator wrapper.
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
    10252350 ->     __miter_base(_Iterator __it)
                    { return __it; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                } // extern "C++"
                
                #endif //_CPP_TYPE_TRAITS_H


Top 10 Lines:

     Line      Count

      560   10252350

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

 10252350   Total number of line executions
10252350.00   Average executions per line


*** File /usr/include/c++/11/bits/move.h:
                // Move, forward and identity for C++11 + swap -*- C++ -*-
                
                // Copyright (C) 2007-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #if __cplusplus < 201103L
                # include <bits/concept_check.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR _Tp*
      369324 ->     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    { return __builtin_addressof(__r); }
                
                #if __cplusplus >= 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr _Tp&&
    93955608 ->     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                		    " substituting _Tp must not be an lvalue reference type");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr typename std::remove_reference<_Tp>::type&&
    39292602 ->     move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                #if __cplusplus > 201402L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2296. std::addressof should be constexpr
                # define __cpp_lib_addressof_constexpr 201603
                #endif
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    inline _GLIBCXX17_CONSTEXPR _Tp*
                    addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2598. addressof works on temporaries
                  template<typename _Tp>
                    const _Tp* addressof(const _Tp&&) = delete;
                
                  // C++11 version of std::exchange for internal use.
                  template <typename _Tp, typename _Up = _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _Tp
                    __exchange(_Tp& __obj, _Up&& __new_val)
                    {
                      _Tp __old_val = std::move(__obj);
                      __obj = std::forward<_Up>(__new_val);
                      return __old_val;
                    }
                
                  /// @} group utilities
                
                #define _GLIBCXX_FWDREF(_Tp) _Tp&&
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_FWDREF(_Tp) const _Tp&
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
                			      is_move_constructible<_Tp>,
                			      is_move_assignable<_Tp>>::value>::type
                #else
                    void
                #endif
    12459292 ->     swap(_Tp& __a, _Tp& __b)
                    _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,
                				is_nothrow_move_assignable<_Tp>>::value)
                    {
                #if __cplusplus < 201103L
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                #endif
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    _GLIBCXX20_CONSTEXPR
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__is_swappable<_Tp>::value>::type
                #else
                    void
                #endif
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                    _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Tp>::value)
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

       77   93955608
      104   39292602
      196   12459292
       49     369324

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

146076826   Total number of line executions
36519206.50   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/./Genetic-Algorithm/Crossover/partially_mapped_crossover.cpp:
                #include "partially_mapped_crossover.hpp"
                #include "../Path_representation.hpp"
                #include <vector>
                #include <utility>
                #include <cstdlib>
                
                using std::vector;
                using std::pair;
                
                
                pair<PathRepresentation, PathRepresentation> PartiallyMappedCrossover::
                      crosslink(const PathRepresentation &A, const PathRepresentation &B)
       90000 -> {
                
                  vector<int> pathA = A.get_order();
                  vector<int> pathB = B.get_order();
                
                  vector<int> offspring1(pathA);
                  vector<int> offspring2(pathB);
                
                  unsigned numCities = std::min(pathA.size(), pathB.size());
                
                  vector<int> partialMapA(numCities);
                  vector<int> partialMapB(numCities);
                
                  // Initilize the partialmaps
                  for(unsigned i = 0 ; i < numCities; ++i)
                  {
                    partialMapA[pathA[i]] = i;
                    partialMapB[pathB[i]] = i;
                  }
                
                  // Generate random crossover points
                  unsigned randomIndex1;
                  unsigned randomIndex2;
                  do
                  {
                    randomIndex1 = rand() % (numCities);
                    randomIndex2 = rand() % (numCities);
                  }
                  while(randomIndex1 >= randomIndex2);
                
                  for(unsigned i = randomIndex1; i <= randomIndex2; ++i)
                  {
                    // selected values
                    int temp1 = pathA[i];
                    int temp2 = pathB[i];
                
                    std::swap(offspring1[partialMapA[temp2]], offspring1[i]);
                    std::swap(offspring2[partialMapB[temp1]], offspring2[i]);
                  }
                
                  PathRepresentation Offspring1(offspring1);
                  PathRepresentation Offspring2(offspring2);
                
                  return pair{Offspring2, Offspring1};
                }


Top 10 Lines:

     Line      Count

       13      90000

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    90000   Total number of line executions
 90000.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <bits/stl_iterator_base_types.h> // for iterator_traits
                #include <bits/stl_iterator_base_funcs.h> // for advance
                
                /* This file provides the C++17 functions std::destroy_at, std::destroy, and
                 * std::destroy_n, and the C++20 function std::construct_at.
                 * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions
                 * which are defined in all standard modes and so can be used in C++98-14 code.
                 * The _Destroy functions will dispatch to destroy_at during constant
                 * evaluation, because calls to that function are intercepted by the compiler
                 * to allow use in constant expressions.
                 */
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201703L
                  template <typename _Tp>
                    _GLIBCXX20_CONSTEXPR inline void
                    destroy_at(_Tp* __location)
                    {
                      if constexpr (__cplusplus > 201703L && is_array_v<_Tp>)
                	{
                	  for (auto& __x : *__location)
                	    std::destroy_at(std::__addressof(__x));
                	}
                      else
                	__location->~_Tp();
                    }
                
                #if __cplusplus > 201703L
                  template<typename _Tp, typename... _Args>
                    constexpr auto
                    construct_at(_Tp* __location, _Args&&... __args)
                    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
                    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
                    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                #endif // C++20
                #endif// C++17
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename... _Args>
                    inline void
      363132 ->     _Construct(_Tp* __p, _Args&&... __args)
                    { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
                #else
                  template<typename _T1, typename _T2>
                    inline void
                    _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  template<typename _T1>
                    inline void
                    _Construct_novalue(_T1* __p)
                    { ::new(static_cast<void*>(__p)) _T1; }
                
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last);
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR inline void
        6192 ->     _Destroy(_Tp* __pointer)
                    {
                #if __cplusplus > 201703L
                      std::destroy_at(__pointer);
                #else
                      __pointer->~_Tp();
                #endif
                    }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                	static _GLIBCXX20_CONSTEXPR void
          44 -> 	__destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
     6208557 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR inline void
     6208601 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                #if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return _Destroy_aux<false>::__destroy(__first, __last);
                #endif
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  template<bool>
                    struct _Destroy_n_aux
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _GLIBCXX20_CONSTEXPR _ForwardIterator
                	__destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  for (; __count > 0; (void)++__first, --__count)
                	    std::_Destroy(std::__addressof(*__first));
                	  return __first;
                	}
                    };
                
                  template<>
                    struct _Destroy_n_aux<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  std::advance(__first, __count);
                	  return __first;
                	}
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator, typename _Size>
                    _GLIBCXX20_CONSTEXPR inline _ForwardIterator
                    _Destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                #if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return _Destroy_n_aux<false>::__destroy_n(__first, __count);
                #endif
                      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy_n(__first, __count);
                    }
                
                #if __cplusplus >= 201703L
                  template <typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR inline void
                    destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      std::_Destroy(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    _GLIBCXX20_CONSTEXPR inline _ForwardIterator
                    destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      return std::_Destroy_n(__first, __count);
                    }
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */


Top 10 Lines:

     Line      Count

      171    6208601
      161    6208557
      108     363132
      135       6192
      149         44

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

 12786526   Total number of line executions
2557305.20   Average executions per line


*** File /usr/include/c++/11/bits/stl_set.h:
                // Set implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_set.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{set}
                 */
                
                #ifndef _STL_SET_H
                #define _STL_SET_H 1
                
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Key, typename _Compare, typename _Alloc>
                    class multiset;
                
                  /**
                   *  @brief A standard container made up of unique keys, which can be
                   *  retrieved in logarithmic time.
                   *
                   *  @ingroup associative_containers
                   *
                   *  @tparam _Key  Type of key objects.
                   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and an
                   *  <a href="tables.html#69">associative container</a> (using unique keys).
                   *
                   *  Sets support bidirectional iterators.
                   *
                   *  The private tree data is declared exactly the same way for set and
                   *  multiset; the distinction is made entirely in how the tree functions are
                   *  called (*_unique versus *_equal, same as the standard).
                  */
                  template<typename _Key, typename _Compare = std::less<_Key>,
                	   typename _Alloc = std::allocator<_Key> >
                    class set
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename _Alloc::value_type		_Alloc_value_type;
                # if __cplusplus < 201103L
                      __glibcxx_class_requires(_Key, _SGIAssignableConcept)
                # endif
                      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
                				_BinaryFunctionConcept)
                      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)
                #endif
                
                #if __cplusplus >= 201103L
                      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
                	  "std::set must have a non-const, non-volatile value_type");
                # if __cplusplus > 201703L || defined __STRICT_ANSI__
                      static_assert(is_same<typename _Alloc::value_type, _Key>::value,
                	  "std::set must have the same value_type as its allocator");
                # endif
                #endif
                
                    public:
                      // typedefs:
                      ///@{
                      /// Public typedefs.
                      typedef _Key     key_type;
                      typedef _Key     value_type;
                      typedef _Compare key_compare;
                      typedef _Compare value_compare;
                      typedef _Alloc   allocator_type;
                      ///@}
                
                    private:
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Key>::other _Key_alloc_type;
                
                      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
                		       key_compare, _Key_alloc_type> _Rep_type;
                      _Rep_type _M_t;  // Red-black tree representing set.
                
                      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
                
                    public:
                      ///@{
                      ///  Iterator-related typedefs.
                      typedef typename _Alloc_traits::pointer		 pointer;
                      typedef typename _Alloc_traits::const_pointer	 const_pointer;
                      typedef typename _Alloc_traits::reference		 reference;
                      typedef typename _Alloc_traits::const_reference	 const_reference;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 103. set::iterator is required to be modifiable,
                      // but this allows modification of keys.
                      typedef typename _Rep_type::const_iterator	 iterator;
                      typedef typename _Rep_type::const_iterator	 const_iterator;
                      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
                      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
                      typedef typename _Rep_type::size_type		 size_type;
                      typedef typename _Rep_type::difference_type	 difference_type;
                      ///@}
                
                #if __cplusplus > 201402L
                      using node_type = typename _Rep_type::node_type;
                      using insert_return_type = typename _Rep_type::insert_return_type;
                #endif
                
                      // allocation/deallocation
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
                #if __cplusplus < 201103L
                      set() : _M_t() { }
                #else
      180000 ->       set() = default;
                #endif
                
                      /**
                       *  @brief  Creates a %set with no elements.
                       *  @param  __comp  Comparator to use.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      set(const _Compare& __comp,
                	  const allocator_type& __a = allocator_type())
                      : _M_t(__comp, _Key_alloc_type(__a)) { }
                
                      /**
                       *  @brief  Builds a %set from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *
                       *  Create a %set consisting of copies of the elements from
                       *  [__first,__last).  This is linear in N if the range is
                       *  already sorted, and NlogN otherwise (where N is
                       *  distance(__first,__last)).
                       */
                      template<typename _InputIterator>
                	set(_InputIterator __first, _InputIterator __last)
                	: _M_t()
                	{ _M_t._M_insert_range_unique(__first, __last); }
                
                      /**
                       *  @brief  Builds a %set from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __comp  A comparison functor.
                       *  @param  __a  An allocator object.
                       *
                       *  Create a %set consisting of copies of the elements from
                       *  [__first,__last).  This is linear in N if the range is
                       *  already sorted, and NlogN otherwise (where N is
                       *  distance(__first,__last)).
                       */
                      template<typename _InputIterator>
                	set(_InputIterator __first, _InputIterator __last,
                	    const _Compare& __comp,
                	    const allocator_type& __a = allocator_type())
                	: _M_t(__comp, _Key_alloc_type(__a))
                	{ _M_t._M_insert_range_unique(__first, __last); }
                
                      /**
                       *  @brief  %Set copy constructor.
                       *
                       *  Whether the allocator is copied depends on the allocator traits.
                       */
                #if __cplusplus < 201103L
                      set(const set& __x)
                      : _M_t(__x._M_t) { }
                #else
                      set(const set&) = default;
                
                     /**
                       *  @brief %Set move constructor
                       *
                       *  The newly-created %set contains the exact contents of the moved
                       *  instance. The moved instance is a valid, but unspecified, %set.
                       */
                      set(set&&) = default;
                
                      /**
                       *  @brief  Builds a %set from an initializer_list.
                       *  @param  __l  An initializer_list.
                       *  @param  __comp  A comparison functor.
                       *  @param  __a  An allocator object.
                       *
                       *  Create a %set consisting of copies of the elements in the list.
                       *  This is linear in N if the list is already sorted, and NlogN
                       *  otherwise (where N is @a __l.size()).
                       */
                      set(initializer_list<value_type> __l,
                	  const _Compare& __comp = _Compare(),
                	  const allocator_type& __a = allocator_type())
                      : _M_t(__comp, _Key_alloc_type(__a))
                      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
                
                      /// Allocator-extended default constructor.
                      explicit
                      set(const allocator_type& __a)
                      : _M_t(_Key_alloc_type(__a)) { }
                
                      /// Allocator-extended copy constructor.
                      set(const set& __x, const allocator_type& __a)
                      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }
                
                      /// Allocator-extended move constructor.
                      set(set&& __x, const allocator_type& __a)
                      noexcept(is_nothrow_copy_constructible<_Compare>::value
                	       && _Alloc_traits::_S_always_equal())
                      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }
                
                      /// Allocator-extended initialier-list constructor.
                      set(initializer_list<value_type> __l, const allocator_type& __a)
                      : _M_t(_Key_alloc_type(__a))
                      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }
                
                      /// Allocator-extended range constructor.
                      template<typename _InputIterator>
                	set(_InputIterator __first, _InputIterator __last,
                	    const allocator_type& __a)
                	: _M_t(_Key_alloc_type(__a))
                	{ _M_t._M_insert_range_unique(__first, __last); }
                
                      /**
                       *  The dtor only erases the elements, and note that if the elements
                       *  themselves are pointers, the pointed-to memory is not touched in any
                       *  way. Managing the pointer is the user's responsibility.
                       */
      180000 ->       ~set() = default;
                #endif
                
                      /**
                       *  @brief  %Set assignment operator.
                       *
                       *  Whether the allocator is copied depends on the allocator traits.
                       */
                #if __cplusplus < 201103L
                      set&
                      operator=(const set& __x)
                      {
                	_M_t = __x._M_t;
                	return *this;
                      }
                #else
                      set&
                      operator=(const set&) = default;
                
                      /// Move assignment operator.
                      set&
                      operator=(set&&) = default;
                
                      /**
                       *  @brief  %Set list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %set with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %set and
                       *  that the resulting %set's size is the same as the number
                       *  of elements assigned.
                       */
                      set&
                      operator=(initializer_list<value_type> __l)
                      {
                	_M_t._M_assign_unique(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      // accessors:
                
                      ///  Returns the comparison object with which the %set was constructed.
                      key_compare
                      key_comp() const
                      { return _M_t.key_comp(); }
                      ///  Returns the comparison object with which the %set was constructed.
                      value_compare
                      value_comp() const
                      { return _M_t.key_comp(); }
                      ///  Returns the allocator object with which the %set was constructed.
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_t.get_allocator()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %set.  Iteration is done in ascending order according
                       *  to the keys.
                       */
                      iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  element in the %set.  Iteration is done in ascending order according
                       *  to the keys.
                       */
                      iterator
    10800000 ->       end() const _GLIBCXX_NOEXCEPT
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the last
                       *  element in the %set.  Iteration is done in descending order according
                       *  to the keys.
                       */
                      reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to the
                       *  last pair in the %set.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return _M_t.rend(); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %set.  Iteration is done in ascending order according
                       *  to the keys.
                       */
                      iterator
                      cbegin() const noexcept
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  element in the %set.  Iteration is done in ascending order according
                       *  to the keys.
                       */
                      iterator
                      cend() const noexcept
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the last
                       *  element in the %set.  Iteration is done in descending order according
                       *  to the keys.
                       */
                      reverse_iterator
                      crbegin() const noexcept
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to the
                       *  last pair in the %set.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      reverse_iterator
                      crend() const noexcept
                      { return _M_t.rend(); }
                #endif
                
                      ///  Returns true if the %set is empty.
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return _M_t.empty(); }
                
                      ///  Returns the size of the %set.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_t.size(); }
                
                      ///  Returns the maximum size of the %set.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _M_t.max_size(); }
                
                      /**
                       *  @brief  Swaps data with another %set.
                       *  @param  __x  A %set of the same element and allocator types.
                       *
                       *  This exchanges the elements between two sets in constant
                       *  time.  (It is only swapping a pointer, an integer, and an
                       *  instance of the @c Compare type (which itself is often
                       *  stateless and empty), so it should be quite fast.)  Note
                       *  that the global std::swap() function is specialized such
                       *  that std::swap(s1,s2) will feed to this function.
                       *
                       *  Whether the allocators are swapped depends on the allocator traits.
                       */
                      void
                      swap(set& __x)
                      _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value)
                      { _M_t.swap(__x._M_t); }
                
                      // insert/erase
                #if __cplusplus >= 201103L
                      /**
                       *  @brief Attempts to build and insert an element into the %set.
                       *  @param __args  Arguments used to generate an element.
                       *  @return  A pair, of which the first element is an iterator that points
                       *           to the possibly inserted element, and the second is a bool
                       *           that is true if the element was actually inserted.
                       *
                       *  This function attempts to build and insert an element into the %set.
                       *  A %set relies on unique keys and thus an element is only inserted if
                       *  it is not already present in the %set.
                       *
                       *  Insertion requires logarithmic time.
                       */
                      template<typename... _Args>
                	std::pair<iterator, bool>
                	emplace(_Args&&... __args)
                	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief Attempts to insert an element into the %set.
                       *  @param  __pos  An iterator that serves as a hint as to where the
                       *                element should be inserted.
                       *  @param  __args  Arguments used to generate the element to be
                       *                 inserted.
                       *  @return An iterator that points to the element with key equivalent to
                       *          the one generated from @a __args (may or may not be the
                       *          element itself).
                       *
                       *  This function is not concerned about whether the insertion took place,
                       *  and thus does not return a boolean like the single-argument emplace()
                       *  does.  Note that the first parameter is only a hint and can
                       *  potentially improve the performance of the insertion process.  A bad
                       *  hint would cause no gains in efficiency.
                       *
                       *  For more on @a hinting, see:
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *
                       *  Insertion requires logarithmic time (if the hint is not taken).
                       */
                      template<typename... _Args>
                	iterator
                	emplace_hint(const_iterator __pos, _Args&&... __args)
                	{
                	  return _M_t._M_emplace_hint_unique(__pos,
                					     std::forward<_Args>(__args)...);
                	}
                #endif
                
                      /**
                       *  @brief Attempts to insert an element into the %set.
                       *  @param  __x  Element to be inserted.
                       *  @return  A pair, of which the first element is an iterator that points
                       *           to the possibly inserted element, and the second is a bool
                       *           that is true if the element was actually inserted.
                       *
                       *  This function attempts to insert an element into the %set.  A %set
                       *  relies on unique keys and thus an element is only inserted if it is
                       *  not already present in the %set.
                       *
                       *  Insertion requires logarithmic time.
                       */
                      std::pair<iterator, bool>
     5397332 ->       insert(const value_type& __x)
                      {
                	std::pair<typename _Rep_type::iterator, bool> __p =
                	  _M_t._M_insert_unique(__x);
                	return std::pair<iterator, bool>(__p.first, __p.second);
                      }
                
                #if __cplusplus >= 201103L
                      std::pair<iterator, bool>
                      insert(value_type&& __x)
                      {
                	std::pair<typename _Rep_type::iterator, bool> __p =
                	  _M_t._M_insert_unique(std::move(__x));
                	return std::pair<iterator, bool>(__p.first, __p.second);
                      }
                #endif
                
                      /**
                       *  @brief Attempts to insert an element into the %set.
                       *  @param  __position  An iterator that serves as a hint as to where the
                       *                    element should be inserted.
                       *  @param  __x  Element to be inserted.
                       *  @return An iterator that points to the element with key of
                       *           @a __x (may or may not be the element passed in).
                       *
                       *  This function is not concerned about whether the insertion took place,
                       *  and thus does not return a boolean like the single-argument insert()
                       *  does.  Note that the first parameter is only a hint and can
                       *  potentially improve the performance of the insertion process.  A bad
                       *  hint would cause no gains in efficiency.
                       *
                       *  For more on @a hinting, see:
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *
                       *  Insertion requires logarithmic time (if the hint is not taken).
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x)
                      { return _M_t._M_insert_unique_(__position, __x); }
                
                #if __cplusplus >= 201103L
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
                #endif
                
                      /**
                       *  @brief A template function that attempts to insert a range
                       *  of elements.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                   inserted.
                       *  @param  __last  Iterator pointing to the end of the range.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      template<typename _InputIterator>
                	void
                	insert(_InputIterator __first, _InputIterator __last)
                	{ _M_t._M_insert_range_unique(__first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief Attempts to insert a list of elements into the %set.
                       *  @param  __l  A std::initializer_list<value_type> of elements
                       *               to be inserted.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      void
                      insert(initializer_list<value_type> __l)
                      { this->insert(__l.begin(), __l.end()); }
                #endif
                
                #if __cplusplus > 201402L
                      /// Extract a node.
                      node_type
                      extract(const_iterator __pos)
                      {
                	__glibcxx_assert(__pos != end());
                	return _M_t.extract(__pos);
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const key_type& __x)
                      { return _M_t.extract(__x); }
                
                      /// Re-insert an extracted node.
                      insert_return_type
                      insert(node_type&& __nh)
                      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }
                
                      /// Re-insert an extracted node.
                      iterator
                      insert(const_iterator __hint, node_type&& __nh)
                      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }
                
                      template<typename, typename>
                	friend struct std::_Rb_tree_merge_helper;
                
                      template<typename _Compare1>
                	void
                	merge(set<_Key, _Compare1, _Alloc>& __source)
                	{
                	  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
                	  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
                	}
                
                      template<typename _Compare1>
                	void
                	merge(set<_Key, _Compare1, _Alloc>&& __source)
                	{ merge(__source); }
                
                      template<typename _Compare1>
                	void
                	merge(multiset<_Key, _Compare1, _Alloc>& __source)
                	{
                	  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
                	  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
                	}
                
                      template<typename _Compare1>
                	void
                	merge(multiset<_Key, _Compare1, _Alloc>&& __source)
                	{ merge(__source); }
                #endif // C++17
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      /**
                       *  @brief Erases an element from a %set.
                       *  @param  __position  An iterator pointing to the element to be erased.
                       *  @return An iterator pointing to the element immediately following
                       *          @a __position prior to the element being erased. If no such
                       *          element exists, end() is returned.
                       *
                       *  This function erases an element, pointed to by the given iterator,
                       *  from a %set.  Note that this function only erases the element, and
                       *  that if the element is itself a pointer, the pointed-to memory is not
                       *  touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __position)
                      { return _M_t.erase(__position); }
                #else
                      /**
                       *  @brief Erases an element from a %set.
                       *  @param  position  An iterator pointing to the element to be erased.
                       *
                       *  This function erases an element, pointed to by the given iterator,
                       *  from a %set.  Note that this function only erases the element, and
                       *  that if the element is itself a pointer, the pointed-to memory is not
                       *  touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
                      void
                      erase(iterator __position)
                      { _M_t.erase(__position); }
                #endif
                
                      /**
                       *  @brief Erases elements according to the provided key.
                       *  @param  __x  Key of element to be erased.
                       *  @return  The number of elements erased.
                       *
                       *  This function erases all the elements located by the given key from
                       *  a %set.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      size_type
                      erase(const key_type& __x)
                      { return _M_t.erase(__x); }
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      /**
                       *  @brief Erases a [__first,__last) range of elements from a %set.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                 erased.
                
                       *  @param __last Iterator pointing to the end of the range to
                       *  be erased.
                       *  @return The iterator @a __last.
                       *
                       *  This function erases a sequence of elements from a %set.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      { return _M_t.erase(__first, __last); }
                #else
                      /**
                       *  @brief Erases a [first,last) range of elements from a %set.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                 erased.
                       *  @param __last Iterator pointing to the end of the range to
                       *  be erased.
                       *
                       *  This function erases a sequence of elements from a %set.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      void
                      erase(iterator __first, iterator __last)
                      { _M_t.erase(__first, __last); }
                #endif
                
                      /**
                       *  Erases all elements in a %set.  Note that this function only erases
                       *  the elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_t.clear(); }
                
                      // set operations:
                
                      ///@{
                      /**
                       *  @brief  Finds the number of elements.
                       *  @param  __x  Element to located.
                       *  @return  Number of elements with specified key.
                       *
                       *  This function only makes sense for multisets; for set the result will
                       *  either be 0 (not present) or 1 (present).
                       */
                      size_type
                      count(const key_type& __x) const
                      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	count(const _Kt& __x) const
                	-> decltype(_M_t._M_count_tr(__x))
                	{ return _M_t._M_count_tr(__x); }
                #endif
                      ///@}
                
                #if __cplusplus > 201703L
                      ///@{
                      /**
                       *  @brief  Finds whether an element with the given key exists.
                       *  @param  __x  Key of elements to be located.
                       *  @return  True if there is an element with the specified key.
                       */
                      bool
                      contains(const key_type& __x) const
                      { return _M_t.find(__x) != _M_t.end(); }
                
                      template<typename _Kt>
                	auto
                	contains(const _Kt& __x) const
                	-> decltype(_M_t._M_find_tr(__x), void(), true)
                	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
                      ///@}
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 214.  set::find() missing const overload
                      ///@{
                      /**
                       *  @brief Tries to locate an element in a %set.
                       *  @param  __x  Element to be located.
                       *  @return  Iterator pointing to sought-after element, or end() if not
                       *           found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns an iterator
                       *  pointing to the sought after element.  If unsuccessful it returns the
                       *  past-the-end ( @c end() ) iterator.
                       */
                      iterator
    10800000 ->       find(const key_type& __x)
                      { return _M_t.find(__x); }
                
                      const_iterator
                      find(const key_type& __x) const
                      { return _M_t.find(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	find(const _Kt& __x)
                	-> decltype(iterator{_M_t._M_find_tr(__x)})
                	{ return iterator{_M_t._M_find_tr(__x)}; }
                
                      template<typename _Kt>
                	auto
                	find(const _Kt& __x) const
                	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
                	{ return const_iterator{_M_t._M_find_tr(__x)}; }
                #endif
                      ///@}
                
                      ///@{
                      /**
                       *  @brief Finds the beginning of a subsequence matching given key.
                       *  @param  __x  Key to be located.
                       *  @return  Iterator pointing to first element equal to or greater
                       *           than key, or end().
                       *
                       *  This function returns the first element of a subsequence of elements
                       *  that matches the given key.  If unsuccessful it returns an iterator
                       *  pointing to the first element that has a greater value than given key
                       *  or end() if no such element exists.
                       */
                      iterator
                      lower_bound(const key_type& __x)
                      { return _M_t.lower_bound(__x); }
                
                      const_iterator
                      lower_bound(const key_type& __x) const
                      { return _M_t.lower_bound(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	lower_bound(const _Kt& __x)
                	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
                	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
                
                      template<typename _Kt>
                	auto
                	lower_bound(const _Kt& __x) const
                	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
                	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
                #endif
                      ///@}
                
                      ///@{
                      /**
                       *  @brief Finds the end of a subsequence matching given key.
                       *  @param  __x  Key to be located.
                       *  @return Iterator pointing to the first element
                       *          greater than key, or end().
                       */
                      iterator
                      upper_bound(const key_type& __x)
                      { return _M_t.upper_bound(__x); }
                
                      const_iterator
                      upper_bound(const key_type& __x) const
                      { return _M_t.upper_bound(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	upper_bound(const _Kt& __x)
                	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
                	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
                
                      template<typename _Kt>
                	auto
                	upper_bound(const _Kt& __x) const
                	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
                	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
                #endif
                      ///@}
                
                      ///@{
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  __x  Key to be located.
                       *  @return  Pair of iterators that possibly points to the subsequence
                       *           matching given key.
                       *
                       *  This function is equivalent to
                       *  @code
                       *    std::make_pair(c.lower_bound(val),
                       *                   c.upper_bound(val))
                       *  @endcode
                       *  (but is faster than making the calls separately).
                       *
                       *  This function probably only makes sense for multisets.
                       */
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __x)
                      { return _M_t.equal_range(__x); }
                
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __x) const
                      { return _M_t.equal_range(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	equal_range(const _Kt& __x)
                	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
                	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
                
                      template<typename _Kt>
                	auto
                	equal_range(const _Kt& __x) const
                	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
                	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
                #endif
                      ///@}
                
                      template<typename _K1, typename _C1, typename _A1>
                	friend bool
                	operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
                
                #if __cpp_lib_three_way_comparison
                      template<typename _K1, typename _C1, typename _A1>
                	friend __detail::__synth3way_t<_K1>
                	operator<=>(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
                #else
                      template<typename _K1, typename _C1, typename _A1>
                	friend bool
                	operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
                #endif
                    };
                
                #if __cpp_deduction_guides >= 201606
                
                  template<typename _InputIterator,
                	   typename _Compare =
                	     less<typename iterator_traits<_InputIterator>::value_type>,
                	   typename _Allocator =
                	     allocator<typename iterator_traits<_InputIterator>::value_type>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireNotAllocator<_Compare>,
                	   typename = _RequireAllocator<_Allocator>>
                    set(_InputIterator, _InputIterator,
                	_Compare = _Compare(), _Allocator = _Allocator())
                    -> set<typename iterator_traits<_InputIterator>::value_type,
                	  _Compare, _Allocator>;
                
                  template<typename _Key, typename _Compare = less<_Key>,
                	   typename _Allocator = allocator<_Key>,
                	   typename = _RequireNotAllocator<_Compare>,
                	   typename = _RequireAllocator<_Allocator>>
                    set(initializer_list<_Key>,
                	_Compare = _Compare(), _Allocator = _Allocator())
                    -> set<_Key, _Compare, _Allocator>;
                
                  template<typename _InputIterator, typename _Allocator,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    set(_InputIterator, _InputIterator, _Allocator)
                    -> set<typename iterator_traits<_InputIterator>::value_type,
                	   less<typename iterator_traits<_InputIterator>::value_type>,
                	   _Allocator>;
                
                  template<typename _Key, typename _Allocator,
                	   typename = _RequireAllocator<_Allocator>>
                    set(initializer_list<_Key>, _Allocator)
                    -> set<_Key, less<_Key>, _Allocator>;
                
                #endif // deduction guides
                
                  /**
                   *  @brief  Set equality comparison.
                   *  @param  __x  A %set.
                   *  @param  __y  A %set of the same type as @a x.
                   *  @return  True iff the size and elements of the sets are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the sets.
                   *  Sets are considered equivalent if their sizes are equal, and if
                   *  corresponding elements compare equal.
                  */
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const set<_Key, _Compare, _Alloc>& __x,
                	       const set<_Key, _Compare, _Alloc>& __y)
                    { return __x._M_t == __y._M_t; }
                
                #if __cpp_lib_three_way_comparison
                  /**
                   *  @brief  Set ordering relation.
                   *  @param  __x  A `set`.
                   *  @param  __y  A `set` of the same type as `x`.
                   *  @return  A value indicating whether `__x` is less than, equal to,
                   *           greater than, or incomparable with `__y`.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  maps.  The elements must be comparable with @c <.
                   *
                   *  See `std::lexicographical_compare_three_way()` for how the determination
                   *  is made. This operator is used to synthesize relational operators like
                   *  `<` and `>=` etc.
                  */
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline __detail::__synth3way_t<_Key>
                    operator<=>(const set<_Key, _Compare, _Alloc>& __x,
                		const set<_Key, _Compare, _Alloc>& __y)
                    { return __x._M_t <=> __y._M_t; }
                #else
                  /**
                   *  @brief  Set ordering relation.
                   *  @param  __x  A %set.
                   *  @param  __y  A %set of the same type as @a x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  sets.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const set<_Key, _Compare, _Alloc>& __x,
                	      const set<_Key, _Compare, _Alloc>& __y)
                    { return __x._M_t < __y._M_t; }
                
                  ///  Returns !(x == y).
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const set<_Key, _Compare, _Alloc>& __x,
                	       const set<_Key, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  ///  Returns y < x.
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const set<_Key, _Compare, _Alloc>& __x,
                	      const set<_Key, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  ///  Returns !(y < x)
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const set<_Key, _Compare, _Alloc>& __x,
                	       const set<_Key, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  ///  Returns !(x < y)
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const set<_Key, _Compare, _Alloc>& __x,
                	       const set<_Key, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                #endif // three-way comparison
                
                  /// See std::set::swap().
                  template<typename _Key, typename _Compare, typename _Alloc>
                    inline void
                    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                #if __cplusplus > 201402L
                  // Allow std::set access to internals of compatible sets.
                  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>
                    struct
                    _Rb_tree_merge_helper<_GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>, _Cmp2>
                    {
                    private:
                      friend class _GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>;
                
                      static auto&
                      _S_get_tree(_GLIBCXX_STD_C::set<_Val, _Cmp2, _Alloc>& __set)
                      { return __set._M_t; }
                
                      static auto&
                      _S_get_tree(_GLIBCXX_STD_C::multiset<_Val, _Cmp2, _Alloc>& __set)
                      { return __set._M_t; }
                    };
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } //namespace std
                #endif /* _STL_SET_H */


Top 10 Lines:

     Line      Count

      353   10800000
      794   10800000
      509    5397332
      167     180000
      281     180000

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

 27357332   Total number of line executions
5471466.40   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/Genetic-Algorithm/Crossover/partially_mapped_crossover.hpp:
                #ifndef PARTIALLY_MAPPED_CROSSOVER_H
                #define PARTIALLY_MAPPED_CROSSOVER_H
                /*
                 * @file Crossover/partially_mapped_crossover.hpp
                 * @author Shah Anwaar Khalid
                 *
                 * This class implements partially_mapped_crossover between
                 * two genomes, given their path representation.
                 */
                
                #include "crossover_base.hpp"
                
                class PartiallyMappedCrossover : public Crossover {
                
                  public:
                    
                    //! Constructor
           1 ->     PartiallyMappedCrossover(){};
                
                    //! Destructor
           1 ->     ~PartiallyMappedCrossover(){};
                
                    //! Crossover function
                    std::pair<PathRepresentation, PathRepresentation>
                      crosslink(const PathRepresentation&A, const PathRepresentation& B);
                
                };
                #endif


Top 10 Lines:

     Line      Count

       18          1
       21          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_tree.h:
                // RB tree implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 */
                
                /** @file bits/stl_tree.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{map,set}
                 */
                
                #ifndef _STL_TREE_H
                #define _STL_TREE_H 1
                
                #pragma GCC system_header
                
                #include <bits/stl_algobase.h>
                #include <bits/allocator.h>
                #include <bits/stl_function.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/alloc_traits.h>
                #if __cplusplus >= 201103L
                # include <ext/aligned_buffer.h>
                #endif
                #if __cplusplus > 201402L
                # include <bits/node_handle.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus > 201103L
                # define __cpp_lib_generic_associative_lookup 201304
                #endif
                
                  // Red-black tree class, designed for use in implementing STL
                  // associative containers (set, multiset, map, and multimap). The
                  // insertion and deletion algorithms are based on those in Cormen,
                  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
                  // 1990), except that
                  //
                  // (1) the header cell is maintained with links not only to the root
                  // but also to the leftmost node of the tree, to enable constant
                  // time begin(), and to the rightmost node of the tree, to enable
                  // linear time performance when used with the generic set algorithms
                  // (set_union, etc.)
                  //
                  // (2) when a node being deleted has two children its successor node
                  // is relinked into its place, rather than copied, so that the only
                  // iterators invalidated are those referring to the deleted node.
                
                  enum _Rb_tree_color { _S_red = false, _S_black = true };
                
                  struct _Rb_tree_node_base
                  {
                    typedef _Rb_tree_node_base* _Base_ptr;
                    typedef const _Rb_tree_node_base* _Const_Base_ptr;
                
                    _Rb_tree_color	_M_color;
                    _Base_ptr		_M_parent;
                    _Base_ptr		_M_left;
                    _Base_ptr		_M_right;
                
                    static _Base_ptr
                    _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Base_ptr
                    _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                  };
                
                  // Helper type offering value initialization guarantee on the compare functor.
                  template<typename _Key_compare>
                    struct _Rb_tree_key_compare
                    {
                      _Key_compare		_M_key_compare;
                
      180000 ->       _Rb_tree_key_compare()
                      _GLIBCXX_NOEXCEPT_IF(
                	is_nothrow_default_constructible<_Key_compare>::value)
                      : _M_key_compare()
                      { }
                
                      _Rb_tree_key_compare(const _Key_compare& __comp)
                      : _M_key_compare(__comp)
                      { }
                
                #if __cplusplus >= 201103L
                      // Copy constructor added for consistency with C++98 mode.
                      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;
                
                      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
                	noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
                      : _M_key_compare(__x._M_key_compare)
                      { }
                #endif
                    };
                
                  // Helper type to manage default initialization of node count and header.
                  struct _Rb_tree_header
                  {
                    _Rb_tree_node_base	_M_header;
                    size_t		_M_node_count; // Keeps track of size of tree.
                
      180000 ->     _Rb_tree_header() _GLIBCXX_NOEXCEPT
                    {
                      _M_header._M_color = _S_red;
                      _M_reset();
                    }
                
                #if __cplusplus >= 201103L
                    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
                    {
                      if (__x._M_header._M_parent != nullptr)
                	_M_move_data(__x);
                      else
                	{
                	  _M_header._M_color = _S_red;
                	  _M_reset();
                	}
                    }
                #endif
                
                    void
                    _M_move_data(_Rb_tree_header& __from)
                    {
                      _M_header._M_color = __from._M_header._M_color;
                      _M_header._M_parent = __from._M_header._M_parent;
                      _M_header._M_left = __from._M_header._M_left;
                      _M_header._M_right = __from._M_header._M_right;
                      _M_header._M_parent->_M_parent = &_M_header;
                      _M_node_count = __from._M_node_count;
                
                      __from._M_reset();
                    }
                
                    void
      180000 ->     _M_reset()
                    {
                      _M_header._M_parent = 0;
                      _M_header._M_left = &_M_header;
                      _M_header._M_right = &_M_header;
                      _M_node_count = 0;
                    }
                  };
                
                  template<typename _Val>
                    struct _Rb_tree_node : public _Rb_tree_node_base
                    {
                      typedef _Rb_tree_node<_Val>* _Link_type;
                
                #if __cplusplus < 201103L
                      _Val _M_value_field;
                
                      _Val*
                      _M_valptr()
                      { return std::__addressof(_M_value_field); }
                
                      const _Val*
                      _M_valptr() const
                      { return std::__addressof(_M_value_field); }
                #else
                      __gnu_cxx::__aligned_membuf<_Val> _M_storage;
                
                      _Val*
    10794664 ->       _M_valptr()
                      { return _M_storage._M_ptr(); }
                
                      const _Val*
    94201451 ->       _M_valptr() const
                      { return _M_storage._M_ptr(); }
                #endif
                    };
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
                
                  template<typename _Tp>
                    struct _Rb_tree_iterator
                    {
                      typedef _Tp  value_type;
                      typedef _Tp& reference;
                      typedef _Tp* pointer;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t			 difference_type;
                
                      typedef _Rb_tree_iterator<_Tp>		_Self;
                      typedef _Rb_tree_node_base::_Base_ptr	_Base_ptr;
                      typedef _Rb_tree_node<_Tp>*		_Link_type;
                
                      _Rb_tree_iterator() _GLIBCXX_NOEXCEPT
                      : _M_node() { }
                
                      explicit
    40382709 ->       _Rb_tree_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      : _M_node(__x) { }
                
                      reference
                      operator*() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
                
                      _Self&
                      operator++() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
     2154989 ->       operator--() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      friend bool
    13385377 ->       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
                      { return __x._M_node == __y._M_node; }
                
                #if ! __cpp_lib_three_way_comparison
                      friend bool
                      operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
                      { return __x._M_node != __y._M_node; }
                #endif
                
                      _Base_ptr _M_node;
                  };
                
                  template<typename _Tp>
                    struct _Rb_tree_const_iterator
                    {
                      typedef _Tp	 value_type;
                      typedef const _Tp& reference;
                      typedef const _Tp* pointer;
                
                      typedef _Rb_tree_iterator<_Tp> iterator;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t			 difference_type;
                
                      typedef _Rb_tree_const_iterator<_Tp>		_Self;
                      typedef _Rb_tree_node_base::_Const_Base_ptr	_Base_ptr;
                      typedef const _Rb_tree_node<_Tp>*			_Link_type;
                
                      _Rb_tree_const_iterator() _GLIBCXX_NOEXCEPT
                      : _M_node() { }
                
                      explicit
    10800000 ->       _Rb_tree_const_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      : _M_node(__x) { }
                
    16197332 ->       _Rb_tree_const_iterator(const iterator& __it) _GLIBCXX_NOEXCEPT
                      : _M_node(__it._M_node) { }
                
                      iterator
                      _M_const_cast() const _GLIBCXX_NOEXCEPT
                      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }
                
                      reference
                      operator*() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      _Self&
                      operator++() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      friend bool
                      operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
                      { return __x._M_node == __y._M_node; }
                
                #if ! __cpp_lib_three_way_comparison
                      friend bool
    10800000 ->       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
                      { return __x._M_node != __y._M_node; }
                #endif
                
                      _Base_ptr _M_node;
                    };
                
                  void
                  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                				_Rb_tree_node_base* __x,
                				_Rb_tree_node_base* __p,
                				_Rb_tree_node_base& __header) throw ();
                
                  _Rb_tree_node_base*
                  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
                			       _Rb_tree_node_base& __header) throw ();
                
                #if __cplusplus > 201402L
                  template<typename _Tree1, typename _Cmp2>
                    struct _Rb_tree_merge_helper { };
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc = allocator<_Val> >
                    class _Rb_tree
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Rb_tree_node<_Val> >::other _Node_allocator;
                
                      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
                
                    protected:
                      typedef _Rb_tree_node_base* 		_Base_ptr;
                      typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
                      typedef _Rb_tree_node<_Val>* 		_Link_type;
                      typedef const _Rb_tree_node<_Val>*	_Const_Link_type;
                
                    private:
                      // Functor recycling a pool of nodes and using allocation once the pool
                      // is empty.
                      struct _Reuse_or_alloc_node
                      {
                	_Reuse_or_alloc_node(_Rb_tree& __t)
                	: _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
                	{
                	  if (_M_root)
                	    {
                	      _M_root->_M_parent = 0;
                
                	      if (_M_nodes->_M_left)
                		_M_nodes = _M_nodes->_M_left;
                	    }
                	  else
                	    _M_nodes = 0;
                	}
                
                #if __cplusplus >= 201103L
                	_Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;
                #endif
                
                	~_Reuse_or_alloc_node()
                	{ _M_t._M_erase(static_cast<_Link_type>(_M_root)); }
                
                	template<typename _Arg>
                	  _Link_type
                	  operator()(_GLIBCXX_FWDREF(_Arg) __arg)
                	  {
                	    _Link_type __node = static_cast<_Link_type>(_M_extract());
                	    if (__node)
                	      {
                		_M_t._M_destroy_node(__node);
                		_M_t._M_construct_node(__node, _GLIBCXX_FORWARD(_Arg, __arg));
                		return __node;
                	      }
                
                	    return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg));
                	  }
                
                      private:
                	_Base_ptr
                	_M_extract()
                	{
                	  if (!_M_nodes)
                	    return _M_nodes;
                
                	  _Base_ptr __node = _M_nodes;
                	  _M_nodes = _M_nodes->_M_parent;
                	  if (_M_nodes)
                	    {
                	      if (_M_nodes->_M_right == __node)
                		{
                		  _M_nodes->_M_right = 0;
                
                		  if (_M_nodes->_M_left)
                		    {
                		      _M_nodes = _M_nodes->_M_left;
                
                		      while (_M_nodes->_M_right)
                			_M_nodes = _M_nodes->_M_right;
                
                		      if (_M_nodes->_M_left)
                			_M_nodes = _M_nodes->_M_left;
                		    }
                		}
                	      else // __node is on the left.
                		_M_nodes->_M_left = 0;
                	    }
                	  else
                	    _M_root = 0;
                
                	  return __node;
                	}
                
                	_Base_ptr _M_root;
                	_Base_ptr _M_nodes;
                	_Rb_tree& _M_t;
                      };
                
                      // Functor similar to the previous one but without any pool of nodes to
                      // recycle.
                      struct _Alloc_node
                      {
     5397332 -> 	_Alloc_node(_Rb_tree& __t)
                	: _M_t(__t) { }
                
                	template<typename _Arg>
                	  _Link_type
     5397332 -> 	  operator()(_GLIBCXX_FWDREF(_Arg) __arg) const
                	  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }
                
                      private:
                	_Rb_tree& _M_t;
                      };
                
                    public:
                      typedef _Key 				key_type;
                      typedef _Val 				value_type;
                      typedef value_type* 			pointer;
                      typedef const value_type* 		const_pointer;
                      typedef value_type& 			reference;
                      typedef const value_type& 		const_reference;
                      typedef size_t 				size_type;
                      typedef ptrdiff_t 			difference_type;
                      typedef _Alloc 				allocator_type;
                
                      _Node_allocator&
    21589328 ->       _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      const _Node_allocator&
                      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Node_allocator()); }
                
                    protected:
                      _Link_type
     5397332 ->       _M_get_node()
                      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }
                
                      void
     5397332 ->       _M_put_node(_Link_type __p) _GLIBCXX_NOEXCEPT
                      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
                
                #if __cplusplus < 201103L
                      void
                      _M_construct_node(_Link_type __node, const value_type& __x)
                      {
                	__try
                	  { get_allocator().construct(__node->_M_valptr(), __x); }
                	__catch(...)
                	  {
                	    _M_put_node(__node);
                	    __throw_exception_again;
                	  }
                      }
                
                      _Link_type
                      _M_create_node(const value_type& __x)
                      {
                	_Link_type __tmp = _M_get_node();
                	_M_construct_node(__tmp, __x);
                	return __tmp;
                      }
                #else
                      template<typename... _Args>
                	void
     5397332 -> 	_M_construct_node(_Link_type __node, _Args&&... __args)
                	{
                	  __try
                	    {
                	      ::new(__node) _Rb_tree_node<_Val>;
                	      _Alloc_traits::construct(_M_get_Node_allocator(),
                				       __node->_M_valptr(),
                				       std::forward<_Args>(__args)...);
                	    }
                	  __catch(...)
                	    {
                	      __node->~_Rb_tree_node<_Val>();
                	      _M_put_node(__node);
                	      __throw_exception_again;
                	    }
                	}
                
                      template<typename... _Args>
                	_Link_type
     5397332 -> 	_M_create_node(_Args&&... __args)
                	{
                	  _Link_type __tmp = _M_get_node();
                	  _M_construct_node(__tmp, std::forward<_Args>(__args)...);
                	  return __tmp;
                	}
                #endif
                
                      void
     5397332 ->       _M_destroy_node(_Link_type __p) _GLIBCXX_NOEXCEPT
                      {
                #if __cplusplus < 201103L
                	get_allocator().destroy(__p->_M_valptr());
                #else
                	_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
                	__p->~_Rb_tree_node<_Val>();
                #endif
                      }
                
                      void
     5397332 ->       _M_drop_node(_Link_type __p) _GLIBCXX_NOEXCEPT
                      {
                	_M_destroy_node(__p);
                	_M_put_node(__p);
                      }
                
                      template<bool _MoveValue, typename _NodeGen>
                	_Link_type
                	_M_clone_node(_Link_type __x, _NodeGen& __node_gen)
                	{
                #if __cplusplus >= 201103L
                	  using _Vp = typename conditional<_MoveValue,
                					   value_type&&,
                					   const value_type&>::type;
                #endif
                	  _Link_type __tmp
                	    = __node_gen(_GLIBCXX_FORWARD(_Vp, *__x->_M_valptr()));
                	  __tmp->_M_color = __x->_M_color;
                	  __tmp->_M_left = 0;
                	  __tmp->_M_right = 0;
                	  return __tmp;
                	}
                
                    protected:
                #if _GLIBCXX_INLINE_VERSION
                      template<typename _Key_compare>
                #else
                      // Unused _Is_pod_comparator is kept as it is part of mangled name.
                      template<typename _Key_compare,
                	       bool /* _Is_pod_comparator */ = __is_pod(_Key_compare)>
                #endif
      180000 -> 	struct _Rb_tree_impl
                	: public _Node_allocator
                	, public _Rb_tree_key_compare<_Key_compare>
                	, public _Rb_tree_header
                	{
                	  typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;
                
      180000 -> 	  _Rb_tree_impl()
                	    _GLIBCXX_NOEXCEPT_IF(
                		is_nothrow_default_constructible<_Node_allocator>::value
                		&& is_nothrow_default_constructible<_Base_key_compare>::value )
                	  : _Node_allocator()
                	  { }
                
                	  _Rb_tree_impl(const _Rb_tree_impl& __x)
                	  : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
                	  , _Base_key_compare(__x._M_key_compare)
                	  , _Rb_tree_header()
                	  { }
                
                #if __cplusplus < 201103L
                	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
                	  : _Node_allocator(__a), _Base_key_compare(__comp)
                	  { }
                #else
                	  _Rb_tree_impl(_Rb_tree_impl&&)
                	    noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
                	  = default;
                
                	  explicit
                	  _Rb_tree_impl(_Node_allocator&& __a)
                	  : _Node_allocator(std::move(__a))
                	  { }
                
                	  _Rb_tree_impl(_Rb_tree_impl&& __x, _Node_allocator&& __a)
                	  : _Node_allocator(std::move(__a)),
                	    _Base_key_compare(std::move(__x)),
                	    _Rb_tree_header(std::move(__x))
                	  { }
                
                	  _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
                	  : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
                	  { }
                #endif
                	};
                
                      _Rb_tree_impl<_Compare> _M_impl;
                
                    protected:
                      _Base_ptr&
                      _M_root() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Const_Base_ptr
                      _M_root() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Base_ptr&
                      _M_leftmost() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_left; }
                
                      _Const_Base_ptr
                      _M_leftmost() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_left; }
                
                      _Base_ptr&
                      _M_rightmost() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_right; }
                
                      _Const_Base_ptr
                      _M_rightmost() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_right; }
                
                      _Link_type
    16377332 ->       _M_mbegin() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
                
                      _Link_type
    16377332 ->       _M_begin() _GLIBCXX_NOEXCEPT
                      { return _M_mbegin(); }
                
                      _Const_Link_type
                      _M_begin() const _GLIBCXX_NOEXCEPT
                      {
                	return static_cast<_Const_Link_type>
                	  (this->_M_impl._M_header._M_parent);
                      }
                
                      _Base_ptr
    21594664 ->       _M_end() _GLIBCXX_NOEXCEPT
                      { return &this->_M_impl._M_header; }
                
                      _Const_Base_ptr
                      _M_end() const _GLIBCXX_NOEXCEPT
                      { return &this->_M_impl._M_header; }
                
                      static const _Key&
    94201451 ->       _S_key(_Const_Link_type __x)
                      {
                #if __cplusplus >= 201103L
                	// If we're asking for the key we're presumably using the comparison
                	// object, and so this is a good place to sanity check it.
                	static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
                		      "comparison object must be invocable "
                		      "with two arguments of key type");
                # if __cplusplus >= 201703L
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2542. Missing const requirements for associative containers
                	if constexpr (__is_invocable<_Compare&, const _Key&, const _Key&>{})
                	  static_assert(
                	      is_invocable_v<const _Compare&, const _Key&, const _Key&>,
                	      "comparison object must be invocable as const");
                # endif // C++17
                #endif // C++11
                
                	return _KeyOfValue()(*__x->_M_valptr());
                      }
                
                      static _Link_type
    41182497 ->       _S_left(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(__x->_M_left); }
                
                      static _Const_Link_type
                      _S_left(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Const_Link_type>(__x->_M_left); }
                
                      static _Link_type
    43530866 ->       _S_right(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(__x->_M_right); }
                
                      static _Const_Link_type
                      _S_right(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Const_Link_type>(__x->_M_right); }
                
                      static const _Key&
    20282752 ->       _S_key(_Const_Base_ptr __x)
                      { return _S_key(static_cast<_Const_Link_type>(__x)); }
                
                      static _Base_ptr
                      _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Const_Base_ptr
                      _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Base_ptr
                      _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                      static _Const_Base_ptr
                      _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                    public:
                      typedef _Rb_tree_iterator<value_type>       iterator;
                      typedef _Rb_tree_const_iterator<value_type> const_iterator;
                
                      typedef std::reverse_iterator<iterator>       reverse_iterator;
                      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                
                #if __cplusplus > 201402L
                      using node_type = _Node_handle<_Key, _Val, _Node_allocator>;
                      using insert_return_type = _Node_insert_return<
                	conditional_t<is_same_v<_Key, _Val>, const_iterator, iterator>,
                	node_type>;
                #endif
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_unique_pos(const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_equal_pos(const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_hint_unique_pos(const_iterator __pos,
                				    const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_hint_equal_pos(const_iterator __pos,
                				   const key_type& __k);
                
                    private:
                #if __cplusplus >= 201103L
                      template<typename _Arg, typename _NodeGen>
                	iterator
                	_M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);
                
                      iterator
                      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_lower(_Base_ptr __y, _Arg&& __v);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_equal_lower(_Arg&& __x);
                
                      iterator
                      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);
                
                      iterator
                      _M_insert_equal_lower_node(_Link_type __z);
                #else
                      template<typename _NodeGen>
                	iterator
                	_M_insert_(_Base_ptr __x, _Base_ptr __y,
                		   const value_type& __v, _NodeGen&);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 233. Insertion hints in associative containers.
                      iterator
                      _M_insert_lower(_Base_ptr __y, const value_type& __v);
                
                      iterator
                      _M_insert_equal_lower(const value_type& __x);
                #endif
                
                      enum { __as_lvalue, __as_rvalue };
                
                      template<bool _MoveValues, typename _NodeGen>
                	_Link_type
                	_M_copy(_Link_type, _Base_ptr, _NodeGen&);
                
                      template<bool _MoveValues, typename _NodeGen>
                	_Link_type
                	_M_copy(const _Rb_tree& __x, _NodeGen& __gen)
                	{
                	  _Link_type __root =
                	    _M_copy<_MoveValues>(__x._M_mbegin(), _M_end(), __gen);
                	  _M_leftmost() = _S_minimum(__root);
                	  _M_rightmost() = _S_maximum(__root);
                	  _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  return __root;
                	}
                
                      _Link_type
                      _M_copy(const _Rb_tree& __x)
                      {
                	_Alloc_node __an(*this);
                	return _M_copy<__as_lvalue>(__x, __an);
                      }
                
                      void
                      _M_erase(_Link_type __x);
                
                      iterator
                      _M_lower_bound(_Link_type __x, _Base_ptr __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
                		     const _Key& __k) const;
                
                      iterator
                      _M_upper_bound(_Link_type __x, _Base_ptr __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
                		     const _Key& __k) const;
                
                    public:
                      // allocation/deallocation
                #if __cplusplus < 201103L
                      _Rb_tree() { }
                #else
      180000 ->       _Rb_tree() = default;
                #endif
                
                      _Rb_tree(const _Compare& __comp,
                	       const allocator_type& __a = allocator_type())
                      : _M_impl(__comp, _Node_allocator(__a)) { }
                
                      _Rb_tree(const _Rb_tree& __x)
                      : _M_impl(__x._M_impl)
                      {
                	if (__x._M_root() != 0)
                	  _M_root() = _M_copy(__x);
                      }
                
                #if __cplusplus >= 201103L
                      _Rb_tree(const allocator_type& __a)
                      : _M_impl(_Node_allocator(__a))
                      { }
                
                      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
                      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
                      {
                	if (__x._M_root() != nullptr)
                	  _M_root() = _M_copy(__x);
                      }
                
                      _Rb_tree(_Rb_tree&&) = default;
                
                      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
                      : _Rb_tree(std::move(__x), _Node_allocator(__a))
                      { }
                
                    private:
                      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, true_type)
                      noexcept(is_nothrow_default_constructible<_Compare>::value)
                      : _M_impl(std::move(__x._M_impl), std::move(__a))
                      { }
                
                      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, false_type)
                      : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
                      {
                	if (__x._M_root() != nullptr)
                	  _M_move_data(__x, false_type{});
                      }
                
                    public:
                      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
                      noexcept( noexcept(
                	_Rb_tree(std::declval<_Rb_tree&&>(), std::declval<_Node_allocator&&>(),
                		 std::declval<typename _Alloc_traits::is_always_equal>())) )
                      : _Rb_tree(std::move(__x), std::move(__a),
                		 typename _Alloc_traits::is_always_equal{})
                      { }
                #endif
                
      180000 ->       ~_Rb_tree() _GLIBCXX_NOEXCEPT
                      { _M_erase(_M_begin()); }
                
                      _Rb_tree&
                      operator=(const _Rb_tree& __x);
                
                      // Accessors.
                      _Compare
                      key_comp() const
                      { return _M_impl._M_key_compare; }
                
                      iterator
     2585377 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_header._M_left); }
                
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_header._M_left); }
                
                      iterator
    16202668 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(&this->_M_impl._M_header); }
                
                      const_iterator
    10800000 ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(&this->_M_impl._M_header); }
                
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return _M_impl._M_node_count == 0; }
                
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_impl._M_node_count; }
                
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }
                
                      void
                      swap(_Rb_tree& __t)
                      _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value);
                
                      // Insert/erase.
                #if __cplusplus >= 201103L
                      template<typename _Arg>
                	pair<iterator, bool>
                	_M_insert_unique(_Arg&& __x);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_equal(_Arg&& __x);
                
                      template<typename _Arg, typename _NodeGen>
                	iterator
                	_M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_unique_(const_iterator __pos, _Arg&& __x)
                	{
                	  _Alloc_node __an(*this);
                	  return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
                	}
                
                      template<typename _Arg, typename _NodeGen>
                	iterator
                	_M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_equal_(const_iterator __pos, _Arg&& __x)
                	{
                	  _Alloc_node __an(*this);
                	  return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
                	}
                
                      template<typename... _Args>
                	pair<iterator, bool>
                	_M_emplace_unique(_Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_equal(_Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
                
                      template<typename _Iter>
                	using __same_value_type
                	  = is_same<value_type, typename iterator_traits<_Iter>::value_type>;
                
                      template<typename _InputIterator>
                	__enable_if_t<__same_value_type<_InputIterator>::value>
                	_M_insert_range_unique(_InputIterator __first, _InputIterator __last)
                	{
                	  _Alloc_node __an(*this);
                	  for (; __first != __last; ++__first)
                	    _M_insert_unique_(end(), *__first, __an);
                	}
                
                      template<typename _InputIterator>
                	__enable_if_t<!__same_value_type<_InputIterator>::value>
                	_M_insert_range_unique(_InputIterator __first, _InputIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    _M_emplace_unique(*__first);
                	}
                
                      template<typename _InputIterator>
                	__enable_if_t<__same_value_type<_InputIterator>::value>
                	_M_insert_range_equal(_InputIterator __first, _InputIterator __last)
                	{
                	  _Alloc_node __an(*this);
                	  for (; __first != __last; ++__first)
                	    _M_insert_equal_(end(), *__first, __an);
                	}
                
                      template<typename _InputIterator>
                	__enable_if_t<!__same_value_type<_InputIterator>::value>
                	_M_insert_range_equal(_InputIterator __first, _InputIterator __last)
                	{
                	  _Alloc_node __an(*this);
                	  for (; __first != __last; ++__first)
                	    _M_emplace_equal(*__first);
                	}
                #else
                      pair<iterator, bool>
                      _M_insert_unique(const value_type& __x);
                
                      iterator
                      _M_insert_equal(const value_type& __x);
                
                      template<typename _NodeGen>
                	iterator
                	_M_insert_unique_(const_iterator __pos, const value_type& __x,
                			  _NodeGen&);
                
                      iterator
                      _M_insert_unique_(const_iterator __pos, const value_type& __x)
                      {
                	_Alloc_node __an(*this);
                	return _M_insert_unique_(__pos, __x, __an);
                      }
                
                      template<typename _NodeGen>
                	iterator
                	_M_insert_equal_(const_iterator __pos, const value_type& __x,
                			 _NodeGen&);
                      iterator
                      _M_insert_equal_(const_iterator __pos, const value_type& __x)
                      {
                	_Alloc_node __an(*this);
                	return _M_insert_equal_(__pos, __x, __an);
                      }
                
                      template<typename _InputIterator>
                	void
                	_M_insert_range_unique(_InputIterator __first, _InputIterator __last)
                	{
                	  _Alloc_node __an(*this);
                	  for (; __first != __last; ++__first)
                	    _M_insert_unique_(end(), *__first, __an);
                	}
                
                      template<typename _InputIterator>
                	void
                	_M_insert_range_equal(_InputIterator __first, _InputIterator __last)
                	{
                	  _Alloc_node __an(*this);
                	  for (; __first != __last; ++__first)
                	    _M_insert_equal_(end(), *__first, __an);
                	}
                #endif
                
                    private:
                      void
                      _M_erase_aux(const_iterator __position);
                
                      void
                      _M_erase_aux(const_iterator __first, const_iterator __last);
                
                    public:
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __position)
                      {
                	__glibcxx_assert(__position != end());
                	const_iterator __result = __position;
                	++__result;
                	_M_erase_aux(__position);
                	return __result._M_const_cast();
                      }
                
                      // LWG 2059.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(iterator __position)
                      {
                	__glibcxx_assert(__position != end());
                	iterator __result = __position;
                	++__result;
                	_M_erase_aux(__position);
                	return __result;
                      }
                #else
                      void
                      erase(iterator __position)
                      {
                	__glibcxx_assert(__position != end());
                	_M_erase_aux(__position);
                      }
                
                      void
                      erase(const_iterator __position)
                      {
                	__glibcxx_assert(__position != end());
                	_M_erase_aux(__position);
                      }
                #endif
                
                      size_type
                      erase(const key_type& __x);
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      {
                	_M_erase_aux(__first, __last);
                	return __last._M_const_cast();
                      }
                #else
                      void
                      erase(iterator __first, iterator __last)
                      { _M_erase_aux(__first, __last); }
                
                      void
                      erase(const_iterator __first, const_iterator __last)
                      { _M_erase_aux(__first, __last); }
                #endif
                
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      {
                	_M_erase(_M_begin());
                	_M_impl._M_reset();
                      }
                
                      // Set operations.
                      iterator
                      find(const key_type& __k);
                
                      const_iterator
                      find(const key_type& __k) const;
                
                      size_type
                      count(const key_type& __k) const;
                
                      iterator
                      lower_bound(const key_type& __k)
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      lower_bound(const key_type& __k) const
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      iterator
                      upper_bound(const key_type& __k)
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      upper_bound(const key_type& __k) const
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      pair<iterator, iterator>
                      equal_range(const key_type& __k);
                
                      pair<const_iterator, const_iterator>
                      equal_range(const key_type& __k) const;
                
                #if __cplusplus >= 201402L
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	iterator
                	_M_find_tr(const _Kt& __k)
                	{
                	  const _Rb_tree* __const_this = this;
                	  return __const_this->_M_find_tr(__k)._M_const_cast();
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	const_iterator
                	_M_find_tr(const _Kt& __k) const
                	{
                	  auto __j = _M_lower_bound_tr(__k);
                	  if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
                	    __j = end();
                	  return __j;
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	size_type
                	_M_count_tr(const _Kt& __k) const
                	{
                	  auto __p = _M_equal_range_tr(__k);
                	  return std::distance(__p.first, __p.second);
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	iterator
                	_M_lower_bound_tr(const _Kt& __k)
                	{
                	  const _Rb_tree* __const_this = this;
                	  return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	const_iterator
                	_M_lower_bound_tr(const _Kt& __k) const
                	{
                	  auto __x = _M_begin();
                	  auto __y = _M_end();
                	  while (__x != 0)
                	    if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	      {
                		__y = __x;
                		__x = _S_left(__x);
                	      }
                	    else
                	      __x = _S_right(__x);
                	  return const_iterator(__y);
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	iterator
                	_M_upper_bound_tr(const _Kt& __k)
                	{
                	  const _Rb_tree* __const_this = this;
                	  return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	const_iterator
                	_M_upper_bound_tr(const _Kt& __k) const
                	{
                	  auto __x = _M_begin();
                	  auto __y = _M_end();
                	  while (__x != 0)
                	    if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	      {
                		__y = __x;
                		__x = _S_left(__x);
                	      }
                	    else
                	      __x = _S_right(__x);
                	  return const_iterator(__y);
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	pair<iterator, iterator>
                	_M_equal_range_tr(const _Kt& __k)
                	{
                	  const _Rb_tree* __const_this = this;
                	  auto __ret = __const_this->_M_equal_range_tr(__k);
                	  return { __ret.first._M_const_cast(), __ret.second._M_const_cast() };
                	}
                
                      template<typename _Kt,
                	       typename _Req = __has_is_transparent_t<_Compare, _Kt>>
                	pair<const_iterator, const_iterator>
                	_M_equal_range_tr(const _Kt& __k) const
                	{
                	  auto __low = _M_lower_bound_tr(__k);
                	  auto __high = __low;
                	  auto& __cmp = _M_impl._M_key_compare;
                	  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
                	    ++__high;
                	  return { __low, __high };
                	}
                #endif
                
                      // Debugging.
                      bool
                      __rb_verify() const;
                
                #if __cplusplus >= 201103L
                      _Rb_tree&
                      operator=(_Rb_tree&&)
                      noexcept(_Alloc_traits::_S_nothrow_move()
                	       && is_nothrow_move_assignable<_Compare>::value);
                
                      template<typename _Iterator>
                	void
                	_M_assign_unique(_Iterator, _Iterator);
                
                      template<typename _Iterator>
                	void
                	_M_assign_equal(_Iterator, _Iterator);
                
                    private:
                      // Move elements from container with equal allocator.
                      void
                      _M_move_data(_Rb_tree& __x, true_type)
                      { _M_impl._M_move_data(__x._M_impl); }
                
                      // Move elements from container with possibly non-equal allocator,
                      // which might result in a copy not a move.
                      void
                      _M_move_data(_Rb_tree&, false_type);
                
                      // Move assignment from container with equal allocator.
                      void
                      _M_move_assign(_Rb_tree&, true_type);
                
                      // Move assignment from container with possibly non-equal allocator,
                      // which might result in a copy not a move.
                      void
                      _M_move_assign(_Rb_tree&, false_type);
                #endif
                
                #if __cplusplus > 201402L
                    public:
                      /// Re-insert an extracted node.
                      insert_return_type
                      _M_reinsert_node_unique(node_type&& __nh)
                      {
                	insert_return_type __ret;
                	if (__nh.empty())
                	  __ret.position = end();
                	else
                	  {
                	    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);
                
                	    auto __res = _M_get_insert_unique_pos(__nh._M_key());
                	    if (__res.second)
                	      {
                		__ret.position
                		  = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
                		__nh._M_ptr = nullptr;
                		__ret.inserted = true;
                	      }
                	    else
                	      {
                		__ret.node = std::move(__nh);
                		__ret.position = iterator(__res.first);
                		__ret.inserted = false;
                	      }
                	  }
                	return __ret;
                      }
                
                      /// Re-insert an extracted node.
                      iterator
                      _M_reinsert_node_equal(node_type&& __nh)
                      {
                	iterator __ret;
                	if (__nh.empty())
                	  __ret = end();
                	else
                	  {
                	    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);
                	    auto __res = _M_get_insert_equal_pos(__nh._M_key());
                	    if (__res.second)
                	      __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
                	    else
                	      __ret = _M_insert_equal_lower_node(__nh._M_ptr);
                	    __nh._M_ptr = nullptr;
                	  }
                	return __ret;
                      }
                
                      /// Re-insert an extracted node.
                      iterator
                      _M_reinsert_node_hint_unique(const_iterator __hint, node_type&& __nh)
                      {
                	iterator __ret;
                	if (__nh.empty())
                	  __ret = end();
                	else
                	  {
                	    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);
                	    auto __res = _M_get_insert_hint_unique_pos(__hint, __nh._M_key());
                	    if (__res.second)
                	      {
                		__ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
                		__nh._M_ptr = nullptr;
                	      }
                	    else
                	      __ret = iterator(__res.first);
                	  }
                	return __ret;
                      }
                
                      /// Re-insert an extracted node.
                      iterator
                      _M_reinsert_node_hint_equal(const_iterator __hint, node_type&& __nh)
                      {
                	iterator __ret;
                	if (__nh.empty())
                	  __ret = end();
                	else
                	  {
                	    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);
                	    auto __res = _M_get_insert_hint_equal_pos(__hint, __nh._M_key());
                	    if (__res.second)
                	      __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
                	    else
                	      __ret = _M_insert_equal_lower_node(__nh._M_ptr);
                	    __nh._M_ptr = nullptr;
                	  }
                	return __ret;
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const_iterator __pos)
                      {
                	auto __ptr = _Rb_tree_rebalance_for_erase(
                	    __pos._M_const_cast()._M_node, _M_impl._M_header);
                	--_M_impl._M_node_count;
                	return { static_cast<_Link_type>(__ptr), _M_get_Node_allocator() };
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const key_type& __k)
                      {
                	node_type __nh;
                	auto __pos = find(__k);
                	if (__pos != end())
                	  __nh = extract(const_iterator(__pos));
                	return __nh;
                      }
                
                      template<typename _Compare2>
                	using _Compatible_tree
                	  = _Rb_tree<_Key, _Val, _KeyOfValue, _Compare2, _Alloc>;
                
                      template<typename, typename>
                	friend class _Rb_tree_merge_helper;
                
                      /// Merge from a compatible container into one with unique keys.
                      template<typename _Compare2>
                	void
                	_M_merge_unique(_Compatible_tree<_Compare2>& __src) noexcept
                	{
                	  using _Merge_helper = _Rb_tree_merge_helper<_Rb_tree, _Compare2>;
                	  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
                	    {
                	      auto __pos = __i++;
                	      auto __res = _M_get_insert_unique_pos(_KeyOfValue()(*__pos));
                	      if (__res.second)
                		{
                		  auto& __src_impl = _Merge_helper::_S_get_impl(__src);
                		  auto __ptr = _Rb_tree_rebalance_for_erase(
                		      __pos._M_node, __src_impl._M_header);
                		  --__src_impl._M_node_count;
                		  _M_insert_node(__res.first, __res.second,
                				 static_cast<_Link_type>(__ptr));
                		}
                	    }
                	}
                
                      /// Merge from a compatible container into one with equivalent keys.
                      template<typename _Compare2>
                	void
                	_M_merge_equal(_Compatible_tree<_Compare2>& __src) noexcept
                	{
                	  using _Merge_helper = _Rb_tree_merge_helper<_Rb_tree, _Compare2>;
                	  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
                	    {
                	      auto __pos = __i++;
                	      auto __res = _M_get_insert_equal_pos(_KeyOfValue()(*__pos));
                	      if (__res.second)
                		{
                		  auto& __src_impl = _Merge_helper::_S_get_impl(__src);
                		  auto __ptr = _Rb_tree_rebalance_for_erase(
                		      __pos._M_node, __src_impl._M_header);
                		  --__src_impl._M_node_count;
                		  _M_insert_node(__res.first, __res.second,
                				 static_cast<_Link_type>(__ptr));
                		}
                	    }
                	}
                #endif // C++17
                
                      friend bool
                      operator==(const _Rb_tree& __x, const _Rb_tree& __y)
                      {
                	return __x.size() == __y.size()
                	  && std::equal(__x.begin(), __x.end(), __y.begin());
                      }
                
                #if __cpp_lib_three_way_comparison
                      friend auto
                      operator<=>(const _Rb_tree& __x, const _Rb_tree& __y)
                      {
                	if constexpr (requires { typename __detail::__synth3way_t<_Val>; })
                	  return std::lexicographical_compare_three_way(__x.begin(), __x.end(),
                							__y.begin(), __y.end(),
                							__detail::__synth3way);
                      }
                #else
                      friend bool
                      operator<(const _Rb_tree& __x, const _Rb_tree& __y)
                      {
                	return std::lexicographical_compare(__x.begin(), __x.end(),
                					    __y.begin(), __y.end());
                      }
                #endif
                    };
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    inline void
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                
                #if __cplusplus >= 201103L
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_data(_Rb_tree& __x, false_type)
                    {
                      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
                	_M_move_data(__x, true_type());
                      else
                	{
                	  _Alloc_node __an(*this);
                	  _M_root() =
                	    _M_copy<!__move_if_noexcept_cond<value_type>::value>(__x, __an);
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    inline void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_assign(_Rb_tree& __x, true_type)
                    {
                      clear();
                      if (__x._M_root() != nullptr)
                	_M_move_data(__x, true_type());
                      std::__alloc_on_move(_M_get_Node_allocator(),
                			   __x._M_get_Node_allocator());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_assign(_Rb_tree& __x, false_type)
                    {
                      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
                	return _M_move_assign(__x, true_type{});
                
                      // Try to move each node reusing existing nodes and copying __x nodes
                      // structure.
                      _Reuse_or_alloc_node __roan(*this);
                      _M_impl._M_reset();
                      if (__x._M_root() != nullptr)
                	{
                	  _M_root() = _M_copy<__as_rvalue>(__x, __roan);
                	  __x.clear();
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(_Rb_tree&& __x)
                    noexcept(_Alloc_traits::_S_nothrow_move()
                	     && is_nothrow_move_assignable<_Compare>::value)
                    {
                      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
                      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    template<typename _Iterator>
                      void
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_assign_unique(_Iterator __first, _Iterator __last)
                      {
                	_Reuse_or_alloc_node __roan(*this);
                	_M_impl._M_reset();
                	for (; __first != __last; ++__first)
                	  _M_insert_unique_(end(), *__first, __roan);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    template<typename _Iterator>
                      void
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_assign_equal(_Iterator __first, _Iterator __last)
                      {
                	_Reuse_or_alloc_node __roan(*this);
                	_M_impl._M_reset();
                	for (; __first != __last; ++__first)
                	  _M_insert_equal_(end(), *__first, __roan);
                      }
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(const _Rb_tree& __x)
                    {
                      if (this != &__x)
                	{
                	  // Note that _Key may be a constant type.
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      auto& __this_alloc = this->_M_get_Node_allocator();
                	      auto& __that_alloc = __x._M_get_Node_allocator();
                	      if (!_Alloc_traits::_S_always_equal()
                		  && __this_alloc != __that_alloc)
                		{
                		  // Replacement allocator cannot free existing storage, we need
                		  // to erase nodes first.
                		  clear();
                		  std::__alloc_on_copy(__this_alloc, __that_alloc);
                		}
                	    }
                #endif
                
                	  _Reuse_or_alloc_node __roan(*this);
                	  _M_impl._M_reset();
                	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                	  if (__x._M_root() != 0)
                	    _M_root() = _M_copy<__as_lvalue>(__x, __roan);
                	}
                
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg, typename _NodeGen>
                #else
                    template<typename _NodeGen>
                #endif
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
     5397332 ->       _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_insert_(_Base_ptr __x, _Base_ptr __p,
                #if __cplusplus >= 201103L
                		 _Arg&& __v,
                #else
                		 const _Val& __v,
                #endif
                		 _NodeGen& __node_gen)
                      {
                	bool __insert_left = (__x != 0 || __p == _M_end()
                			      || _M_impl._M_key_compare(_KeyOfValue()(__v),
                							_S_key(__p)));
                
                	_Link_type __z = __node_gen(_GLIBCXX_FORWARD(_Arg, __v));
                
                	_Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				      this->_M_impl._M_header);
                	++_M_impl._M_node_count;
                	return iterator(__z);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
                #else
                    _M_insert_lower(_Base_ptr __p, const _Val& __v)
                #endif
                    {
                      bool __insert_left = (__p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _KeyOfValue()(__v)));
                
                      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal_lower(_Arg&& __v)
                #else
                    _M_insert_equal_lower(const _Val& __v)
                #endif
                    {
                      _Link_type __x = _M_begin();
                      _Base_ptr __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
                		_S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                	   typename _Compare, typename _Alloc>
                    template<bool _MoveValues, typename _NodeGen>
                      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
                      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                      _M_copy(_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
                      {
                	// Structural copy. __x and __p must be non-null.
                	_Link_type __top = _M_clone_node<_MoveValues>(__x, __node_gen);
                	__top->_M_parent = __p;
                
                	__try
                	  {
                	    if (__x->_M_right)
                	      __top->_M_right =
                		_M_copy<_MoveValues>(_S_right(__x), __top, __node_gen);
                	    __p = __top;
                	    __x = _S_left(__x);
                
                	    while (__x != 0)
                	      {
                		_Link_type __y = _M_clone_node<_MoveValues>(__x, __node_gen);
                		__p->_M_left = __y;
                		__y->_M_parent = __p;
                		if (__x->_M_right)
                		  __y->_M_right = _M_copy<_MoveValues>(_S_right(__x),
                						       __y, __node_gen);
                		__p = __y;
                		__x = _S_left(__x);
                	      }
                	  }
                	__catch(...)
                	  {
                	    _M_erase(__top);
                	    __throw_exception_again;
                	  }
                	return __top;
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    void
      180000 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase(_Link_type __x)
                    {
                      // Erase without rebalancing.
                      while (__x != 0)
                	{
                	  _M_erase(_S_right(__x));
                	  _Link_type __y = _S_left(__x);
                	  _M_drop_node(__x);
                	  __x = __y;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
    10800000 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Link_type __x, _Base_ptr __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Link_type __x, _Base_ptr __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k)
                    {
                      _Link_type __x = _M_begin();
                      _Base_ptr __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Link_type __xu(__x);
                	      _Base_ptr __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<iterator,
                			  iterator>(_M_lower_bound(__x, __y, __k),
                				    _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<iterator, iterator>(iterator(__y),
                				      iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin();
                      _Const_Base_ptr __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Const_Link_type __xu(__x);
                	      _Const_Base_ptr __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<const_iterator,
                			  const_iterator>(_M_lower_bound(__x, __y, __k),
                					  _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<const_iterator, const_iterator>(const_iterator(__y),
                						  const_iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    swap(_Rb_tree& __t)
                    _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value)
                    {
                      if (_M_root() == 0)
                	{
                	  if (__t._M_root() != 0)
                	    _M_impl._M_move_data(__t._M_impl);
                	}
                      else if (__t._M_root() == 0)
                	__t._M_impl._M_move_data(_M_impl);
                      else
                	{
                	  std::swap(_M_root(),__t._M_root());
                	  std::swap(_M_leftmost(),__t._M_leftmost());
                	  std::swap(_M_rightmost(),__t._M_rightmost());
                
                	  _M_root()->_M_parent = _M_end();
                	  __t._M_root()->_M_parent = __t._M_end();
                	  std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
                	}
                      // No need to swap header's color as it does not change.
                      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
                
                      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
                				__t._M_get_Node_allocator());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
     5397332 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_unique_pos(const key_type& __k)
                    {
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                      _Link_type __x = _M_begin();
                      _Base_ptr __y = _M_end();
                      bool __comp = true;
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
                	  __x = __comp ? _S_left(__x) : _S_right(__x);
                	}
                      iterator __j = iterator(__y);
                      if (__comp)
                	{
                	  if (__j == begin())
                	    return _Res(__x, __y);
                	  else
                	    --__j;
                	}
                      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
                	return _Res(__x, __y);
                      return _Res(__j._M_node, 0);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_equal_pos(const key_type& __k)
                    {
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                      _Link_type __x = _M_begin();
                      _Base_ptr __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
                		_S_left(__x) : _S_right(__x);
                	}
                      return _Res(__x, __y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator, bool>
     5397332 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_unique(_Arg&& __v)
                #else
                    _M_insert_unique(const _Val& __v)
                #endif
                    {
                      typedef pair<iterator, bool> _Res;
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_unique_pos(_KeyOfValue()(__v));
                
                      if (__res.second)
                	{
                	  _Alloc_node __an(*this);
                	  return _Res(_M_insert_(__res.first, __res.second,
                				 _GLIBCXX_FORWARD(_Arg, __v), __an),
                		      true);
                	}
                
                      return _Res(iterator(__res.first), false);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal(_Arg&& __v)
                #else
                    _M_insert_equal(const _Val& __v)
                #endif
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_equal_pos(_KeyOfValue()(__v));
                      _Alloc_node __an(*this);
                      return _M_insert_(__res.first, __res.second,
                			_GLIBCXX_FORWARD(_Arg, __v), __an);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_hint_unique_pos(const_iterator __position,
                				  const key_type& __k)
                    {
                      iterator __pos = __position._M_const_cast();
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                
                      // end()
                      if (__pos._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
                	    return _Res(0, _M_rightmost());
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
                	{
                	  // First, try before...
                	  iterator __before = __pos;
                	  if (__pos._M_node == _M_leftmost()) // begin()
                	    return _Res(_M_leftmost(), _M_leftmost());
                	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _Res(0, __before._M_node);
                	      else
                		return _Res(__pos._M_node, __pos._M_node);
                	    }
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                	{
                	  // ... then try after.
                	  iterator __after = __pos;
                	  if (__pos._M_node == _M_rightmost())
                	    return _Res(0, _M_rightmost());
                	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
                	    {
                	      if (_S_right(__pos._M_node) == 0)
                		return _Res(0, __pos._M_node);
                	      else
                		return _Res(__after._M_node, __after._M_node);
                	    }
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else
                	// Equivalent keys.
                	return _Res(__pos._M_node, 0);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg, typename _NodeGen>
                #else
                    template<typename _NodeGen>
                #endif
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_insert_unique_(const_iterator __position,
                #if __cplusplus >= 201103L
                			_Arg&& __v,
                #else
                			const _Val& __v,
                #endif
                			_NodeGen& __node_gen)
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
                
                      if (__res.second)
                	return _M_insert_(__res.first, __res.second,
                			  _GLIBCXX_FORWARD(_Arg, __v),
                			  __node_gen);
                      return iterator(__res.first);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
                    {
                      iterator __pos = __position._M_const_cast();
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                
                      // end()
                      if (__pos._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
                	    return _Res(0, _M_rightmost());
                	  else
                	    return _M_get_insert_equal_pos(__k);
                	}
                      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                	{
                	  // First, try before...
                	  iterator __before = __pos;
                	  if (__pos._M_node == _M_leftmost()) // begin()
                	    return _Res(_M_leftmost(), _M_leftmost());
                	  else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _Res(0, __before._M_node);
                	      else
                		return _Res(__pos._M_node, __pos._M_node);
                	    }
                	  else
                	    return _M_get_insert_equal_pos(__k);
                	}
                      else
                	{
                	  // ... then try after.
                	  iterator __after = __pos;
                	  if (__pos._M_node == _M_rightmost())
                	    return _Res(0, _M_rightmost());
                	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
                	    {
                	      if (_S_right(__pos._M_node) == 0)
                		return _Res(0, __pos._M_node);
                	      else
                		return _Res(__after._M_node, __after._M_node);
                	    }
                	  else
                	    return _Res(0, 0);
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg, typename _NodeGen>
                #else
                    template<typename _NodeGen>
                #endif
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_insert_equal_(const_iterator __position,
                #if __cplusplus >= 201103L
                		       _Arg&& __v,
                #else
                		       const _Val& __v,
                #endif
                		       _NodeGen& __node_gen)
                      {
                	pair<_Base_ptr, _Base_ptr> __res
                	  = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
                
                	if (__res.second)
                	  return _M_insert_(__res.first, __res.second,
                			    _GLIBCXX_FORWARD(_Arg, __v),
                			    __node_gen);
                
                	return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_S_key(__z),
                						      _S_key(__p)));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
                    {
                      bool __insert_left = (__p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _S_key(__z)));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_equal_lower_node(_Link_type __z)
                    {
                      _Link_type __x = _M_begin();
                      _Base_ptr __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
                		_S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower_node(__y, __z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			     _Compare, _Alloc>::iterator, bool>
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_unique(_Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    typedef pair<iterator, bool> _Res;
                	    auto __res = _M_get_insert_unique_pos(_S_key(__z));
                	    if (__res.second)
                	      return _Res(_M_insert_node(__res.first, __res.second, __z), true);
                	
                	    _M_drop_node(__z);
                	    return _Res(iterator(__res.first), false);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_equal(_Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_equal_pos(_S_key(__z));
                	    return _M_insert_node(__res.first, __res.second, __z);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
                
                	    if (__res.second)
                	      return _M_insert_node(__res.first, __res.second, __z);
                
                	    _M_drop_node(__z);
                	    return iterator(__res.first);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));
                
                	    if (__res.second)
                	      return _M_insert_node(__res.first, __res.second, __z);
                
                	    return _M_insert_equal_lower_node(__z);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                #endif
                
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase_aux(const_iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(const_cast<_Base_ptr>(__position._M_node),
                				 this->_M_impl._M_header));
                      _M_drop_node(__y);
                      --_M_impl._M_node_count;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase_aux(const_iterator __first, const_iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  _M_erase_aux(__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key& __x)
                    {
                      pair<iterator, iterator> __p = equal_range(__x);
                      const size_type __old_size = size();
                      _M_erase_aux(__p.first, __p.second);
                      return __old_size - size();
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
    10800000 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k)
                    {
                      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k,
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k) const
                    {
                      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k,
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    count(const _Key& __k) const
                    {
                      pair<const_iterator, const_iterator> __p = equal_range(__k);
                      const size_type __n = std::distance(__p.first, __p.second);
                      return __n;
                    }
                
                  _GLIBCXX_PURE unsigned int
                  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                		       const _Rb_tree_node_base* __root) throw ();
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                	   typename _Compare, typename _Alloc>
                    bool
                    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
                    {
                      if (_M_impl._M_node_count == 0 || begin() == end())
                	return _M_impl._M_node_count == 0 && begin() == end()
                	       && this->_M_impl._M_header._M_left == _M_end()
                	       && this->_M_impl._M_header._M_right == _M_end();
                
                      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
                      for (const_iterator __it = begin(); __it != end(); ++__it)
                	{
                	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
                	  _Const_Link_type __L = _S_left(__x);
                	  _Const_Link_type __R = _S_right(__x);
                
                	  if (__x->_M_color == _S_red)
                	    if ((__L && __L->_M_color == _S_red)
                		|| (__R && __R->_M_color == _S_red))
                	      return false;
                
                	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                	    return false;
                	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                	    return false;
                
                	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                	    return false;
                	}
                
                      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
                	return false;
                      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
                	return false;
                      return true;
                    }
                
                #if __cplusplus > 201402L
                  // Allow access to internals of compatible _Rb_tree specializations.
                  template<typename _Key, typename _Val, typename _Sel, typename _Cmp1,
                	   typename _Alloc, typename _Cmp2>
                    struct _Rb_tree_merge_helper<_Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>,
                				 _Cmp2>
                    {
                    private:
                      friend class _Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>;
                
                      static auto&
                      _S_get_impl(_Rb_tree<_Key, _Val, _Sel, _Cmp2, _Alloc>& __tree)
                      { return __tree._M_impl; }
                    };
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      238   94201451
      757   94201451
      787   43530866
      779   41182497
      273   40382709
      749   21594664
      547   21589328
      795   20282752
      734   16377332
      738   16377332

Execution Summary:

       40   Executable lines in this file
       40   Lines executed
   100.00   Percent of the file executed

585851441   Total number of line executions
14646286.03   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/./Point/point.cpp:
                #include "point.hpp"
                #include <cmath>
                
                // Default constructor
                // Initializes the point to (0, 0, 0)
                
       ##### -> Point::Point()
                {
                  x = 0;
                  y = 0;
                  z = 0;
                }
                
                // Intializes the point to the given (x, y, z)
          60 -> Point::Point(double x, double y, double z):
                  x(x), y(y), z(z) {}
                
                // Copy Constructor
         123 -> Point::Point(const Point &P)
                {
                  x = P.get_x();
                  y = P.get_y();
                  z = P.get_z();
                }
                
                //Copy assignment operator
                Point& Point::operator= (const Point& P)
       ##### -> {
                  this->x = P.get_x();
                  this->y = P.get_y();
                  this->z = P.get_z();
                  return *this;
                }
                
                // Destructor - Nothing to do here
         183 -> Point::~Point()
                {
                }
                
                // Mutators
                
                void Point::set_x(const double x)
       ##### -> {
                  this->x = x;
                }
                
                void Point::set_y(const double y)
       ##### -> {
                  this->y = y;
                
                }
                void Point::set_z(const double z)
       ##### -> {
                  this->z = z;
                }
                
                
                // Accessors
    18000123 -> double Point::get_x() const {
                  return x;
                }
                
    18000123 -> double Point::get_y() const {
                  return y;
                }
                
    18000123 -> double Point::get_z() const {
                  return z;
                }
                
                
                // Distance method
                
    18000000 -> double Point::distance_to(const Point& target) const{
                
                  double x_ = target.get_x();
                  double y_ = target.get_y();
                  double z_ = target.get_z();
                
                  double dist = sqrt (
                                    ( (x - x_) * (x - x_)) +
                                    ( (y - y_) * (y - y_)) +
                                    ( (z - z_) * (z - z_))
                                      );
                
                  return dist;
                }


Top 10 Lines:

     Line      Count

       59   18000123
       63   18000123
       67   18000123
       74   18000000
       36        183
       19        123
       15         60

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

 72000735   Total number of line executions
6000061.25   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/./Genetic-Algorithm/Path_representation.hpp:
                /*
                 * @file Genetic/Path_representation.h
                 * @author Shah Anwaar Khalid
                 *
                 * The class represents path representation of a genome.
                 */
                
                #ifndef PATH_REPRESENTATION_H
                #define PATH_REPRESENTATION_H
                
                #include "../Point/point.hpp"
                #include "Crossover/crossover_base.hpp"
                #include <vector>
                #include <cstdlib>
                
                //class Crossover;
     3685554 -> class PathRepresentation {
                
                  public:
                    //! Constructors
                
                    /*
                     * Takes the number of points that will be visited
                     * & generates a random order to visit those points.
                     */
                    PathRepresentation(const int numPoints);
                
                    /*
                     * Initializes the genome from the specified visit order.
                     */
                
                    PathRepresentation(const std::vector<int> &order);
                
                    //! Destructor
                    ~PathRepresentation();
                
                    //! Fitness Score
                    double fitness_score(const std::vector<Point>& points);
                
                    //! Mutate the gene
                    void mutate();
                
                    //! Order of visitation
                    std::vector<int> get_order() const;
                
                    //! Returns the fitness score
                    double get_fitness_score() const;
                
                  private:
                    std::vector<int> genome;
                    double fitnessScore;
                
                };
                
                PathRepresentation run_genetic_algorithm( const std::vector<Point>&points,
                                                          Crossover* CrossoverObject,
                                                          size_t populationSize, size_t numGenerations,
                                                          size_t keepPopulation, size_t numMutations);
                
                bool compare_paths(const PathRepresentation& A, const PathRepresentation &B);
                #endif


Top 10 Lines:

     Line      Count

       17    3685554

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

  3685554   Total number of line executions
3685554.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_algo.h:
                // Algorithm implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algo.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGO_H
                #define _STL_ALGO_H 1
                
                #include <cstdlib>	     // for rand
                #include <bits/algorithmfwd.h>
                #include <bits/stl_heap.h>
                #include <bits/stl_tempbuf.h>  // for _Temporary_buffer
                #include <bits/predefined_ops.h>
                
                #if __cplusplus >= 201103L
                #include <bits/uniform_int_dist.h>
                #endif
                
                // See concept_check.h for the __glibcxx_*_requires macros.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
                  template<typename _Iterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
       30407 ->     __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
                			   _Iterator __c, _Compare __comp)
                    {
                      if (__comp(__a, __b))
                	{
                	  if (__comp(__b, __c))
                	    std::iter_swap(__result, __b);
                	  else if (__comp(__a, __c))
                	    std::iter_swap(__result, __c);
                	  else
                	    std::iter_swap(__result, __a);
                	}
                      else if (__comp(__a, __c))
                	std::iter_swap(__result, __a);
                      else if (__comp(__b, __c))
                	std::iter_swap(__result, __c);
                      else
                	std::iter_swap(__result, __b);
                    }
                
                  /// Provided for stable_partition to use.
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    __find_if_not(_InputIterator __first, _InputIterator __last,
                		  _Predicate __pred)
                    {
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__negate(__pred),
                			    std::__iterator_category(__first));
                    }
                
                  /// Like find_if_not(), but uses and updates a count of the
                  /// remaining range length instead of comparing against an end
                  /// iterator.
                  template<typename _InputIterator, typename _Predicate, typename _Distance>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
                    {
                      for (; __len; --__len,  (void) ++__first)
                	if (!__pred(__first))
                	  break;
                      return __first;
                    }
                
                  // set_difference
                  // set_intersection
                  // set_symmetric_difference
                  // set_union
                  // for_each
                  // find
                  // find_if
                  // find_first_of
                  // adjacent_find
                  // count
                  // count_if
                  // search
                
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator1
                    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	     _BinaryPredicate  __predicate)
                    {
                      // Test for empty ranges
                      if (__first1 == __last1 || __first2 == __last2)
                	return __first1;
                
                      // Test for a pattern of length 1.
                      _ForwardIterator2 __p1(__first2);
                      if (++__p1 == __last2)
                	return std::__find_if(__first1, __last1,
                		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
                
                      // General case.
                      _ForwardIterator1 __current = __first1;
                
                      for (;;)
                	{
                	  __first1 =
                	    std::__find_if(__first1, __last1,
                		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
                
                	  if (__first1 == __last1)
                	    return __last1;
                
                	  _ForwardIterator2 __p = __p1;
                	  __current = __first1;
                	  if (++__current == __last1)
                	    return __last1;
                
                	  while (__predicate(__current, __p))
                	    {
                	      if (++__p == __last2)
                		return __first1;
                	      if (++__current == __last1)
                		return __last1;
                	    }
                	  ++__first1;
                	}
                      return __first1;
                    }
                
                  // search_n
                
                  /**
                   *  This is an helper function for search_n overloaded for forward iterators.
                  */
                  template<typename _ForwardIterator, typename _Integer,
                	   typename _UnaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
                		   _Integer __count, _UnaryPredicate __unary_pred,
                		   std::forward_iterator_tag)
                    {
                      __first = std::__find_if(__first, __last, __unary_pred);
                      while (__first != __last)
                	{
                	  typename iterator_traits<_ForwardIterator>::difference_type
                	    __n = __count;
                	  _ForwardIterator __i = __first;
                	  ++__i;
                	  while (__i != __last && __n != 1 && __unary_pred(__i))
                	    {
                	      ++__i;
                	      --__n;
                	    }
                	  if (__n == 1)
                	    return __first;
                	  if (__i == __last)
                	    return __last;
                	  __first = std::__find_if(++__i, __last, __unary_pred);
                	}
                      return __last;
                    }
                
                  /**
                   *  This is an helper function for search_n overloaded for random access
                   *  iterators.
                  */
                  template<typename _RandomAccessIter, typename _Integer,
                	   typename _UnaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIter
                    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
                		   _Integer __count, _UnaryPredicate __unary_pred,
                		   std::random_access_iterator_tag)
                    {
                      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
                	_DistanceType;
                
                      _DistanceType __tailSize = __last - __first;
                      _DistanceType __remainder = __count;
                
                      while (__remainder <= __tailSize) // the main loop...
                	{
                	  __first += __remainder;
                	  __tailSize -= __remainder;
                	  // __first here is always pointing to one past the last element of
                	  // next possible match.
                	  _RandomAccessIter __backTrack = __first; 
                	  while (__unary_pred(--__backTrack))
                	    {
                	      if (--__remainder == 0)
                		return (__first - __count); // Success
                	    }
                	  __remainder = __count + 1 - (__first - __backTrack);
                	}
                      return __last; // Failure
                    }
                
                  template<typename _ForwardIterator, typename _Integer,
                	   typename _UnaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __search_n(_ForwardIterator __first, _ForwardIterator __last,
                	       _Integer __count,
                	       _UnaryPredicate __unary_pred)
                    {
                      if (__count <= 0)
                	return __first;
                
                      if (__count == 1)
                	return std::__find_if(__first, __last, __unary_pred);
                
                      return std::__search_n_aux(__first, __last, __count, __unary_pred,
                				 std::__iterator_category(__first));
                    }
                
                  // find_end for forward iterators.
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator1
                    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	       forward_iterator_tag, forward_iterator_tag,
                	       _BinaryPredicate __comp)
                    {
                      if (__first2 == __last2)
                	return __last1;
                
                      _ForwardIterator1 __result = __last1;
                      while (1)
                	{
                	  _ForwardIterator1 __new_result
                	    = std::__search(__first1, __last1, __first2, __last2, __comp);
                	  if (__new_result == __last1)
                	    return __result;
                	  else
                	    {
                	      __result = __new_result;
                	      __first1 = __new_result;
                	      ++__first1;
                	    }
                	}
                    }
                
                  // find_end for bidirectional iterators (much faster).
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _BidirectionalIterator1
                    __find_end(_BidirectionalIterator1 __first1,
                	       _BidirectionalIterator1 __last1,
                	       _BidirectionalIterator2 __first2,
                	       _BidirectionalIterator2 __last2,
                	       bidirectional_iterator_tag, bidirectional_iterator_tag,
                	       _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator1>)
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator2>)
                
                      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
                      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
                
                      _RevIterator1 __rlast1(__first1);
                      _RevIterator2 __rlast2(__first2);
                      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
                					      _RevIterator2(__last2), __rlast2,
                					      __comp);
                
                      if (__rresult == __rlast1)
                	return __last1;
                      else
                	{
                	  _BidirectionalIterator1 __result = __rresult.base();
                	  std::advance(__result, -std::distance(__first2, __last2));
                	  return __result;
                	}
                    }
                
                  /**
                   *  @brief  Find last matching subsequence in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of sequence to match.
                   *  @param  __last2   End of sequence to match.
                   *  @return   The last iterator @c i in the range
                   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
                   *  @p *(__first2+N) for each @c N in the range @p
                   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) and returns an iterator to the __first
                   *  element of the sub-sequence, or @p __last1 if the sub-sequence
                   *  is not found.  The sub-sequence will be the last such
                   *  subsequence contained in [__first1,__last1).
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.  This means that the returned
                   *  iterator @c i will be in the range @p
                   *  [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__find_end(__first1, __last1, __first2, __last2,
                			     std::__iterator_category(__first1),
                			     std::__iterator_category(__first2),
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Find last matching subsequence in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of sequence to match.
                   *  @param  __last2   End of sequence to match.
                   *  @param  __comp    The predicate to use.
                   *  @return The last iterator @c i in the range @p
                   *  [__first1,__last1-(__last2-__first2)) such that @c
                   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
                   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
                   *  exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) using comp as a predicate and returns an
                   *  iterator to the first element of the sub-sequence, or @p __last1
                   *  if the sub-sequence is not found.  The sub-sequence will be the
                   *  last such subsequence contained in [__first,__last1).
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.  This means that the returned
                   *  iterator @c i will be in the range @p
                   *  [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	     _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__find_end(__first1, __last1, __first2, __last2,
                			     std::__iterator_category(__first1),
                			     std::__iterator_category(__first2),
                			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Checks that a predicate is true for all the elements
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if @p __pred is true for each element in the range
                   *  @p [__first,__last), and false otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return __last == std::find_if_not(__first, __last, __pred); }
                
                  /**
                   *  @brief  Checks that a predicate is false for all the elements
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if @p __pred is false for each element in the range
                   *  @p [__first,__last), and false otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
                
                  /**
                   *  @brief  Checks that a predicate is true for at least one element
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if an element exists in the range @p
                   *  [__first,__last) such that @p __pred is true, and false
                   *  otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return !std::none_of(__first, __last, __pred); }
                
                  /**
                   *  @brief  Find the first element in a sequence for which a
                   *          predicate is false.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    find_if_not(_InputIterator __first, _InputIterator __last,
                		_Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      return std::__find_if_not(__first, __last,
                				__gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief  Checks whether the sequence is partitioned.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
                   *  i.e. if all elements that satisfy @p __pred appear before those that
                   *  do not.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_partitioned(_InputIterator __first, _InputIterator __last,
                		   _Predicate __pred)
                    {
                      __first = std::find_if_not(__first, __last, __pred);
                      if (__first == __last)
                	return true;
                      ++__first;
                      return std::none_of(__first, __last, __pred);
                    }
                
                  /**
                   *  @brief  Find the partition point of a partitioned range.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __pred    A predicate.
                   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
                   *           and @p none_of(mid, __last, __pred) are both true.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    partition_point(_ForwardIterator __first, _ForwardIterator __last,
                		    _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_ForwardIterator>::value_type>)
                
                      // A specific debug-mode test will be necessary...
                      __glibcxx_requires_valid_range(__first, __last);
                
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__pred(*__middle))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                #endif
                
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __remove_copy_if(_InputIterator __first, _InputIterator __last,
                		     _OutputIterator __result, _Predicate __pred)
                    {
                      for (; __first != __last; ++__first)
                	if (!__pred(__first))
                	  {
                	    *__result = *__first;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Copy a sequence, removing elements of a given value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __value   The value to be removed.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) not equal
                   *  to @p __value to the range beginning at @p __result.
                   *  remove_copy() is stable, so the relative order of elements that
                   *  are copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    remove_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_copy_if(__first, __last, __result,
                	__gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Copy a sequence, removing elements for which a predicate is true.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns false to the range beginning at @p __result.
                   *
                   *  remove_copy_if() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    remove_copy_if(_InputIterator __first, _InputIterator __last,
                		   _OutputIterator __result, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_copy_if(__first, __last, __result,
                				   __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Copy the elements of a sequence for which a predicate is true.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns true to the range beginning at @p __result.
                   *
                   *  copy_if() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    copy_if(_InputIterator __first, _InputIterator __last,
                	    _OutputIterator __result, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  {
                	    *__result = *__first;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __copy_n(_InputIterator __first, _Size __n,
                	     _OutputIterator __result, input_iterator_tag)
                    {
                      return std::__niter_wrap(__result,
                			       __copy_n_a(__first, __n,
                					  std::__niter_base(__result), true));
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __copy_n(_RandomAccessIterator __first, _Size __n,
                	     _OutputIterator __result, random_access_iterator_tag)
                    { return std::copy(__first, __first + __n, __result); }
                
                  /**
                   *  @brief Copies the range [first,first+n) into [result,result+n).
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  result+n.
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                  */
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                
                      const auto __n2 = std::__size_to_integer(__n);
                      if (__n2 <= 0)
                	return __result;
                
                      __glibcxx_requires_can_increment(__first, __n2);
                      __glibcxx_requires_can_increment(__result, __n2);
                
                      return std::__copy_n(__first, __n2, __result,
                			   std::__iterator_category(__first));
                    }
                
                  /**
                   *  @brief Copy the elements of a sequence to separate output sequences
                   *         depending on the truth value of a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __out_true   An output iterator.
                   *  @param  __out_false  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   A pair designating the ends of the resulting sequences.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns true to the range beginning at @p out_true
                   *  and each element for which @p __pred returns false to @p __out_false.
                  */
                  template<typename _InputIterator, typename _OutputIterator1,
                	   typename _OutputIterator2, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    pair<_OutputIterator1, _OutputIterator2>
                    partition_copy(_InputIterator __first, _InputIterator __last,
                		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
                		   _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  {
                	    *__out_true = *__first;
                	    ++__out_true;
                	  }
                	else
                	  {
                	    *__out_false = *__first;
                	    ++__out_false;
                	  }
                
                      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
                    }
                #endif // C++11
                
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
                		_Predicate __pred)
                    {
                      __first = std::__find_if(__first, __last, __pred);
                      if (__first == __last)
                	return __first;
                      _ForwardIterator __result = __first;
                      ++__first;
                      for (; __first != __last; ++__first)
                	if (!__pred(__first))
                	  {
                	    *__result = _GLIBCXX_MOVE(*__first);
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Remove elements from a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __value  The value to be removed.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  All elements equal to @p __value are removed from the range
                   *  @p [__first,__last).
                   *
                   *  remove() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    remove(_ForwardIterator __first, _ForwardIterator __last,
                	   const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_if(__first, __last,
                		__gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Remove elements from a sequence using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __pred   A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  All elements for which @p __pred returns true are removed from the range
                   *  @p [__first,__last).
                   *
                   *  remove_if() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    remove_if(_ForwardIterator __first, _ForwardIterator __last,
                	      _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_if(__first, __last,
                			      __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                		    _BinaryPredicate __binary_pred)
                    {
                      if (__first == __last)
                	return __last;
                      _ForwardIterator __next = __first;
                      while (++__next != __last)
                	{
                	  if (__binary_pred(__first, __next))
                	    return __first;
                	  __first = __next;
                	}
                      return __last;
                    }
                
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __unique(_ForwardIterator __first, _ForwardIterator __last,
                	     _BinaryPredicate __binary_pred)
                    {
                      // Skip the beginning, if already unique.
                      __first = std::__adjacent_find(__first, __last, __binary_pred);
                      if (__first == __last)
                	return __last;
                
                      // Do the real copy work.
                      _ForwardIterator __dest = __first;
                      ++__first;
                      while (++__first != __last)
                	if (!__binary_pred(__dest, __first))
                	  *++__dest = _GLIBCXX_MOVE(*__first);
                      return ++__dest;
                    }
                
                  /**
                   *  @brief Remove consecutive duplicate values from a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Removes all but the first element from each group of consecutive
                   *  values that compare equal.
                   *  unique() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    unique(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                		     typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__unique(__first, __last,
                			   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Remove consecutive values from a sequence using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Removes all but the first element from each group of consecutive
                   *  values for which @p __binary_pred returns true.
                   *  unique() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    unique(_ForwardIterator __first, _ForwardIterator __last,
                	   _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                		typename iterator_traits<_ForwardIterator>::value_type,
                		typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__unique(__first, __last,
                			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for forward iterators and output iterator as result.
                  */
                  template<typename _ForwardIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                		  forward_iterator_tag, output_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_ForwardIterator>::value_type,
                	  typename iterator_traits<_ForwardIterator>::value_type>)
                
                      _ForwardIterator __next = __first;
                      *__result = *__first;
                      while (++__next != __last)
                	if (!__binary_pred(__first, __next))
                	  {
                	    __first = __next;
                	    *++__result = *__first;
                	  }
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for input iterators and output iterator as result.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __unique_copy(_InputIterator __first, _InputIterator __last,
                		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                		  input_iterator_tag, output_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_InputIterator>::value_type,
                	  typename iterator_traits<_InputIterator>::value_type>)
                
                      typename iterator_traits<_InputIterator>::value_type __value = *__first;
                      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
                	__rebound_pred
                	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
                      *__result = __value;
                      while (++__first != __last)
                	if (!__rebound_pred(__first, __value))
                	  {
                	    __value = *__first;
                	    *++__result = __value;
                	  }
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for input iterators and forward iterator as result.
                  */
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __unique_copy(_InputIterator __first, _InputIterator __last,
                		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
                		  input_iterator_tag, forward_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_ForwardIterator>::value_type,
                	  typename iterator_traits<_InputIterator>::value_type>)
                      *__result = *__first;
                      while (++__first != __last)
                	if (!__binary_pred(__result, __first))
                	  *++__result = *__first;
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified reverse(_BidirectionalIterator,
                   *                              _BidirectionalIterator)
                   *  overloaded for bidirectional iterators.
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
                	      bidirectional_iterator_tag)
                    {
                      while (true)
                	if (__first == __last || __first == --__last)
                	  return;
                	else
                	  {
                	    std::iter_swap(__first, __last);
                	    ++__first;
                	  }
                    }
                
                  /**
                   *  This is an uglified reverse(_BidirectionalIterator,
                   *                              _BidirectionalIterator)
                   *  overloaded for random access iterators.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	      random_access_iterator_tag)
                    {
                      if (__first == __last)
                	return;
                      --__last;
                      while (__first < __last)
                	{
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	  --__last;
                	}
                    }
                
                  /**
                   *  @brief Reverse a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @return   reverse() returns no value.
                   *
                   *  Reverses the order of the elements in the range @p [__first,__last),
                   *  so that the first element becomes the last etc.
                   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
                   *  swaps @p *(__first+i) and @p *(__last-(i+1))
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                      std::__reverse(__first, __last, std::__iterator_category(__first));
                    }
                
                  /**
                   *  @brief Copy a sequence, reversing its elements.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A bidirectional iterator.
                   *  @param  __last    A bidirectional iterator.
                   *  @param  __result  An output iterator.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Copies the elements in the range @p [__first,__last) to the
                   *  range @p [__result,__result+(__last-__first)) such that the
                   *  order of the elements is reversed.  For every @c i such that @p
                   *  0<=i<=(__last-__first), @p reverse_copy() performs the
                   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
                   *  The ranges @p [__first,__last) and @p
                   *  [__result,__result+(__last-__first)) must not overlap.
                  */
                  template<typename _BidirectionalIterator, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
                		 _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                		typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      while (__first != __last)
                	{
                	  --__last;
                	  *__result = *__last;
                	  ++__result;
                	}
                      return __result;
                    }
                
                  /**
                   *  This is a helper function for the rotate algorithm specialized on RAIs.
                   *  It returns the greatest common divisor of two integer values.
                  */
                  template<typename _EuclideanRingElement>
                    _GLIBCXX20_CONSTEXPR
                    _EuclideanRingElement
                    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
                    {
                      while (__n != 0)
                	{
                	  _EuclideanRingElement __t = __m % __n;
                	  __m = __n;
                	  __n = __t;
                	}
                      return __m;
                    }
                
                  inline namespace _V2
                  {
                
                  /// This is a helper function for the rotate algorithm.
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __rotate(_ForwardIterator __first,
                	     _ForwardIterator __middle,
                	     _ForwardIterator __last,
                	     forward_iterator_tag)
                    {
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      _ForwardIterator __first2 = __middle;
                      do
                	{
                	  std::iter_swap(__first, __first2);
                	  ++__first;
                	  ++__first2;
                	  if (__first == __middle)
                	    __middle = __first2;
                	}
                      while (__first2 != __last);
                
                      _ForwardIterator __ret = __first;
                
                      __first2 = __middle;
                
                      while (__first2 != __last)
                	{
                	  std::iter_swap(__first, __first2);
                	  ++__first;
                	  ++__first2;
                	  if (__first == __middle)
                	    __middle = __first2;
                	  else if (__first2 == __last)
                	    __first2 = __middle;
                	}
                      return __ret;
                    }
                
                   /// This is a helper function for the rotate algorithm.
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    _BidirectionalIterator
                    __rotate(_BidirectionalIterator __first,
                	     _BidirectionalIterator __middle,
                	     _BidirectionalIterator __last,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                      std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                
                      while (__first != __middle && __middle != __last)
                	{
                	  std::iter_swap(__first, --__last);
                	  ++__first;
                	}
                
                      if (__first == __middle)
                	{
                	  std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                	  return __last;
                	}
                      else
                	{
                	  std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                	  return __first;
                	}
                    }
                
                  /// This is a helper function for the rotate algorithm.
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
                    __rotate(_RandomAccessIterator __first,
                	     _RandomAccessIterator __middle,
                	     _RandomAccessIterator __last,
                	     random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_Distance;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_ValueType;
                
                      _Distance __n = __last   - __first;
                      _Distance __k = __middle - __first;
                
                      if (__k == __n - __k)
                	{
                	  std::swap_ranges(__first, __middle, __middle);
                	  return __middle;
                	}
                
                      _RandomAccessIterator __p = __first;
                      _RandomAccessIterator __ret = __first + (__last - __middle);
                
                      for (;;)
                	{
                	  if (__k < __n - __k)
                	    {
                	      if (__is_pod(_ValueType) && __k == 1)
                		{
                		  _ValueType __t = _GLIBCXX_MOVE(*__p);
                		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
                		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
                		  return __ret;
                		}
                	      _RandomAccessIterator __q = __p + __k;
                	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                		{
                		  std::iter_swap(__p, __q);
                		  ++__p;
                		  ++__q;
                		}
                	      __n %= __k;
                	      if (__n == 0)
                		return __ret;
                	      std::swap(__n, __k);
                	      __k = __n - __k;
                	    }
                	  else
                	    {
                	      __k = __n - __k;
                	      if (__is_pod(_ValueType) && __k == 1)
                		{
                		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
                		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
                		  *__p = _GLIBCXX_MOVE(__t);
                		  return __ret;
                		}
                	      _RandomAccessIterator __q = __p + __n;
                	      __p = __q - __k;
                	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                		{
                		  --__p;
                		  --__q;
                		  std::iter_swap(__p, __q);
                		}
                	      __n %= __k;
                	      if (__n == 0)
                		return __ret;
                	      std::swap(__n, __k);
                	    }
                	}
                    }
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 488. rotate throws away useful information
                  /**
                   *  @brief Rotate the elements of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __middle  A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @return  first + (last - middle).
                   *
                   *  Rotates the elements of the range @p [__first,__last) by 
                   *  @p (__middle - __first) positions so that the element at @p __middle
                   *  is moved to @p __first, the element at @p __middle+1 is moved to
                   *  @p __first+1 and so on for each element in the range
                   *  @p [__first,__last).
                   *
                   *  This effectively swaps the ranges @p [__first,__middle) and
                   *  @p [__middle,__last).
                   *
                   *  Performs
                   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                   *  for each @p n in the range @p [0,__last-__first).
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    rotate(_ForwardIterator __first, _ForwardIterator __middle,
                	   _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                
                      return std::__rotate(__first, __middle, __last,
                			   std::__iterator_category(__first));
                    }
                
                  } // namespace _V2
                
                  /**
                   *  @brief Copy a sequence, rotating its elements.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __middle  A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __result  An output iterator.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies the elements of the range @p [__first,__last) to the
                   *  range beginning at @result, rotating the copied elements by 
                   *  @p (__middle-__first) positions so that the element at @p __middle
                   *  is moved to @p __result, the element at @p __middle+1 is moved
                   *  to @p __result+1 and so on for each element in the range @p
                   *  [__first,__last).
                   *
                   *  Performs 
                   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                   *  for each @p n in the range @p [0,__last-__first).
                  */
                  template<typename _ForwardIterator, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                		_ForwardIterator __last, _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                		typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                
                      return std::copy(__first, __middle,
                		       std::copy(__middle, __last, __result));
                    }
                
                  /// This is a helper function...
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __partition(_ForwardIterator __first, _ForwardIterator __last,
                		_Predicate __pred, forward_iterator_tag)
                    {
                      if (__first == __last)
                	return __first;
                
                      while (__pred(*__first))
                	if (++__first == __last)
                	  return __first;
                
                      _ForwardIterator __next = __first;
                
                      while (++__next != __last)
                	if (__pred(*__next))
                	  {
                	    std::iter_swap(__first, __next);
                	    ++__first;
                	  }
                
                      return __first;
                    }
                
                  /// This is a helper function...
                  template<typename _BidirectionalIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _BidirectionalIterator
                    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
                		_Predicate __pred, bidirectional_iterator_tag)
                    {
                      while (true)
                	{
                	  while (true)
                	    if (__first == __last)
                	      return __first;
                	    else if (__pred(*__first))
                	      ++__first;
                	    else
                	      break;
                	  --__last;
                	  while (true)
                	    if (__first == __last)
                	      return __first;
                	    else if (!bool(__pred(*__last)))
                	      --__last;
                	    else
                	      break;
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	}
                    }
                
                  // partition
                
                  /// This is a helper function...
                  /// Requires __first != __last and !__pred(__first)
                  /// and __len == distance(__first, __last).
                  ///
                  /// !__pred(__first) allows us to guarantee that we don't
                  /// move-assign an element onto itself.
                  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
                	   typename _Distance>
                    _ForwardIterator
                    __stable_partition_adaptive(_ForwardIterator __first,
                				_ForwardIterator __last,
                				_Predicate __pred, _Distance __len,
                				_Pointer __buffer,
                				_Distance __buffer_size)
                    {
                      if (__len == 1)
                	return __first;
                
                      if (__len <= __buffer_size)
                	{
                	  _ForwardIterator __result1 = __first;
                	  _Pointer __result2 = __buffer;
                
                	  // The precondition guarantees that !__pred(__first), so
                	  // move that element to the buffer before starting the loop.
                	  // This ensures that we only call __pred once per element.
                	  *__result2 = _GLIBCXX_MOVE(*__first);
                	  ++__result2;
                	  ++__first;
                	  for (; __first != __last; ++__first)
                	    if (__pred(__first))
                	      {
                		*__result1 = _GLIBCXX_MOVE(*__first);
                		++__result1;
                	      }
                	    else
                	      {
                		*__result2 = _GLIBCXX_MOVE(*__first);
                		++__result2;
                	      }
                
                	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
                	  return __result1;
                	}
                
                      _ForwardIterator __middle = __first;
                      std::advance(__middle, __len / 2);
                      _ForwardIterator __left_split =
                	std::__stable_partition_adaptive(__first, __middle, __pred,
                					 __len / 2, __buffer,
                					 __buffer_size);
                
                      // Advance past true-predicate values to satisfy this
                      // function's preconditions.
                      _Distance __right_len = __len - __len / 2;
                      _ForwardIterator __right_split =
                	std::__find_if_not_n(__middle, __right_len, __pred);
                
                      if (__right_len)
                	__right_split =
                	  std::__stable_partition_adaptive(__right_split, __last, __pred,
                					   __right_len,
                					   __buffer, __buffer_size);
                
                      return std::rotate(__left_split, __middle, __right_split);
                    }
                
                  template<typename _ForwardIterator, typename _Predicate>
                    _ForwardIterator
                    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                		       _Predicate __pred)
                    {
                      __first = std::__find_if_not(__first, __last, __pred);
                
                      if (__first == __last)
                	return __first;
                
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _Temporary_buffer<_ForwardIterator, _ValueType>
                	__buf(__first, std::distance(__first, __last));
                      return
                	std::__stable_partition_adaptive(__first, __last, __pred,
                					 _DistanceType(__buf.requested_size()),
                					 __buf.begin(),
                					 _DistanceType(__buf.size()));
                    }
                
                  /**
                   *  @brief Move elements for which a predicate is true to the beginning
                   *         of a sequence, preserving relative ordering.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __pred    A predicate functor.
                   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                   *  iterator @p i in the range @p [first,middle) and false for each @p i
                   *  in the range @p [middle,last).
                   *
                   *  Performs the same function as @p partition() with the additional
                   *  guarantee that the relative ordering of elements in each group is
                   *  preserved, so any two elements @p x and @p y in the range
                   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
                   *  relative ordering after calling @p stable_partition().
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    inline _ForwardIterator
                    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                		     _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__stable_partition(__first, __last,
                				     __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /// This is a helper function for the sort routines.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
       ##### ->     __heap_select(_RandomAccessIterator __first,
                		  _RandomAccessIterator __middle,
                		  _RandomAccessIterator __last, _Compare __comp)
                    {
                      std::__make_heap(__first, __middle, __comp);
                      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
                	if (__comp(__i, __first))
                	  std::__pop_heap(__first, __middle, __i, __comp);
                    }
                
                  // partial_sort
                
                  template<typename _InputIterator, typename _RandomAccessIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
                    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
                			_RandomAccessIterator __result_first,
                			_RandomAccessIterator __result_last,
                			_Compare __comp)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
                      typedef typename _RItTraits::difference_type _DistanceType;
                
                      if (__result_first == __result_last)
                	return __result_last;
                      _RandomAccessIterator __result_real_last = __result_first;
                      while (__first != __last && __result_real_last != __result_last)
                	{
                	  *__result_real_last = *__first;
                	  ++__result_real_last;
                	  ++__first;
                	}
                      
                      std::__make_heap(__result_first, __result_real_last, __comp);
                      while (__first != __last)
                	{
                	  if (__comp(__first, __result_first))
                	    std::__adjust_heap(__result_first, _DistanceType(0),
                			       _DistanceType(__result_real_last
                					     - __result_first),
                			       _InputValueType(*__first), __comp);
                	  ++__first;
                	}
                      std::__sort_heap(__result_first, __result_real_last, __comp);
                      return __result_real_last;
                    }
                
                  /**
                   *  @brief Copy the smallest elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __result_first   A random-access iterator.
                   *  @param  __result_last    Another random-access iterator.
                   *  @return   An iterator indicating the end of the resulting sequence.
                   *
                   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                   *  to the range beginning at @p __result_first, where the number of
                   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                   *  @p (__result_last-__result_first).
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__result_first,__result_first+N) such that i precedes j then
                   *  *j<*i is false.
                   *  The value returned is @p __result_first+N.
                  */
                  template<typename _InputIterator, typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _RandomAccessIterator
                    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                		      _RandomAccessIterator __result_first,
                		      _RandomAccessIterator __result_last)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_OutputValueType;
                #endif
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                				  _OutputValueType>)
                      __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
                						     _OutputValueType>)
                      __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                      __glibcxx_requires_valid_range(__result_first, __result_last);
                
                      return std::__partial_sort_copy(__first, __last,
                				      __result_first, __result_last,
                				      __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Copy the smallest elements of a sequence using a predicate for
                   *         comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    Another input iterator.
                   *  @param  __result_first   A random-access iterator.
                   *  @param  __result_last    Another random-access iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return   An iterator indicating the end of the resulting sequence.
                   *
                   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                   *  to the range beginning at @p result_first, where the number of
                   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                   *  @p (__result_last-__result_first).
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__result_first,__result_first+N) such that i precedes j then
                   *  @p __comp(*j,*i) is false.
                   *  The value returned is @p __result_first+N.
                  */
                  template<typename _InputIterator, typename _RandomAccessIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _RandomAccessIterator
                    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                		      _RandomAccessIterator __result_first,
                		      _RandomAccessIterator __result_last,
                		      _Compare __comp)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_OutputValueType;
                #endif
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                				  _OutputValueType>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                				  _InputValueType, _OutputValueType>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                				  _OutputValueType, _OutputValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                      __glibcxx_requires_valid_range(__result_first, __result_last);
                
                      return std::__partial_sort_copy(__first, __last,
                				      __result_first, __result_last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
      299082 ->     __unguarded_linear_insert(_RandomAccessIterator __last,
                			      _Compare __comp)
                    {
                      typename iterator_traits<_RandomAccessIterator>::value_type
                	__val = _GLIBCXX_MOVE(*__last);
                      _RandomAccessIterator __next = __last;
                      --__next;
                      while (__comp(__val, __next))
                	{
                	  *__last = _GLIBCXX_MOVE(*__next);
                	  __last = __next;
                	  --__next;
                	}
                      *__last = _GLIBCXX_MOVE(__val);
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
         300 ->     __insertion_sort(_RandomAccessIterator __first,
                		     _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__first == __last) return;
                
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	{
                	  if (__comp(__i, __first))
                	    {
                	      typename iterator_traits<_RandomAccessIterator>::value_type
                		__val = _GLIBCXX_MOVE(*__i);
                	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
                	      *__first = _GLIBCXX_MOVE(__val);
                	    }
                	  else
                	    std::__unguarded_linear_insert(__i,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                	}
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
         300 ->     __unguarded_insertion_sort(_RandomAccessIterator __first,
                			       _RandomAccessIterator __last, _Compare __comp)
                    {
                      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
                	std::__unguarded_linear_insert(__i,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  /**
                   *  @doctodo
                   *  This controls some aspect of the sort routines.
                  */
                  enum { _S_threshold = 16 };
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
         300 ->     __final_insertion_sort(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__last - __first > int(_S_threshold))
                	{
                	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
                	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
                					  __comp);
                	}
                      else
                	std::__insertion_sort(__first, __last, __comp);
                    }
                
                  /// This is a helper function...
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
       30407 ->     __unguarded_partition(_RandomAccessIterator __first,
                			  _RandomAccessIterator __last,
                			  _RandomAccessIterator __pivot, _Compare __comp)
                    {
                      while (true)
                	{
                	  while (__comp(__first, __pivot))
                	    ++__first;
                	  --__last;
                	  while (__comp(__pivot, __last))
                	    --__last;
                	  if (!(__first < __last))
                	    return __first;
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	}
                    }
                
                  /// This is a helper function...
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _RandomAccessIterator
       30407 ->     __unguarded_partition_pivot(_RandomAccessIterator __first,
                				_RandomAccessIterator __last, _Compare __comp)
                    {
                      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
                      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                				  __comp);
                      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
                    }
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
       ##### ->     __partial_sort(_RandomAccessIterator __first,
                		   _RandomAccessIterator __middle,
                		   _RandomAccessIterator __last,
                		   _Compare __comp)
                    {
                      std::__heap_select(__first, __middle, __last, __comp);
                      std::__sort_heap(__first, __middle, __comp);
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
         300 ->     __introsort_loop(_RandomAccessIterator __first,
                		     _RandomAccessIterator __last,
                		     _Size __depth_limit, _Compare __comp)
                    {
                      while (__last - __first > int(_S_threshold))
                	{
                	  if (__depth_limit == 0)
                	    {
                	      std::__partial_sort(__first, __last, __last, __comp);
                	      return;
                	    }
                	  --__depth_limit;
                	  _RandomAccessIterator __cut =
                	    std::__unguarded_partition_pivot(__first, __last, __comp);
                	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
                	  __last = __cut;
                	}
                    }
                
                  // sort
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
         300 ->     __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	   _Compare __comp)
                    {
                      if (__first != __last)
                	{
                	  std::__introsort_loop(__first, __last,
                				std::__lg(__last - __first) * 2,
                				__comp);
                	  std::__final_insertion_sort(__first, __last, __comp);
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		  _RandomAccessIterator __last, _Size __depth_limit,
                		  _Compare __comp)
                    {
                      while (__last - __first > 3)
                	{
                	  if (__depth_limit == 0)
                	    {
                	      std::__heap_select(__first, __nth + 1, __last, __comp);
                	      // Place the nth largest element in its final position.
                	      std::iter_swap(__first, __nth);
                	      return;
                	    }
                	  --__depth_limit;
                	  _RandomAccessIterator __cut =
                	    std::__unguarded_partition_pivot(__first, __last, __comp);
                	  if (__cut <= __nth)
                	    __first = __cut;
                	  else
                	    __last = __cut;
                	}
                      std::__insertion_sort(__first, __last, __comp);
                    }
                
                  // nth_element
                
                  // lower_bound moved to stl_algobase.h
                
                  /**
                   *  @brief Finds the first position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return An iterator pointing to the first element <em>not less
                   *           than</em> @p __val, or end() if every element is less
                   *           than @p __val.
                   *  @ingroup binary_search_algorithms
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_comp_val(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__val, __middle))
                	    __len = __half;
                	  else
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the last position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return  An iterator pointing to the first element greater than @p __val,
                   *           or end() if no elements are greater than @p __val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      return std::__upper_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__val_less_iter());
                    }
                
                  /**
                   *  @brief Finds the last position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  An iterator pointing to the first element greater than @p __val,
                   *           or end() if no elements are greater than @p __val.
                   *  @ingroup binary_search_algorithms
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      return std::__upper_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Tp,
                	   typename _CompareItTp, typename _CompareTpIt>
                    _GLIBCXX20_CONSTEXPR
                    pair<_ForwardIterator, _ForwardIterator>
                    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val,
                		  _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp_it_val(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else if (__comp_val_it(__val, __middle))
                	    __len = __half;
                	  else
                	    {
                	      _ForwardIterator __left
                		= std::__lower_bound(__first, __middle, __val, __comp_it_val);
                	      std::advance(__first, __len);
                	      _ForwardIterator __right
                		= std::__upper_bound(++__middle, __first, __val, __comp_val_it);
                	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
                	    }
                	}
                      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
                    }
                
                  /**
                   *  @brief Finds the largest subrange in which @p __val could be inserted
                   *         at any place in it without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return  An pair of iterators defining the subrange.
                   *  @ingroup binary_search_algorithms
                   *
                   *  This is equivalent to
                   *  @code
                   *    std::make_pair(lower_bound(__first, __last, __val),
                   *                   upper_bound(__first, __last, __val))
                   *  @endcode
                   *  but does not actually call those functions.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      return std::__equal_range(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val(),
                				__gnu_cxx::__ops::__val_less_iter());
                    }
                
                  /**
                   *  @brief Finds the largest subrange in which @p __val could be inserted
                   *         at any place in it without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  An pair of iterators defining the subrange.
                   *  @ingroup binary_search_algorithms
                   *
                   *  This is equivalent to
                   *  @code
                   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
                   *                   upper_bound(__first, __last, __val, __comp))
                   *  @endcode
                   *  but does not actually call those functions.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      return std::__equal_range(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_comp_val(__comp),
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Determines whether an element exists in a range.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return True if @p __val (or its equivalent) is in [@p
                   *  __first,@p __last ].
                   *
                   *  Note that this does not actually return an iterator to @p __val.  For
                   *  that, use std::find or a container's specialized find member functions.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      _ForwardIterator __i
                	= std::__lower_bound(__first, __last, __val,
                			     __gnu_cxx::__ops::__iter_less_val());
                      return __i != __last && !(__val < *__i);
                    }
                
                  /**
                   *  @brief Determines whether an element exists in a range.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
                   *
                   *  Note that this does not actually return an iterator to @p __val.  For
                   *  that, use std::find or a container's specialized find member functions.
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      _ForwardIterator __i
                	= std::__lower_bound(__first, __last, __val,
                			     __gnu_cxx::__ops::__iter_comp_val(__comp));
                      return __i != __last && !bool(__comp(__val, *__i));
                    }
                
                  // merge
                
                  /// This is a helper function for the __merge_adaptive routines.
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    void
                    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
                			  _InputIterator2 __first2, _InputIterator2 __last2,
                			  _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first2);
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first1);
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      if (__first1 != __last1)
                	_GLIBCXX_MOVE3(__first1, __last1, __result);
                    }
                
                  /// This is a helper function for the __merge_adaptive routines.
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _BidirectionalIterator3, typename _Compare>
                    void
                    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
                				   _BidirectionalIterator1 __last1,
                				   _BidirectionalIterator2 __first2,
                				   _BidirectionalIterator2 __last2,
                				   _BidirectionalIterator3 __result,
                				   _Compare __comp)
                    {
                      if (__first1 == __last1)
                	{
                	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
                	  return;
                	}
                      else if (__first2 == __last2)
                	return;
                
                      --__last1;
                      --__last2;
                      while (true)
                	{
                	  if (__comp(__last2, __last1))
                	    {
                	      *--__result = _GLIBCXX_MOVE(*__last1);
                	      if (__first1 == __last1)
                		{
                		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
                		  return;
                		}
                	      --__last1;
                	    }
                	  else
                	    {
                	      *--__result = _GLIBCXX_MOVE(*__last2);
                	      if (__first2 == __last2)
                		return;
                	      --__last2;
                	    }
                	}
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _Distance>
                    _BidirectionalIterator1
                    __rotate_adaptive(_BidirectionalIterator1 __first,
                		      _BidirectionalIterator1 __middle,
                		      _BidirectionalIterator1 __last,
                		      _Distance __len1, _Distance __len2,
                		      _BidirectionalIterator2 __buffer,
                		      _Distance __buffer_size)
                    {
                      _BidirectionalIterator2 __buffer_end;
                      if (__len1 > __len2 && __len2 <= __buffer_size)
                	{
                	  if (__len2)
                	    {
                	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
                	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
                	    }
                	  else
                	    return __first;
                	}
                      else if (__len1 <= __buffer_size)
                	{
                	  if (__len1)
                	    {
                	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                	      _GLIBCXX_MOVE3(__middle, __last, __first);
                	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
                	    }
                	  else
                	    return __last;
                	}
                      else
                	return std::rotate(__first, __middle, __last);
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator, typename _Distance, 
                	   typename _Pointer, typename _Compare>
                    void
                    __merge_adaptive(_BidirectionalIterator __first,
                		     _BidirectionalIterator __middle,
                		     _BidirectionalIterator __last,
                		     _Distance __len1, _Distance __len2,
                		     _Pointer __buffer, _Distance __buffer_size,
                		     _Compare __comp)
                    {
                      if (__len1 <= __len2 && __len1 <= __buffer_size)
                	{
                	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
                				     __first, __comp);
                	}
                      else if (__len2 <= __buffer_size)
                	{
                	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
                					      __buffer_end, __last, __comp);
                	}
                      else
                	{
                	  _BidirectionalIterator __first_cut = __first;
                	  _BidirectionalIterator __second_cut = __middle;
                	  _Distance __len11 = 0;
                	  _Distance __len22 = 0;
                	  if (__len1 > __len2)
                	    {
                	      __len11 = __len1 / 2;
                	      std::advance(__first_cut, __len11);
                	      __second_cut
                		= std::__lower_bound(__middle, __last, *__first_cut,
                				     __gnu_cxx::__ops::__iter_comp_val(__comp));
                	      __len22 = std::distance(__middle, __second_cut);
                	    }
                	  else
                	    {
                	      __len22 = __len2 / 2;
                	      std::advance(__second_cut, __len22);
                	      __first_cut
                		= std::__upper_bound(__first, __middle, *__second_cut,
                				     __gnu_cxx::__ops::__val_comp_iter(__comp));
                	      __len11 = std::distance(__first, __first_cut);
                	    }
                
                	  _BidirectionalIterator __new_middle
                	    = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
                				     __len1 - __len11, __len22, __buffer,
                				     __buffer_size);
                	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
                				__len22, __buffer, __buffer_size, __comp);
                	  std::__merge_adaptive(__new_middle, __second_cut, __last,
                				__len1 - __len11,
                				__len2 - __len22, __buffer,
                				__buffer_size, __comp);
                	}
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator, typename _Distance,
                	   typename _Compare>
                    void
                    __merge_without_buffer(_BidirectionalIterator __first,
                			   _BidirectionalIterator __middle,
                			   _BidirectionalIterator __last,
                			   _Distance __len1, _Distance __len2,
                			   _Compare __comp)
                    {
                      if (__len1 == 0 || __len2 == 0)
                	return;
                
                      if (__len1 + __len2 == 2)
                	{
                	  if (__comp(__middle, __first))
                	    std::iter_swap(__first, __middle);
                	  return;
                	}
                
                      _BidirectionalIterator __first_cut = __first;
                      _BidirectionalIterator __second_cut = __middle;
                      _Distance __len11 = 0;
                      _Distance __len22 = 0;
                      if (__len1 > __len2)
                	{
                	  __len11 = __len1 / 2;
                	  std::advance(__first_cut, __len11);
                	  __second_cut
                	    = std::__lower_bound(__middle, __last, *__first_cut,
                				 __gnu_cxx::__ops::__iter_comp_val(__comp));
                	  __len22 = std::distance(__middle, __second_cut);
                	}
                      else
                	{
                	  __len22 = __len2 / 2;
                	  std::advance(__second_cut, __len22);
                	  __first_cut
                	    = std::__upper_bound(__first, __middle, *__second_cut,
                				 __gnu_cxx::__ops::__val_comp_iter(__comp));
                	  __len11 = std::distance(__first, __first_cut);
                	}
                
                      _BidirectionalIterator __new_middle
                	= std::rotate(__first_cut, __middle, __second_cut);
                      std::__merge_without_buffer(__first, __first_cut, __new_middle,
                				  __len11, __len22, __comp);
                      std::__merge_without_buffer(__new_middle, __second_cut, __last,
                				  __len1 - __len11, __len2 - __len22, __comp);
                    }
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    void
                    __inplace_merge(_BidirectionalIterator __first,
                		    _BidirectionalIterator __middle,
                		    _BidirectionalIterator __last,
                		    _Compare __comp)
                    {
                      typedef typename iterator_traits<_BidirectionalIterator>::value_type
                	  _ValueType;
                      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
                	  _DistanceType;
                      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
                
                      if (__first == __middle || __middle == __last)
                	return;
                
                      const _DistanceType __len1 = std::distance(__first, __middle);
                      const _DistanceType __len2 = std::distance(__middle, __last);
                
                      // __merge_adaptive will use a buffer for the smaller of
                      // [first,middle) and [middle,last).
                      _TmpBuf __buf(__first, std::min(__len1, __len2));
                
                      if (__buf.begin() == 0)
                	std::__merge_without_buffer
                	  (__first, __middle, __last, __len1, __len2, __comp);
                      else
                	std::__merge_adaptive
                	  (__first, __middle, __last, __len1, __len2, __buf.begin(),
                	   _DistanceType(__buf.size()), __comp);
                    }
                
                  /**
                   *  @brief Merges two sorted ranges in place.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                   *  [__middle,__last), and puts the result in [__first,__last).  The
                   *  output will be sorted.  The sort is @e stable, that is, for
                   *  equivalent elements in the two ranges, elements from the first
                   *  range will always come before elements from the second.
                   *
                   *  If enough additional memory is available, this takes (__last-__first)-1
                   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                   *  distance(__first,__last).
                  */
                  template<typename _BidirectionalIterator>
                    inline void
                    inplace_merge(_BidirectionalIterator __first,
                		  _BidirectionalIterator __middle,
                		  _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                	    _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_sorted(__first, __middle);
                      __glibcxx_requires_sorted(__middle, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__inplace_merge(__first, __middle, __last,
                			   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Merges two sorted ranges in place.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  Nothing.
                   *
                   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                   *  [middle,last), and puts the result in [__first,__last).  The output will
                   *  be sorted.  The sort is @e stable, that is, for equivalent
                   *  elements in the two ranges, elements from the first range will always
                   *  come before elements from the second.
                   *
                   *  If enough additional memory is available, this takes (__last-__first)-1
                   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                   *  distance(__first,__last).
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    inline void
                    inplace_merge(_BidirectionalIterator __first,
                		  _BidirectionalIterator __middle,
                		  _BidirectionalIterator __last,
                		  _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                	    _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_sorted_pred(__first, __middle, __comp);
                      __glibcxx_requires_sorted_pred(__middle, __last, __comp);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__inplace_merge(__first, __middle, __last,
                			   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                
                  /// This is a helper function for the __merge_sort_loop routines.
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __move_merge(_InputIterator __first1, _InputIterator __last1,
                		 _InputIterator __first2, _InputIterator __last2,
                		 _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first2);
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first1);
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      return _GLIBCXX_MOVE3(__first2, __last2,
                			    _GLIBCXX_MOVE3(__first1, __last1,
                					   __result));
                    }
                
                  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
                	   typename _Distance, typename _Compare>
                    void
                    __merge_sort_loop(_RandomAccessIterator1 __first,
                		      _RandomAccessIterator1 __last,
                		      _RandomAccessIterator2 __result, _Distance __step_size,
                		      _Compare __comp)
                    {
                      const _Distance __two_step = 2 * __step_size;
                
                      while (__last - __first >= __two_step)
                	{
                	  __result = std::__move_merge(__first, __first + __step_size,
                				       __first + __step_size,
                				       __first + __two_step,
                				       __result, __comp);
                	  __first += __two_step;
                	}
                      __step_size = std::min(_Distance(__last - __first), __step_size);
                
                      std::__move_merge(__first, __first + __step_size,
                			__first + __step_size, __last, __result, __comp);
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __chunk_insertion_sort(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last,
                			   _Distance __chunk_size, _Compare __comp)
                    {
                      while (__last - __first >= __chunk_size)
                	{
                	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
                	  __first += __chunk_size;
                	}
                      std::__insertion_sort(__first, __last, __comp);
                    }
                
                  enum { _S_chunk_size = 7 };
                
                  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
                    void
                    __merge_sort_with_buffer(_RandomAccessIterator __first,
                			     _RandomAccessIterator __last,
                			     _Pointer __buffer, _Compare __comp)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_Distance;
                
                      const _Distance __len = __last - __first;
                      const _Pointer __buffer_last = __buffer + __len;
                
                      _Distance __step_size = _S_chunk_size;
                      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
                
                      while (__step_size < __len)
                	{
                	  std::__merge_sort_loop(__first, __last, __buffer,
                				 __step_size, __comp);
                	  __step_size *= 2;
                	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
                				 __step_size, __comp);
                	  __step_size *= 2;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Pointer,
                	   typename _Distance, typename _Compare>
                    void
                    __stable_sort_adaptive(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last,
                			   _Pointer __buffer, _Distance __buffer_size,
                			   _Compare __comp)
                    {
                      const _Distance __len = (__last - __first + 1) / 2;
                      const _RandomAccessIterator __middle = __first + __len;
                      if (__len > __buffer_size)
                	{
                	  std::__stable_sort_adaptive(__first, __middle, __buffer,
                				      __buffer_size, __comp);
                	  std::__stable_sort_adaptive(__middle, __last, __buffer,
                				      __buffer_size, __comp);
                	}
                      else
                	{
                	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
                	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
                	}
                
                      std::__merge_adaptive(__first, __middle, __last,
                			    _Distance(__middle - __first),
                			    _Distance(__last - __middle),
                			    __buffer, __buffer_size,
                			    __comp);
                    }
                
                  /// This is a helper function for the stable sorting routines.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
                    __inplace_stable_sort(_RandomAccessIterator __first,
                			  _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__last - __first < 15)
                	{
                	  std::__insertion_sort(__first, __last, __comp);
                	  return;
                	}
                      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
                      std::__inplace_stable_sort(__first, __middle, __comp);
                      std::__inplace_stable_sort(__middle, __last, __comp);
                      std::__merge_without_buffer(__first, __middle, __last,
                				  __middle - __first,
                				  __last - __middle,
                				  __comp);
                    }
                
                  // stable_sort
                
                  // Set algorithms: includes, set_union, set_intersection, set_difference,
                  // set_symmetric_difference.  All of these algorithms have the precondition
                  // that their input ranges are sorted and the postcondition that their output
                  // ranges are sorted.
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    return false;
                	  if (!__comp(__first1, __first2))
                	    ++__first2;
                	  ++__first1;
                	}
                
                      return __first2 == __last2;
                    }
                
                  /**
                   *  @brief Determines whether all elements of a sequence exists in a range.
                   *  @param  __first1  Start of search range.
                   *  @param  __last1   End of search range.
                   *  @param  __first2  Start of sequence
                   *  @param  __last2   End of sequence.
                   *  @return  True if each element in [__first2,__last2) is contained in order
                   *  within [__first1,__last1).  False otherwise.
                   *  @ingroup set_algorithms
                   *
                   *  This operation expects both [__first1,__last1) and
                   *  [__first2,__last2) to be sorted.  Searches for the presence of
                   *  each element in [__first2,__last2) within [__first1,__last1).
                   *  The iterators over each range only move forward, so this is a
                   *  linear algorithm.  If an element in [__first2,__last2) is not
                   *  found before the search iterator reaches @p __last2, false is
                   *  returned.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return std::__includes(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Determines whether all elements of a sequence exists in a range
                   *  using comparison.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of search range.
                   *  @param  __last1   End of search range.
                   *  @param  __first2  Start of sequence
                   *  @param  __last2   End of sequence.
                   *  @param  __comp    Comparison function to use.
                   *  @return True if each element in [__first2,__last2) is contained
                   *  in order within [__first1,__last1) according to comp.  False
                   *  otherwise.  @ingroup set_algorithms
                   *
                   *  This operation expects both [__first1,__last1) and
                   *  [__first2,__last2) to be sorted.  Searches for the presence of
                   *  each element in [__first2,__last2) within [__first1,__last1),
                   *  using comp to decide.  The iterators over each range only move
                   *  forward, so this is a linear algorithm.  If an element in
                   *  [__first2,__last2) is not found before the search iterator
                   *  reaches @p __last2, false is returned.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return std::__includes(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // nth_element
                  // merge
                  // set_difference
                  // set_intersection
                  // set_union
                  // stable_sort
                  // set_symmetric_difference
                  // min_element
                  // max_element
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __next_permutation(_BidirectionalIterator __first,
                		       _BidirectionalIterator __last, _Compare __comp)
                    {
                      if (__first == __last)
                	return false;
                      _BidirectionalIterator __i = __first;
                      ++__i;
                      if (__i == __last)
                	return false;
                      __i = __last;
                      --__i;
                
                      for(;;)
                	{
                	  _BidirectionalIterator __ii = __i;
                	  --__i;
                	  if (__comp(__i, __ii))
                	    {
                	      _BidirectionalIterator __j = __last;
                	      while (!__comp(__i, --__j))
                		{}
                	      std::iter_swap(__i, __j);
                	      std::__reverse(__ii, __last,
                			     std::__iterator_category(__first));
                	      return true;
                	    }
                	  if (__i == __first)
                	    {
                	      std::__reverse(__first, __last,
                			     std::__iterator_category(__first));
                	      return false;
                	    }
                	}
                    }
                
                  /**
                   *  @brief  Permute range into the next @e dictionary ordering.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  False if wrapped to first permutation, true otherwise.
                   *
                   *  Treats all permutations of the range as a set of @e dictionary sorted
                   *  sequences.  Permutes the current sequence into the next one of this set.
                   *  Returns true if there are more sequences to generate.  If the sequence
                   *  is the largest of the set, the smallest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    next_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__next_permutation
                	(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Permute range into the next @e dictionary ordering using
                   *          comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   A comparison functor.
                   *  @return  False if wrapped to first permutation, true otherwise.
                   *
                   *  Treats all permutations of the range [__first,__last) as a set of
                   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                   *  sequence into the next one of this set.  Returns true if there are more
                   *  sequences to generate.  If the sequence is the largest of the set, the
                   *  smallest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    next_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__next_permutation
                	(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __prev_permutation(_BidirectionalIterator __first,
                		       _BidirectionalIterator __last, _Compare __comp)
                    {
                      if (__first == __last)
                	return false;
                      _BidirectionalIterator __i = __first;
                      ++__i;
                      if (__i == __last)
                	return false;
                      __i = __last;
                      --__i;
                
                      for(;;)
                	{
                	  _BidirectionalIterator __ii = __i;
                	  --__i;
                	  if (__comp(__ii, __i))
                	    {
                	      _BidirectionalIterator __j = __last;
                	      while (!__comp(--__j, __i))
                		{}
                	      std::iter_swap(__i, __j);
                	      std::__reverse(__ii, __last,
                			     std::__iterator_category(__first));
                	      return true;
                	    }
                	  if (__i == __first)
                	    {
                	      std::__reverse(__first, __last,
                			     std::__iterator_category(__first));
                	      return false;
                	    }
                	}
                    }
                
                  /**
                   *  @brief  Permute range into the previous @e dictionary ordering.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  False if wrapped to last permutation, true otherwise.
                   *
                   *  Treats all permutations of the range as a set of @e dictionary sorted
                   *  sequences.  Permutes the current sequence into the previous one of this
                   *  set.  Returns true if there are more sequences to generate.  If the
                   *  sequence is the smallest of the set, the largest is generated and false
                   *  returned.
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    prev_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__prev_permutation(__first, __last,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Permute range into the previous @e dictionary ordering using
                   *          comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   A comparison functor.
                   *  @return  False if wrapped to last permutation, true otherwise.
                   *
                   *  Treats all permutations of the range [__first,__last) as a set of
                   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                   *  sequence into the previous one of this set.  Returns true if there are
                   *  more sequences to generate.  If the sequence is the smallest of the set,
                   *  the largest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    prev_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__prev_permutation(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // replace
                  // replace_if
                
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __replace_copy_if(_InputIterator __first, _InputIterator __last,
                		      _OutputIterator __result,
                		      _Predicate __pred, const _Tp& __new_value)
                    {
                      for (; __first != __last; ++__first, (void)++__result)
                	if (__pred(__first))
                	  *__result = __new_value;
                	else
                	  *__result = *__first;
                      return __result;
                    }
                
                  /**
                   *  @brief Copy a sequence, replacing each element of one value with another
                   *         value.
                   *  @param  __first      An input iterator.
                   *  @param  __last       An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __old_value  The value to be replaced.
                   *  @param  __new_value  The replacement value.
                   *  @return   The end of the output sequence, @p result+(last-first).
                   *
                   *  Copies each element in the input range @p [__first,__last) to the
                   *  output range @p [__result,__result+(__last-__first)) replacing elements
                   *  equal to @p __old_value with @p __new_value.
                  */
                  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    replace_copy(_InputIterator __first, _InputIterator __last,
                		 _OutputIterator __result,
                		 const _Tp& __old_value, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__replace_copy_if(__first, __last, __result,
                			__gnu_cxx::__ops::__iter_equals_val(__old_value),
                					      __new_value);
                    }
                
                  /**
                   *  @brief Copy a sequence, replacing each value for which a predicate
                   *         returns true with another value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      An input iterator.
                   *  @param  __last       An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __pred       A predicate.
                   *  @param  __new_value  The replacement value.
                   *  @return   The end of the output sequence, @p __result+(__last-__first).
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  @p [__result,__result+(__last-__first)) replacing elements for which
                   *  @p __pred returns true with @p __new_value.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    replace_copy_if(_InputIterator __first, _InputIterator __last,
                		    _OutputIterator __result,
                		    _Predicate __pred, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__replace_copy_if(__first, __last, __result,
                				__gnu_cxx::__ops::__pred_iter(__pred),
                					      __new_value);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Determines whether the elements of a sequence are sorted.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  True if the elements are sorted, false otherwise.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
                    { return std::is_sorted_until(__first, __last) == __last; }
                
                  /**
                   *  @brief  Determines whether the elements of a sequence are sorted
                   *          according to a comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  True if the elements are sorted, false otherwise.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
                	      _Compare __comp)
                    { return std::is_sorted_until(__first, __last, __comp) == __last; }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                		      _Compare __comp)
                    {
                      if (__first == __last)
                	return __last;
                
                      _ForwardIterator __next = __first;
                      for (++__next; __next != __last; __first = __next, (void)++__next)
                	if (__comp(__next, __first))
                	  return __next;
                      return __next;
                    }
                
                  /**
                   *  @brief  Determines the end of a sorted sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                   *           for which the range [__first, i) is sorted.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__is_sorted_until(__first, __last,
                				    __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Determines the end of a sorted sequence using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                   *           for which the range [__first, i) is sorted.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                		    _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__is_sorted_until(__first, __last,
                				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief  Determines min and max at once as an ordered pair.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                   *  __b) otherwise.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<const _Tp&, const _Tp&>
                    minmax(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                
                      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                		       : pair<const _Tp&, const _Tp&>(__a, __b);
                    }
                
                  /**
                   *  @brief  Determines min and max at once as an ordered pair.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
                   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                   *  __b) otherwise.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<const _Tp&, const _Tp&>
                    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                			      : pair<const _Tp&, const _Tp&>(__a, __b);
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    pair<_ForwardIterator, _ForwardIterator>
                    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                		     _Compare __comp)
                    {
                      _ForwardIterator __next = __first;
                      if (__first == __last
                	  || ++__next == __last)
                	return std::make_pair(__first, __first);
                
                      _ForwardIterator __min{}, __max{};
                      if (__comp(__next, __first))
                	{
                	  __min = __next;
                	  __max = __first;
                	}
                      else
                	{
                	  __min = __first;
                	  __max = __next;
                	}
                
                      __first = __next;
                      ++__first;
                
                      while (__first != __last)
                	{
                	  __next = __first;
                	  if (++__next == __last)
                	    {
                	      if (__comp(__first, __min))
                		__min = __first;
                	      else if (!__comp(__first, __max))
                		__max = __first;
                	      break;
                	    }
                
                	  if (__comp(__next, __first))
                	    {
                	      if (__comp(__next, __min))
                		__min = __next;
                	      if (!__comp(__first, __max))
                		__max = __first;
                	    }
                	  else
                	    {
                	      if (__comp(__first, __min))
                		__min = __first;
                	      if (!__comp(__next, __max))
                		__max = __next;
                	    }
                
                	  __first = __next;
                	  ++__first;
                	}
                
                      return std::make_pair(__min, __max);
                    }
                
                  /**
                   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                   *          elements in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  make_pair(m, M), where m is the first iterator i in 
                   *           [__first, __last) such that no other element in the range is
                   *           smaller, and where M is the last iterator i in [__first, __last)
                   *           such that no other element in the range is larger.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__minmax_element(__first, __last,
                				   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                   *          elements in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  make_pair(m, M), where m is the first iterator i in 
                   *           [__first, __last) such that no other element in the range is
                   *           smaller, and where M is the last iterator i in [__first, __last)
                   *           such that no other element in the range is larger.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                		   _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__minmax_element(__first, __last,
                				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // N2722 + DR 915.
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    min(initializer_list<_Tp> __l)
                    { return *std::min_element(__l.begin(), __l.end()); }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    min(initializer_list<_Tp> __l, _Compare __comp)
                    { return *std::min_element(__l.begin(), __l.end(), __comp); }
                
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    max(initializer_list<_Tp> __l)
                    { return *std::max_element(__l.begin(), __l.end()); }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    max(initializer_list<_Tp> __l, _Compare __comp)
                    { return *std::max_element(__l.begin(), __l.end(), __comp); }
                
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_Tp, _Tp>
                    minmax(initializer_list<_Tp> __l)
                    {
                      pair<const _Tp*, const _Tp*> __p =
                	std::minmax_element(__l.begin(), __l.end());
                      return std::make_pair(*__p.first, *__p.second);
                    }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_Tp, _Tp>
                    minmax(initializer_list<_Tp> __l, _Compare __comp)
                    {
                      pair<const _Tp*, const _Tp*> __p =
                	std::minmax_element(__l.begin(), __l.end(), __comp);
                      return std::make_pair(*__p.first, *__p.second);
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __pred    A binary predicate.
                   *  @return true if there exists a permutation of the elements in
                   *          the range [__first2, __first2 + (__last1 - __first1)),
                   *          beginning with ForwardIterator2 begin, such that
                   *          equal(__first1, __last1, __begin, __pred) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__is_permutation(__first1, __last1, __first2,
                				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
                    }
                
                #if __cplusplus > 201103L
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                		     _BinaryPredicate __pred)
                    {
                      using _Cat1
                	= typename iterator_traits<_ForwardIterator1>::iterator_category;
                      using _Cat2
                	= typename iterator_traits<_ForwardIterator2>::iterator_category;
                      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
                      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
                      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
                      if (__ra_iters)
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	}
                
                      // Efficiently compare identical prefixes:  O(N) if sequences
                      // have the same elements in the same order.
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!__pred(__first1, __first2))
                	  break;
                
                      if (__ra_iters)
                	{
                	  if (__first1 == __last1)
                	    return true;
                	}
                      else
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 == 0 && __d2 == 0)
                	    return true;
                	  if (__d1 != __d2)
                	    return false;
                	}
                
                      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                	{
                	  if (__scan != std::__find_if(__first1, __scan,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                	    continue; // We've seen this one before.
                
                	  auto __matches = std::__count_if(__first2, __last2,
                		__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
                	  if (0 == __matches
                	      || std::__count_if(__scan, __last1,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
                	      != __matches)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  @brief  Checks whether a permutaion of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of first range.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __last2), beginning with ForwardIterator2 begin,
                   *          such that equal(__first1, __last1, begin) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return
                	std::__is_permutation(__first1, __last1, __first2, __last2,
                			      __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of first range.
                   *  @param  __pred    A binary predicate.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __last2), beginning with ForwardIterator2 begin,
                   *          such that equal(__first1, __last1, __begin, __pred) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                		   _BinaryPredicate __pred)
                    {
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__is_permutation(__first1, __last1, __first2, __last2,
                				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
                    }
                
                #if __cplusplus > 201402L
                
                #define __cpp_lib_clamp 201603
                
                  /**
                   *  @brief  Returns the value clamped between lo and hi.
                   *  @ingroup sorting_algorithms
                   *  @param  __val  A value of arbitrary type.
                   *  @param  __lo   A lower limit of arbitrary type.
                   *  @param  __hi   An upper limit of arbitrary type.
                   *  @return max(__val, __lo) if __val < __hi or min(__val, __hi) otherwise.
                   */
                  template<typename _Tp>
                    constexpr const _Tp&
                    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
                    {
                      __glibcxx_assert(!(__hi < __lo));
                      return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
                    }
                
                  /**
                   *  @brief  Returns the value clamped between lo and hi.
                   *  @ingroup sorting_algorithms
                   *  @param  __val   A value of arbitrary type.
                   *  @param  __lo    A lower limit of arbitrary type.
                   *  @param  __hi    An upper limit of arbitrary type.
                   *  @param  __comp  A comparison functor.
                   *  @return max(__val, __lo, __comp) if __comp(__val, __hi)
                   *	      or min(__val, __hi, __comp) otherwise.
                   */
                  template<typename _Tp, typename _Compare>
                    constexpr const _Tp&
                    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
                    {
                      __glibcxx_assert(!__comp(__hi, __lo));
                      return __comp(__val, __lo) ? __lo : __comp(__hi, __val) ? __hi : __val;
                    }
                #endif // C++17
                #endif // C++14
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  /**
                   *  @brief Generate two uniformly distributed integers using a
                   *         single distribution invocation.
                   *  @param  __b0    The upper bound for the first integer.
                   *  @param  __b1    The upper bound for the second integer.
                   *  @param  __g     A UniformRandomBitGenerator.
                   *  @return  A pair (i, j) with i and j uniformly distributed
                   *           over [0, __b0) and [0, __b1), respectively.
                   *
                   *  Requires: __b0 * __b1 <= __g.max() - __g.min().
                   *
                   *  Using uniform_int_distribution with a range that is very
                   *  small relative to the range of the generator ends up wasting
                   *  potentially expensively generated randomness, since
                   *  uniform_int_distribution does not store leftover randomness
                   *  between invocations.
                   *
                   *  If we know we want two integers in ranges that are sufficiently
                   *  small, we can compose the ranges, use a single distribution
                   *  invocation, and significantly reduce the waste.
                  */
                  template<typename _IntType, typename _UniformRandomBitGenerator>
                    pair<_IntType, _IntType>
                    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
                			   _UniformRandomBitGenerator&& __g)
                    {
                      _IntType __x
                	= uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
                      return std::make_pair(__x / __b1, __x % __b1);
                    }
                
                  /**
                   *  @brief Shuffle the elements of a sequence using a uniform random
                   *         number generator.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
                   *  @return  Nothing.
                   *
                   *  Reorders the elements in the range @p [__first,__last) using @p __g to
                   *  provide random numbers.
                  */
                  template<typename _RandomAccessIterator,
                	   typename _UniformRandomNumberGenerator>
                    void
                    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	    _UniformRandomNumberGenerator&& __g)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return;
                
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_DistanceType;
                
                      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
                      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
                      typedef typename __distr_type::param_type __p_type;
                
                      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
                	_Gen;
                      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
                	__uc_type;
                
                      const __uc_type __urngrange = __g.max() - __g.min();
                      const __uc_type __urange = __uc_type(__last - __first);
                
                      if (__urngrange / __urange >= __urange)
                        // I.e. (__urngrange >= __urange * __urange) but without wrap issues.
                      {
                	_RandomAccessIterator __i = __first + 1;
                
                	// Since we know the range isn't empty, an even number of elements
                	// means an uneven number of elements /to swap/, in which case we
                	// do the first one up front:
                
                	if ((__urange % 2) == 0)
                	{
                	  __distr_type __d{0, 1};
                	  std::iter_swap(__i++, __first + __d(__g));
                	}
                
                	// Now we know that __last - __i is even, so we do the rest in pairs,
                	// using a single distribution invocation to produce swap positions
                	// for two successive elements at a time:
                
                	while (__i != __last)
                	{
                	  const __uc_type __swap_range = __uc_type(__i - __first) + 1;
                
                	  const pair<__uc_type, __uc_type> __pospos =
                	    __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);
                
                	  std::iter_swap(__i++, __first + __pospos.first);
                	  std::iter_swap(__i++, __first + __pospos.second);
                	}
                
                	return;
                      }
                
                      __distr_type __d;
                
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
                    }
                #endif
                
                #endif // C++11
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Apply a function to every element of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __f      A unary function object.
                   *  @return   @p __f
                   *
                   *  Applies the function object @p __f to each element in the range
                   *  @p [first,last).  @p __f must not modify the order of the sequence.
                   *  If @p __f has a return value it is ignored.
                  */
                  template<typename _InputIterator, typename _Function>
                    _GLIBCXX20_CONSTEXPR
                    _Function
                    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                      for (; __first != __last; ++__first)
                	__f(*__first);
                      return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.
                    }
                
                #if __cplusplus >= 201703L
                  /**
                   *  @brief Apply a function to every element of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __n      A value convertible to an integer.
                   *  @param  __f      A unary function object.
                   *  @return   `__first+__n`
                   *
                   *  Applies the function object `__f` to each element in the range
                   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.
                   *  If `__f` has a return value it is ignored.
                  */
                  template<typename _InputIterator, typename _Size, typename _Function>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    for_each_n(_InputIterator __first, _Size __n, _Function __f)
                    {
                      auto __n2 = std::__size_to_integer(__n);
                      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
                      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)
                	{
                	  if (__n2 <= 0)
                	    return __first;
                	  auto __last = __first + __n2;
                	  std::for_each(__first, __last, std::move(__f));
                	  return __last;
                	}
                      else
                	{
                	  while (__n2-->0)
                	    {
                	      __f(*__first);
                	      ++__first;
                	    }
                	  return __first;
                	}
                    }
                #endif // C++17
                
                  /**
                   *  @brief Find the first occurrence of a value in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __val    The value to find.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    find(_InputIterator __first, _InputIterator __last,
                	 const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                		typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__iter_equals_val(__val));
                    }
                
                  /**
                   *  @brief Find the first element in a sequence for which a
                   *         predicate is true.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    find_if(_InputIterator __first, _InputIterator __last,
                	    _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief  Find element from a set in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of match candidates.
                   *  @param  __last2   End of match candidates.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
                   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for an element that is
                   *  equal to some element in the range [__first2,__last2).  If
                   *  found, returns an iterator in the range [__first1,__last1),
                   *  otherwise returns @p __last1.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    find_first_of(_InputIterator __first1, _InputIterator __last1,
                		  _ForwardIterator __first2, _ForwardIterator __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1; ++__first1)
                	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                	  if (*__first1 == *__iter)
                	    return __first1;
                      return __last1;
                    }
                
                  /**
                   *  @brief  Find element from a set in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of match candidates.
                   *  @param  __last2   End of match candidates.
                   *  @param  __comp    Predicate to use.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
                   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
                   *  such iterator exists.
                   *
                
                   *  Searches the range @p [__first1,__last1) for an element that is
                   *  equal to some element in the range [__first2,__last2).  If
                   *  found, returns an iterator in the range [__first1,__last1),
                   *  otherwise returns @p __last1.
                  */
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    find_first_of(_InputIterator __first1, _InputIterator __last1,
                		  _ForwardIterator __first2, _ForwardIterator __last2,
                		  _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_InputIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1; ++__first1)
                	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                	  if (__comp(*__first1, *__iter))
                	    return __first1;
                      return __last1;
                    }
                
                  /**
                   *  @brief Find two adjacent values in a sequence that are equal.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
                   *  or @p __last if no such iterator exists.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__adjacent_find(__first, __last,
                				  __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Find two adjacent values in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first         A forward iterator.
                   *  @param  __last          A forward iterator.
                   *  @param  __binary_pred   A binary predicate.
                   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                   *  valid iterators in @p [__first,__last) and such that
                   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
                   *  exists.
                  */
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                		  _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__adjacent_find(__first, __last,
                			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                  /**
                   *  @brief Count the number of copies of a value in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __value  The value to be counted.
                   *  @return   The number of iterators @c i in the range @p [__first,__last)
                   *  for which @c *i == @p __value
                  */
                  template<typename _InputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename iterator_traits<_InputIterator>::difference_type
                    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__count_if(__first, __last,
                			     __gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Count the elements of a sequence for which a predicate is true.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The number of iterators @c i in the range @p [__first,__last)
                   *  for which @p __pred(*i) is true.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline typename iterator_traits<_InputIterator>::difference_type
                    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__count_if(__first, __last,
                			     __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief Search a sequence for a matching sub-sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @param  __last2   A forward iterator.
                   *  @return The first iterator @c i in the range @p
                   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
                   *  *(__first2+N) for each @c N in the range @p
                   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) and returns an iterator to the first element
                   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
                   *  found.
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.
                   *
                   *  This means that the returned iterator @c i will be in the range
                   *  @p [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__search(__first1, __last1, __first2, __last2,
                			   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Search a sequence for a matching sub-sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1     A forward iterator.
                   *  @param  __last1      A forward iterator.
                   *  @param  __first2     A forward iterator.
                   *  @param  __last2      A forward iterator.
                   *  @param  __predicate  A binary predicate.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1-(__last2-__first2)) such that
                   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
                   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2), using @p __predicate to determine equality,
                   *  and returns an iterator to the first element of the
                   *  sub-sequence, or @p __last1 if no such iterator exists.
                   *
                   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	   _BinaryPredicate  __predicate)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__search(__first1, __last1, __first2, __last2,
                			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
                    }
                
                  /**
                   *  @brief Search a sequence for a number of consecutive values.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __count  The number of consecutive values.
                   *  @param  __val    The value to find.
                   *  @return The first iterator @c i in the range @p
                   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
                   *  each @c N in the range @p [0,__count), or @p __last if no such
                   *  iterator exists.
                   *
                   *  Searches the range @p [__first,__last) for @p count consecutive elements
                   *  equal to @p __val.
                  */
                  template<typename _ForwardIterator, typename _Integer, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    search_n(_ForwardIterator __first, _ForwardIterator __last,
                	     _Integer __count, const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__search_n(__first, __last, __count,
                			     __gnu_cxx::__ops::__iter_equals_val(__val));
                    }
                
                
                  /**
                   *  @brief Search a sequence for a number of consecutive values using a
                   *         predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __count        The number of consecutive values.
                   *  @param  __val          The value to find.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return The first iterator @c i in the range @p
                   *  [__first,__last-__count) such that @p
                   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
                   *  @p [0,__count), or @p __last if no such iterator exists.
                   *
                   *  Searches the range @p [__first,__last) for @p __count
                   *  consecutive elements for which the predicate returns true.
                  */
                  template<typename _ForwardIterator, typename _Integer, typename _Tp,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    search_n(_ForwardIterator __first, _ForwardIterator __last,
                	     _Integer __count, const _Tp& __val,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__search_n(__first, __last, __count,
                		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
                    }
                
                #if __cplusplus >= 201703L
                  /** @brief Search a sequence using a Searcher object.
                   *
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __searcher     A callable object.
                   *  @return @p __searcher(__first,__last).first
                  */
                  template<typename _ForwardIterator, typename _Searcher>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    search(_ForwardIterator __first, _ForwardIterator __last,
                	   const _Searcher& __searcher)
                    { return __searcher(__first, __last).first; }
                #endif
                
                  /**
                   *  @brief Perform an operation on a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first     An input iterator.
                   *  @param  __last      An input iterator.
                   *  @param  __result    An output iterator.
                   *  @param  __unary_op  A unary operator.
                   *  @return   An output iterator equal to @p __result+(__last-__first).
                   *
                   *  Applies the operator to each element in the input range and assigns
                   *  the results to successive elements of the output sequence.
                   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
                   *  range @p [0,__last-__first).
                   *
                   *  @p unary_op must not alter its argument.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _UnaryOperation>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    transform(_InputIterator __first, _InputIterator __last,
                	      _OutputIterator __result, _UnaryOperation __unary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _UnaryOperation"
                	    __typeof__(__unary_op(*__first))>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first, (void)++__result)
                	*__result = __unary_op(*__first);
                      return __result;
                    }
                
                  /**
                   *  @brief Perform an operation on corresponding elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1     An input iterator.
                   *  @param  __last1      An input iterator.
                   *  @param  __first2     An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __binary_op  A binary operator.
                   *  @return   An output iterator equal to @p result+(last-first).
                   *
                   *  Applies the operator to the corresponding elements in the two
                   *  input ranges and assigns the results to successive elements of the
                   *  output sequence.
                   *  Evaluates @p
                   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
                   *  @c N in the range @p [0,__last1-__first1).
                   *
                   *  @p binary_op must not alter either of its arguments.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _BinaryOperation>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    transform(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _OutputIterator __result,
                	      _BinaryOperation __binary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _BinaryOperation"
                	    __typeof__(__binary_op(*__first1,*__first2))>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
                	*__result = __binary_op(*__first1, *__first2);
                      return __result;
                    }
                
                  /**
                   *  @brief Replace each occurrence of one value in a sequence with another
                   *         value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      A forward iterator.
                   *  @param  __last       A forward iterator.
                   *  @param  __old_value  The value to be replaced.
                   *  @param  __new_value  The replacement value.
                   *  @return   replace() returns no value.
                   *
                   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
                   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    void
                    replace(_ForwardIterator __first, _ForwardIterator __last,
                	    const _Tp& __old_value, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (*__first == __old_value)
                	  *__first = __new_value;
                    }
                
                  /**
                   *  @brief Replace each value in a sequence for which a predicate returns
                   *         true with another value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      A forward iterator.
                   *  @param  __last       A forward iterator.
                   *  @param  __pred       A predicate.
                   *  @param  __new_value  The replacement value.
                   *  @return   replace_if() returns no value.
                   *
                   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
                   *  is true then the assignment @c *i = @p __new_value is performed.
                  */
                  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    void
                    replace_if(_ForwardIterator __first, _ForwardIterator __last,
                	       _Predicate __pred, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  *__first = __new_value;
                    }
                
                  /**
                   *  @brief Assign the result of a function object to each value in a
                   *         sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __gen    A function object taking no arguments and returning
                   *                 std::iterator_traits<_ForwardIterator>::value_type
                   *  @return   generate() returns no value.
                   *
                   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                   *  @p [__first,__last).
                  */
                  template<typename _ForwardIterator, typename _Generator>
                    _GLIBCXX20_CONSTEXPR
                    void
                    generate(_ForwardIterator __first, _ForwardIterator __last,
                	     _Generator __gen)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_GeneratorConcept<_Generator,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	*__first = __gen();
                    }
                
                  /**
                   *  @brief Assign the result of a function object to each value in a
                   *         sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __n      The length of the sequence.
                   *  @param  __gen    A function object taking no arguments and returning
                   *                 std::iterator_traits<_ForwardIterator>::value_type
                   *  @return   The end of the sequence, @p __first+__n
                   *
                   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                   *  @p [__first,__first+__n).
                   *
                   * If @p __n is negative, the function does nothing and returns @p __first.
                  */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 865. More algorithms that throw away information
                  // DR 426. search_n(), fill_n(), and generate_n() with negative n
                  template<typename _OutputIterator, typename _Size, typename _Generator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _Generator"
                	    __typeof__(__gen())>)
                
                      typedef __decltype(std::__size_to_integer(__n)) _IntSize;
                      for (_IntSize __niter = std::__size_to_integer(__n);
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __gen();
                      return __first;
                    }
                
                  /**
                   *  @brief Copy a sequence, removing consecutive duplicate values.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  beginning at @p __result, except that only the first element is copied
                   *  from groups of consecutive elements that compare equal.
                   *  unique_copy() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                   *  
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
                   *  Assignable?
                  */
                  template<typename _InputIterator, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    unique_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      return std::__unique_copy(__first, __last, __result,
                				__gnu_cxx::__ops::__iter_equal_to_iter(),
                				std::__iterator_category(__first),
                				std::__iterator_category(__result));
                    }
                
                  /**
                   *  @brief Copy a sequence, removing consecutive values using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first        An input iterator.
                   *  @param  __last         An input iterator.
                   *  @param  __result       An output iterator.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  beginning at @p __result, except that only the first element is copied
                   *  from groups of consecutive elements for which @p __binary_pred returns
                   *  true.
                   *  unique_copy() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    unique_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result,
                		_BinaryPredicate __binary_pred)
                    {
                      // concept requirements -- predicates checked later
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      return std::__unique_copy(__first, __last, __result,
                			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
                				std::__iterator_category(__first),
                				std::__iterator_category(__result));
                    }
                
                #if _GLIBCXX_HOSTED
                  /**
                   *  @brief Randomly shuffle the elements of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @return  Nothing.
                   *
                   *  Reorder the elements in the range @p [__first,__last) using a random
                   *  distribution, so that every possible ordering of the sequence is
                   *  equally likely.
                  */
                  template<typename _RandomAccessIterator>
                    inline void
        3000 ->     random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first != __last)
                	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	  {
                	    // XXX rand() % N is not uniformly distributed
                	    _RandomAccessIterator __j = __first
                					+ std::rand() % ((__i - __first) + 1);
                	    if (__i != __j)
                	      std::iter_swap(__i, __j);
                	  }
                    }
                #endif
                
                  /**
                   *  @brief Shuffle the elements of a sequence using a random number
                   *         generator.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __rand    The RNG functor or function.
                   *  @return  Nothing.
                   *
                   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
                   *  provide a random distribution. Calling @p __rand(N) for a positive
                   *  integer @p N should return a randomly chosen integer from the
                   *  range [0,N).
                  */
                  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
                    void
                    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                #if __cplusplus >= 201103L
                		   _RandomNumberGenerator&& __rand)
                #else
                		   _RandomNumberGenerator& __rand)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return;
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	{
                	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
                	  if (__i != __j)
                	    std::iter_swap(__i, __j);
                	}
                    }
                
                
                  /**
                   *  @brief Move elements for which a predicate is true to the beginning
                   *         of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __pred    A predicate functor.
                   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                   *  iterator @p i in the range @p [__first,middle) and false for each @p i
                   *  in the range @p [middle,__last).
                   *
                   *  @p __pred must not modify its operand. @p partition() does not preserve
                   *  the relative ordering of elements in each group, use
                   *  @p stable_partition() if this is needed.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    partition(_ForwardIterator __first, _ForwardIterator __last,
                	      _Predicate   __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__partition(__first, __last, __pred,
                			      std::__iterator_category(__first));
                    }
                
                
                  /**
                   *  @brief Sort the smallest elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the smallest @p (__middle-__first) elements in the range
                   *  @p [first,last) and moves them to the range @p [__first,__middle). The
                   *  order of the remaining elements in the range @p [__middle,__last) is
                   *  undefined.
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    partial_sort(_RandomAccessIterator __first,
                		 _RandomAccessIterator __middle,
                		 _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__partial_sort(__first, __middle, __last,
                			  __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the smallest elements of a sequence using a predicate
                   *         for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the smallest @p (__middle-__first) elements in the range
                   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
                   *  order of the remaining elements in the range @p [__middle,__last) is
                   *  undefined.
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
                   *  are both false.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    partial_sort(_RandomAccessIterator __first,
                		 _RandomAccessIterator __middle,
                		 _RandomAccessIterator __last,
                		 _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__partial_sort(__first, __middle, __last,
                			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Sort a sequence just enough to find a particular position.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __nth     Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                   *  is the same element that would have been in that position had the
                   *  whole sequence been sorted. The elements either side of @p *__nth are
                   *  not completely sorted, but for any iterator @e i in the range
                   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                   *  holds that *j < *i is false.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		_RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __nth);
                      __glibcxx_requires_valid_range(__nth, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      if (__first == __last || __nth == __last)
                	return;
                
                      std::__introselect(__first, __nth, __last,
                			 std::__lg(__last - __first) * 2,
                			 __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort a sequence just enough to find a particular position
                   *         using a predicate for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __nth     Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                   *  is the same element that would have been in that position had the
                   *  whole sequence been sorted. The elements either side of @p *__nth are
                   *  not completely sorted, but for any iterator @e i in the range
                   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                   *  holds that @p __comp(*j,*i) is false.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		_RandomAccessIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __nth);
                      __glibcxx_requires_valid_range(__nth, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      if (__first == __last || __nth == __last)
                	return;
                
                      std::__introselect(__first, __nth, __last,
                			 std::__lg(__last - __first) * 2,
                			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @e i in the range @p [__first,__last-1),  
                   *  *(i+1)<*i is false.
                   *
                   *  The relative ordering of equivalent elements is not preserved, use
                   *  @p stable_sort() if this is needed.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence using a predicate for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
                   *  range @p [__first,__last-1).
                   *
                   *  The relative ordering of equivalent elements is not preserved, use
                   *  @p stable_sort() if this is needed.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
         300 ->     sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	 _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	    _InputIterator2 __first2, _InputIterator2 __last2,
                	    _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = *__first2;
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      return std::copy(__first2, __last2,
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief Merges two sorted ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An iterator.
                   *  @param  __first2  Another iterator.
                   *  @param  __last1   Another iterator.
                   *  @param  __last2   Another iterator.
                   *  @param  __result  An iterator pointing to the end of the merged range.
                   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
                   *            + (__last2 - __first2).
                   *
                   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                   *  the sorted range @p [__result, __result + (__last1-__first1) +
                   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                   *  output range must not overlap with either of the input ranges.
                   *  The sort is @e stable, that is, for equivalent elements in the
                   *  two ranges, elements from the first range will always come
                   *  before elements from the second.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2, _InputIterator2 __last2,
                	  _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__merge(__first1, __last1,
                				     __first2, __last2, __result,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Merges two sorted ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An iterator.
                   *  @param  __first2  Another iterator.
                   *  @param  __last1   Another iterator.
                   *  @param  __last2   Another iterator.
                   *  @param  __result  An iterator pointing to the end of the merged range.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
                   *            + (__last2 - __first2).
                   *
                   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                   *  the sorted range @p [__result, __result + (__last1-__first1) +
                   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                   *  output range must not overlap with either of the input ranges.
                   *  The sort is @e stable, that is, for equivalent elements in the
                   *  two ranges, elements from the first range will always come
                   *  before elements from the second.
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2, _InputIterator2 __last2,
                	  _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__merge(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                		  _Compare __comp)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_DistanceType;
                      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
                
                      if (__first == __last)
                	return;
                
                      // __stable_sort_adaptive sorts the range in two halves,
                      // so the buffer only needs to fit half the range at once.
                      _TmpBuf __buf(__first, (__last - __first + 1) / 2);
                
                      if (__buf.begin() == 0)
                	std::__inplace_stable_sort(__first, __last, __comp);
                      else
                	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
                				    _DistanceType(__buf.size()), __comp);
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence, preserving the relative order
                   *         of equivalent elements.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @p i in the range @p [__first,__last-1),
                   *  @p *(i+1)<*i is false.
                   *
                   *  The relative ordering of equivalent elements is preserved, so any two
                   *  elements @p x and @p y in the range @p [__first,__last) such that
                   *  @p x<y is false and @p y<x is false will have the same relative
                   *  ordering after calling @p stable_sort().
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      _GLIBCXX_STD_A::__stable_sort(__first, __last,
                				    __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence using a predicate for comparison,
                   *         preserving the relative order of equivalent elements.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @p i in the range @p [__first,__last-1),
                   *  @p __comp(*(i+1),*i) is false.
                   *
                   *  The relative ordering of equivalent elements is preserved, so any two
                   *  elements @p x and @p y in the range @p [__first,__last) such that
                   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
                   *  relative ordering after calling @p stable_sort().
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      _GLIBCXX_STD_A::__stable_sort(__first, __last,
                				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                		_InputIterator2 __first2, _InputIterator2 __last2,
                		_OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first1, __first2))
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	    }
                	  else if (__comp(__first2, __first1))
                	    {
                	      *__result = *__first2;
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	      ++__first2;
                	    }
                	  ++__result;
                	}
                      return std::copy(__first2, __last2,
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief Return the union of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  each range in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other,
                   *  that element is copied and the iterator advanced.  If an element is
                   *  contained in both ranges, the element from the first range is copied and
                   *  both ranges advance.  The output range may not overlap either input
                   *  range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _InputIterator2 __last2,
                	      _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Return the union of two sorted ranges using a comparison functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  each range in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other
                   *  according to @p __comp, that element is copied and the iterator advanced.
                   *  If an equivalent element according to @p __comp is contained in both
                   *  ranges, the element from the first range is copied and both ranges
                   *  advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _InputIterator2 __last2,
                	      _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		       _InputIterator2 __first2, _InputIterator2 __last2,
                		       _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  ++__first1;
                	else if (__comp(__first2, __first1))
                	  ++__first2;
                	else
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__first2;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Return the intersection of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  both ranges in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other,
                   *  that iterator advances.  If an element is contained in both ranges, the
                   *  element from the first range is copied and both ranges advance.  The
                   *  output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
                				     __first2, __last2, __result,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Return the intersection of two sorted ranges using comparison
                   *  functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  both ranges in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other
                   *  according to @p __comp, that iterator advances.  If an element is
                   *  contained in both ranges according to @p __comp, the element from the
                   *  first range is copied and both ranges advance.  The output range may not
                   *  overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__result;
                	  }
                	else if (__comp(__first2, __first1))
                	  ++__first2;
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                      return std::copy(__first1, __last1, __result);
                    }
                
                  /**
                   *  @brief Return the difference of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  the first range but not the second in order to the output range.
                   *  Iterators increment for each range.  When the current element of the
                   *  first range is less than the second, that element is copied and the
                   *  iterator advances.  If the current element of the second range is less,
                   *  the iterator advances, but no element is copied.  If an element is
                   *  contained in both ranges, no elements are copied and both ranges
                   *  advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		   _InputIterator2 __first2, _InputIterator2 __last2,
                		   _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
                				   __first2, __last2, __result,
                				   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the difference of two sorted ranges using comparison
                   *  functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  the first range but not the second in order to the output range.
                   *  Iterators increment for each range.  When the current element of the
                   *  first range is less than the second according to @p __comp, that element
                   *  is copied and the iterator advances.  If the current element of the
                   *  second range is less, no element is copied and the iterator advances.
                   *  If an element is contained in both ranges according to @p __comp, no
                   *  elements are copied and both ranges advance.  The output range may not
                   *  overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		   _InputIterator2 __first2, _InputIterator2 __last2,
                		   _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
                				   __first2, __last2, __result,
                				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_symmetric_difference(_InputIterator1 __first1,
                			       _InputIterator1 __last1,
                			       _InputIterator2 __first2,
                			       _InputIterator2 __last2,
                			       _OutputIterator __result,
                			       _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__result;
                	  }
                	else if (__comp(__first2, __first1))
                	  {
                	    *__result = *__first2;
                	    ++__first2;
                	    ++__result;
                	  }
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                      return std::copy(__first2, __last2, 
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief  Return the symmetric difference of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  one range but not the other in order to the output range.  Iterators
                   *  increment for each range.  When the current element of one range is less
                   *  than the other, that element is copied and the iterator advances.  If an
                   *  element is contained in both ranges, no elements are copied and both
                   *  ranges advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                			     _InputIterator2 __first2, _InputIterator2 __last2,
                			     _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
                					__first2, __last2, __result,
                					__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the symmetric difference of two sorted ranges using
                   *  comparison functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  one range but not the other in order to the output range.  Iterators
                   *  increment for each range.  When the current element of one range is less
                   *  than the other according to @p comp, that element is copied and the
                   *  iterator advances.  If an element is contained in both ranges according
                   *  to @p __comp, no elements are copied and both ranges advance.  The output
                   *  range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                			     _InputIterator2 __first2, _InputIterator2 __last2,
                			     _OutputIterator __result,
                			     _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    __min_element(_ForwardIterator __first, _ForwardIterator __last,
                		  _Compare __comp)
                    {
                      if (__first == __last)
                	return __first;
                      _ForwardIterator __result = __first;
                      while (++__first != __last)
                	if (__comp(__first, __result))
                	  __result = __first;
                      return __result;
                    }
                
                  /**
                   *  @brief  Return the minimum element in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  Iterator referencing the first instance of the smallest value.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return _GLIBCXX_STD_A::__min_element(__first, __last,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the minimum element in a range using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  Iterator referencing the first instance of the smallest value
                   *  according to __comp.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    min_element(_ForwardIterator __first, _ForwardIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return _GLIBCXX_STD_A::__min_element(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    __max_element(_ForwardIterator __first, _ForwardIterator __last,
                		  _Compare __comp)
                    {
                      if (__first == __last) return __first;
                      _ForwardIterator __result = __first;
                      while (++__first != __last)
                	if (__comp(__result, __first))
                	  __result = __first;
                      return __result;
                    }
                
                  /**
                   *  @brief  Return the maximum element in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  Iterator referencing the first instance of the largest value.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    max_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return _GLIBCXX_STD_A::__max_element(__first, __last,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the maximum element in a range using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  Iterator referencing the first instance of the largest value
                   *  according to __comp.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    max_element(_ForwardIterator __first, _ForwardIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return _GLIBCXX_STD_A::__max_element(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cplusplus >= 201402L
                  /// Reservoir sampling algorithm.
                  template<typename _InputIterator, typename _RandomAccessIterator,
                           typename _Size, typename _UniformRandomBitGenerator>
                    _RandomAccessIterator
                    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
                	     _RandomAccessIterator __out, random_access_iterator_tag,
                	     _Size __n, _UniformRandomBitGenerator&& __g)
                    {
                      using __distrib_type = uniform_int_distribution<_Size>;
                      using __param_type = typename __distrib_type::param_type;
                      __distrib_type __d{};
                      _Size __sample_sz = 0;
                      while (__first != __last && __sample_sz != __n)
                	{
                	  __out[__sample_sz++] = *__first;
                	  ++__first;
                	}
                      for (auto __pop_sz = __sample_sz; __first != __last;
                	  ++__first, (void) ++__pop_sz)
                	{
                	  const auto __k = __d(__g, __param_type{0, __pop_sz});
                	  if (__k < __n)
                	    __out[__k] = *__first;
                	}
                      return __out + __sample_sz;
                    }
                
                  /// Selection sampling algorithm.
                  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
                           typename _Size, typename _UniformRandomBitGenerator>
                    _OutputIterator
                    __sample(_ForwardIterator __first, _ForwardIterator __last,
                	     forward_iterator_tag,
                	     _OutputIterator __out, _Cat,
                	     _Size __n, _UniformRandomBitGenerator&& __g)
                    {
                      using __distrib_type = uniform_int_distribution<_Size>;
                      using __param_type = typename __distrib_type::param_type;
                      using _USize = make_unsigned_t<_Size>;
                      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
                      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
                
                      if (__first == __last)
                	return __out;
                
                      __distrib_type __d{};
                      _Size __unsampled_sz = std::distance(__first, __last);
                      __n = std::min(__n, __unsampled_sz);
                
                      // If possible, we use __gen_two_uniform_ints to efficiently produce
                      // two random numbers using a single distribution invocation:
                
                      const __uc_type __urngrange = __g.max() - __g.min();
                      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))
                        // I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without
                	// wrapping issues.
                        {
                	  while (__n != 0 && __unsampled_sz >= 2)
                	    {
                	      const pair<_Size, _Size> __p =
                		__gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);
                
                	      --__unsampled_sz;
                	      if (__p.first < __n)
                		{
                		  *__out++ = *__first;
                		  --__n;
                		}
                
                	      ++__first;
                
                	      if (__n == 0) break;
                
                	      --__unsampled_sz;
                	      if (__p.second < __n)
                		{
                		  *__out++ = *__first;
                		  --__n;
                		}
                
                	      ++__first;
                	    }
                        }
                
                      // The loop above is otherwise equivalent to this one-at-a-time version:
                
                      for (; __n != 0; ++__first)
                	if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
                	  {
                	    *__out++ = *__first;
                	    --__n;
                	  }
                      return __out;
                    }
                
                #if __cplusplus > 201402L
                #define __cpp_lib_sample 201603
                  /// Take a random sample from a population.
                  template<typename _PopulationIterator, typename _SampleIterator,
                           typename _Distance, typename _UniformRandomBitGenerator>
                    _SampleIterator
                    sample(_PopulationIterator __first, _PopulationIterator __last,
                	   _SampleIterator __out, _Distance __n,
                	   _UniformRandomBitGenerator&& __g)
                    {
                      using __pop_cat = typename
                	std::iterator_traits<_PopulationIterator>::iterator_category;
                      using __samp_cat = typename
                	std::iterator_traits<_SampleIterator>::iterator_category;
                
                      static_assert(
                	  __or_<is_convertible<__pop_cat, forward_iterator_tag>,
                		is_convertible<__samp_cat, random_access_iterator_tag>>::value,
                	  "output range must use a RandomAccessIterator when input range"
                	  " does not meet the ForwardIterator requirements");
                
                      static_assert(is_integral<_Distance>::value,
                		    "sample size must be an integer type");
                
                      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
                      return _GLIBCXX_STD_A::
                	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
                		 std::forward<_UniformRandomBitGenerator>(__g));
                    }
                #endif // C++17
                #endif // C++14
                
                _GLIBCXX_END_NAMESPACE_ALGO
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_ALGO_H */


Top 10 Lines:

     Line      Count

     1799     299082
       79      30407
     1878      30407
     1900      30407
     4568       3000
     1819        300
     1843        300
     1861        300
     1925        300
     1949        300

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

   395103   Total number of line executions
 30392.54   Average executions per line


*** File /usr/include/c++/11/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp;
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __tmp = this->_M_allocate(__n);
                	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  __tmp, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __tmp = _M_allocate_and_copy(__n,
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	    }
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                #if __cplusplus > 201402L
                      typename vector<_Tp, _Alloc>::reference
                #else
                      void
                #endif
                      vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
                #if __cplusplus > 201402L
                	return back();
                #endif
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == end())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  {
                #if __cplusplus >= 201103L
                	    const auto __pos = begin() + (__position - cbegin());
                	    // __x could be an existing element of this vector, so make a
                	    // copy of it before _M_insert_aux moves elements around.
                	    _Temporary_value __x_copy(this, __x);
                	    _M_insert_aux(__pos, std::move(__x_copy._M_val()));
                #else
                	    _M_insert_aux(__position, __x);
                #endif
                	  }
                      else
                #if __cplusplus >= 201103L
                	_M_realloc_insert(begin() + (__position - cbegin()), __x);
                #else
                	_M_realloc_insert(__position, __x);
                #endif
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
     2861942 ->     vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp._M_impl._M_swap_data(this->_M_impl);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  const size_type __add = __n - size();
                	  _GLIBCXX_ASAN_ANNOTATE_GROW(__add);
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					  __add, __val, _M_get_Tp_allocator());
                	  _GLIBCXX_ASAN_ANNOTATE_GREW(__add);
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, (void)++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  _M_range_insert(end(), __first, __last,
                			  std::__iterator_category(__first));
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    _S_check_init_len(__len, _M_get_Tp_allocator());
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    const size_type __attribute__((__unused__)) __n = __len - size();
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    auto
                    vector<_Tp, _Alloc>::
                    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
                    {
                      const auto __n = __position - cbegin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == cend())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::move(__v));
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_insert_aux(begin() + __n, std::move(__v));
                      else
                	_M_realloc_insert(begin() + __n, std::move(__v));
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      auto
                      vector<_Tp, _Alloc>::
                      _M_emplace_aux(const_iterator __position, _Args&&... __args)
                      -> iterator
                      {
                	const auto __n = __position - cbegin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  if (__position == cend())
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				       std::forward<_Args>(__args)...);
                	      ++this->_M_impl._M_finish;
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	    }
                	  else
                	    {
                	      // We need to construct a temporary because something in __args...
                	      // could alias one of the elements of the container and so we
                	      // need to use it before _M_insert_aux moves elements around.
                	      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
                	      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
                	    }
                	else
                	  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
                
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _Arg>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Arg&& __arg)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			       _GLIBCXX_MOVE(*(this->_M_impl._M_finish - 1)));
                      ++this->_M_impl._M_finish;
                      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                #if __cplusplus < 201103L
                      _Tp __x_copy = __x;
                #endif
                      _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                			      this->_M_impl._M_finish - 2,
                			      this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                      *__position = __x_copy;
                #else
                      *__position = std::forward<_Arg>(__arg);
                #endif
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
     1281040 ->       vector<_Tp, _Alloc>::
                      _M_realloc_insert(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_realloc_insert(iterator __position, const _Tp& __x)
                #endif
                    {
                      const size_type __len =
                	_M_check_len(size_type(1), "vector::_M_realloc_insert");
                      pointer __old_start = this->_M_impl._M_start;
                      pointer __old_finish = this->_M_impl._M_finish;
                      const size_type __elems_before = __position - begin();
                      pointer __new_start(this->_M_allocate(__len));
                      pointer __new_finish(__new_start);
                      __try
                	{
                	  // The order of the three operations is dictated by the C++11
                	  // case, where the moves could alter a new element belonging
                	  // to the existing vector.  This is an issue only for callers
                	  // taking the element by lvalue ref (see last bullet of C++11
                	  // [res.on.arguments]).
                	  _Alloc_traits::construct(this->_M_impl,
                				   __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				   std::forward<_Args>(__args)...);
                #else
                				   __x);
                #endif
                	  __new_finish = pointer();
                
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __new_finish = _S_relocate(__old_start, __position.base(),
                					 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish = _S_relocate(__position.base(), __old_finish,
                					 __new_finish, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__old_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), __old_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                	}
                      __catch(...)
                	{
                	  if (!__new_finish)
                	    _Alloc_traits::destroy(this->_M_impl,
                				   __new_start + __elems_before);
                	  else
                	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	  _M_deallocate(__new_start, __len);
                	  __throw_exception_again;
                	}
                #if __cplusplus >= 201103L
                      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
                #endif
                	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      _M_deallocate(__old_start,
                		    this->_M_impl._M_end_of_storage - __old_start);
                      this->_M_impl._M_start = __new_start;
                      this->_M_impl._M_finish = __new_finish;
                      this->_M_impl._M_end_of_storage = __new_start + __len;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                #if __cplusplus < 201103L
                	      value_type __x_copy = __x;
                #else
                	      _Temporary_value __tmp(this, __x);
                	      value_type& __x_copy = __tmp._M_val();
                #endif
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  this->_M_impl._M_finish =
                		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						  __n - __elems_after,
                						  __x_copy,
                						  _M_get_Tp_allocator());
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_realloc_insert above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = pointer();
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  const size_type __size = size();
                	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
                					 - this->_M_impl._M_finish);
                
                	  if (__size > max_size() || __navail > max_size() - __size)
                	    __builtin_unreachable();
                
                	  if (__navail >= __n)
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	      this->_M_impl._M_finish =
                		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                						 __n, _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      pointer __new_start(this->_M_allocate(__len));
                	      if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                		{
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		}
                	      else
                		{
                		  pointer __destroy_from = pointer();
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		      __destroy_from = __new_start + __size;
                		      std::__uninitialized_move_if_noexcept_a(
                			      this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      if (__destroy_from)
                			std::_Destroy(__destroy_from, __destroy_from + __n,
                				      _M_get_Tp_allocator());
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                				_M_get_Tp_allocator());
                		}
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_start + __size + __n;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	if (__pos == end())
                	  {
                	    for (; __first != __last; ++__first)
                	      insert(end(), *__first);
                	  }
                	else if (__first != __last)
                	  {
                	    vector __tmp(__first, __last, _M_get_Tp_allocator());
                	    insert(__pos,
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.begin()),
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.end()));
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_GLIBCXX_ASAN_ANNOTATE_REINIT;
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_pointer __q = this->_M_allocate(__n);
                      iterator __start(std::__addressof(*__q), 0);
                      iterator __finish(_M_copy_aligned(begin(), end(), __start));
                      this->_M_deallocate();
                      this->_M_impl._M_start = __start;
                      this->_M_impl._M_finish = __finish;
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  iterator __finish = std::copy(__position, end(),
                					__i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_pointer __q = this->_M_allocate(__len);
                		iterator __start(std::__addressof(*__q), 0);
                		iterator __i = _M_copy_aligned(begin(), __position, __start);
                		__i = std::copy(__first, __last, __i);
                		iterator __finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = __start;
                		this->_M_impl._M_finish = __finish;
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  *__i++ = __x;
                	  iterator __finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      return __position;
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	_M_erase_at_end(std::copy(__last, end(), __first));
                      return __first;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  _M_reallocate(size());
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #undef _GLIBCXX_ASAN_ANNOTATE_REINIT
                #undef _GLIBCXX_ASAN_ANNOTATE_GROW
                #undef _GLIBCXX_ASAN_ANNOTATE_GREW
                #undef _GLIBCXX_ASAN_ANNOTATE_SHRINK
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      198    2861942
      426    1281040

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

  4142982   Total number of line executions
2071491.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_algobase.h:
                // Core algorithmic facilities -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGOBASE_H
                #define _STL_ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <bits/functexcept.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <ext/numeric_traits.h>
                #include <bits/stl_pair.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For std::swap
                #include <bits/predefined_ops.h>
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                #if __cplusplus > 201703L
                # include <compare>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /*
                   * A constexpr wrapper for __builtin_memcmp.
                   * @param __num The number of elements of type _Tp (not bytes).
                   */
                  template<typename _Tp, typename _Up>
                    _GLIBCXX14_CONSTEXPR
                    inline int
                    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
                    {
                #if __cplusplus >= 201103L
                      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
                #endif
                #ifdef __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	{
                	  for(; __num > 0; ++__first1, ++__first2, --__num)
                	    if (*__first1 != *__first2)
                	      return *__first1 < *__first2 ? -1 : 1;
                	  return 0;
                	}
                      else
                #endif
                	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
                    }
                
                #if __cplusplus < 201103L
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  typedef typename iterator_traits<_ForwardIterator1>::value_type
                	    _ValueType1;
                	  _ValueType1 __tmp = *__a;
                	  *__a = *__b;
                	  *__b = __tmp;
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  swap(*__a, *__b);
                	}
                    };
                #endif // C++03
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @ingroup mutating_algorithms
                   *  @param  __a  An iterator.
                   *  @param  __b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline void
      953850 ->     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                
                #if __cplusplus < 201103L
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 187. iter_swap underspecified
                      swap(*__a, *__b);
                #endif
                    }
                
                  /**
                   *  @brief Swap the elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @return   An iterator equal to @p first2+(last1-first1).
                   *
                   *  Swaps each element in the range @p [first1,last1) with the
                   *  corresponding element in the range @p [first2,(last1-first1)).
                   *  The ranges must not overlap.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator2
                    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		_ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	std::iter_swap(__first1, __first2);
                      return __first2;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
     3102080 ->     min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
     1281040 ->     max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the __normal_iterator wrapper. See copy, fill, ...
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
    10489615 ->     __niter_base(_Iterator __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it; }
                
                  template<typename _Ite, typename _Seq>
                    _Ite
                    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
                		 std::random_access_iterator_tag>&);
                
                  // Reverse the __niter_base transformation to get a
                  // __normal_iterator back again (this assumes that __normal_iterator
                  // is only used to wrap random access iterators, like pointers).
                  template<typename _From, typename _To>
                    _GLIBCXX20_CONSTEXPR
                    inline _From
     2322560 ->     __niter_wrap(_From __from, _To __res)
                    { return __from + (__res - std::__niter_base(__from)); }
                
                  // No need to wrap, iterator already has the right type.
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
     2803615 ->     __niter_wrap(const _Iterator&, _Iterator __res)
                    { return __res; }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool _IsMove, bool _IsSimple, typename _Category>
                    struct __copy_move
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move<true, false, _Category>
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = std::move(*__first);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move<false, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move<true, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = std::move(*__first);
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	_GLIBCXX20_CONSTEXPR
                	static _Tp*
     5125557 -> 	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
                	  return __result + _Num;
                	}
                    };
                
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    struct _Deque_iterator;
                
                  struct _Bit_iterator;
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                  // Helpers for streambuf iterators (either istream or ostream).
                  // NB: avoid including <iosfwd>, relatively large.
                  template<typename _CharT>
                    struct char_traits;
                
                  template<typename _CharT, typename _Traits>
                    class istreambuf_iterator;
                
                  template<typename _CharT, typename _Traits>
                    class ostreambuf_iterator;
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(_CharT*, _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(const _CharT*, const _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                				    _CharT*>::__type
                    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<
                      __is_char<_CharT>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
                    __copy_move_a2(
                	istreambuf_iterator<_CharT, char_traits<_CharT> >,
                	istreambuf_iterator<_CharT, char_traits<_CharT> >,
                	_GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
     5125557 ->     __copy_move_a2(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                #ifdef __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return std::__copy_move<_IsMove, false, _Category>::
                	  __copy_m(__first, __last, __result);
                #endif
                      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
                			      _Category>::__copy_m(__first, __last, __result);
                    }
                
                  template<bool _IsMove,
                	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
                    _OI
                    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		   _OI);
                
                  template<bool _IsMove,
                	   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
                    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>
                    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                		   _GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                		   _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);
                
                  template<bool _IsMove, typename _II, typename _Tp>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
                    __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
     5125557 ->     __copy_move_a1(_II __first, _II __last, _OI __result)
                    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
     5125557 ->     __copy_move_a(_II __first, _II __last, _OI __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
                					     std::__niter_base(__last),
                					     std::__niter_base(__result)));
                    }
                
                  template<bool _IsMove,
                	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
                    _OI
                    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		  _OI);
                
                  template<bool _IsMove,
                	   typename _II, typename _Ite, typename _Seq, typename _Cat>
                    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
                    __copy_move_a(_II, _II,
                		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);
                
                  template<bool _IsMove,
                	   typename _IIte, typename _ISeq, typename _ICat,
                	   typename _OIte, typename _OSeq, typename _OCat>
                    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
                    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
                
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
                	       bool)
                    {
                      if (__n > 0)
                	{
                	  while (true)
                	    {
                	      *__result = *__first;
                	      ++__result;
                	      if (--__n > 0)
                		++__first;
                	      else
                		break;
                	    }
                	}
                      return __result;
                    }
                
                  template<typename _CharT, typename _Size>
                    typename __gnu_cxx::__enable_if<
                      __is_char<_CharT>::__value, _CharT*>::__type
                    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                	       _Size, _CharT*, bool);
                
                  template<typename _CharT, typename _Size>
                    typename __gnu_cxx::__enable_if<
                      __is_char<_CharT>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
                    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
                	       _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>,
                	       bool);
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
     5125557 ->     copy(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a<__is_move_iterator<_II>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the move_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
                    move(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a<true>(std::__miter_base(__first),
                				      std::__miter_base(__last), __result);
                    }
                
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                #endif
                
                  template<bool _IsMove, bool _IsSimple, typename _Category>
                    struct __copy_move_backward
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move_backward<true, false, _Category>
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move_backward<false, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type
                	    __n = __last - __first;
                	  for (; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move_backward<true, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
         618 -> 	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type
                	    __n = __last - __first;
                	  for (; __n > 0; --__n)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	_GLIBCXX20_CONSTEXPR
                	static _Tp*
                	__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
         618 ->     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                #ifdef __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return std::__copy_move_backward<_IsMove, false, _Category>::
                	  __copy_move_b(__first, __last, __result);
                #endif
                      return std::__copy_move_backward<_IsMove,
                				       __memcpyable<_BI2, _BI1>::__value,
                				       _Category>::__copy_move_b(__first,
                								 __last,
                								 __result);
                    }
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
         618 ->     __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
                    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }
                
                  template<bool _IsMove,
                	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
                    _OI
                    __copy_move_backward_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                			    _OI);
                
                  template<bool _IsMove,
                	   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
                    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>
                    __copy_move_backward_a1(
                			_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                			_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                			_GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);
                
                  template<bool _IsMove, typename _II, typename _Tp>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
                    __copy_move_backward_a1(_II, _II,
                			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
         618 ->     __copy_move_backward_a(_II __first, _II __last, _OI __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_backward_a1<_IsMove>
                		  (std::__niter_base(__first), std::__niter_base(__last),
                		   std::__niter_base(__result)));
                    }
                
                  template<bool _IsMove,
                	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
                    _OI
                    __copy_move_backward_a(
                		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		_OI);
                
                  template<bool _IsMove,
                	   typename _II, typename _Ite, typename _Seq, typename _Cat>
                    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
                    __copy_move_backward_a(_II, _II,
                		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);
                
                  template<bool _IsMove,
                	   typename _IIte, typename _ISeq, typename _ICat,
                	   typename _OIte, typename _OSeq, typename _OCat>
                    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
                    __copy_move_backward_a(
                		const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
                    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as move, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use move instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
         618 ->     move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
                					       std::__miter_base(__last),
                					       __result);
                    }
                
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                #endif
                
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
                    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
                	      const _Tp& __value)
                    {
                      for (; __first != __last; ++__first)
                	*__first = __value;
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
      360000 ->     __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
                	      const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __first != __last; ++__first)
                	*__first = __tmp;
                    }
                
                  // Specialization: for char types we can use memset.
                  template<typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
                    {
                      const _Tp __tmp = __c;
                #if __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	{
                	  for (; __first != __last; ++__first)
                	    *__first = __tmp;
                	  return;
                	}
                #endif
                      if (const size_t __len = __last - __first)
                	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
                    }
                
                  template<typename _Ite, typename _Cont, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
                	      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
                	      const _Tp& __value)
                    { std::__fill_a1(__first.base(), __last.base(), __value); }
                
                  template<typename _Tp, typename _VTp>
                    void
                    __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
                	      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
                	      const _VTp&);
                
                  void
                  __fill_a1(_GLIBCXX_STD_C::_Bit_iterator, _GLIBCXX_STD_C::_Bit_iterator,
                	    const bool&);
                
                  template<typename _FIte, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline void
      360000 ->     __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
                    { std::__fill_a1(__first, __last, __value); }
                
                  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
                    void
                    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                	     const _Tp&);
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      std::__fill_a(__first, __last, __value);
                    }
                
                  // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
                  inline _GLIBCXX_CONSTEXPR int
                  __size_to_integer(int __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __size_to_integer(unsigned __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR long
                  __size_to_integer(long __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned long
      360000 ->   __size_to_integer(unsigned long __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(long long __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __size_to_integer(unsigned long long __n) { return __n; }
                
                #if defined(__GLIBCXX_TYPE_INT_N_0)
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_0
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_1)
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_1
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_1 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_1
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_1 __n) { return __n; }
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_2)
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_2
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_2 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_2
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_2 __n) { return __n; }
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_3)
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_3
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_3 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_3
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_3 __n) { return __n; }
                #endif
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(float __n) { return (long long)__n; }
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(double __n) { return (long long)__n; }
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(long double __n) { return (long long)__n; }
                #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(__float128 __n) { return (long long)__n; }
                #endif
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      for (; __n > 0; --__n, (void) ++__first)
                	*__first = __value;
                      return __first;
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __n > 0; --__n, (void) ++__first)
                	*__first = __tmp;
                      return __first;
                    }
                
                  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
                	   typename _Tp>
                    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
                    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
                	       _Size __n, const _Tp& __value,
                	       std::input_iterator_tag);
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
                	       std::output_iterator_tag)
                    {
                #if __cplusplus >= 201103L
                      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
                #endif
                      return __fill_n_a1(__first, __n, __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
                	       std::input_iterator_tag)
                    {
                #if __cplusplus >= 201103L
                      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
                #endif
                      return __fill_n_a1(__first, __n, __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
      360000 ->     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
                	       std::random_access_iterator_tag)
                    {
                #if __cplusplus >= 201103L
                      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
                #endif
                      if (__n <= 0)
                	return __first;
                
                      __glibcxx_requires_can_increment(__first, __n);
                
                      std::__fill_a(__first, __first + __n, __value);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An output iterator.
                   *  @param  __n      The count of copies to perform.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                   *
                   *  If @p __n is negative, the function does nothing.
                  */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 865. More algorithms that throw away information
                  // DR 426. search_n(), fill_n(), and generate_n() with negative n
                  template<typename _OI, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
      360000 ->     fill_n(_OI __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                
                      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
                			       std::__iterator_category(__first));
                    }
                
                  template<bool _BoolType>
                    struct __equal
                    {
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	equal(_II1 __first1, _II1 __last1, _II2 __first2)
                	{
                	  for (; __first1 != __last1; ++__first1, (void) ++__first2)
                	    if (!(*__first1 == *__first2))
                	      return false;
                	  return true;
                	}
                    };
                
                  template<>
                    struct __equal<true>
                    {
                      template<typename _Tp>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                	{
                	  if (const size_t __len = (__last1 - __first1))
                	    return !std::__memcmp(__first1, __first2, __len);
                	  return true;
                	}
                    };
                
                  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value, bool>::__type
                    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		 _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		 _II);
                
                  template<typename _Tp1, typename _Ref1, typename _Ptr1,
                	   typename _Tp2, typename _Ref2, typename _Ptr2>
                    bool
                    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                		 _GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                		 _GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
                
                  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value, bool>::__type
                    __equal_aux1(_II, _II,
                		_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>);
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      const bool __simple = ((__is_integer<_ValueType1>::__value
                			      || __is_pointer<_ValueType1>::__value)
                			     && __memcmpable<_II1, _II2>::__value);
                      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                    }
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      return std::__equal_aux1(std::__niter_base(__first1),
                			       std::__niter_base(__last1),
                			       std::__niter_base(__first2));
                    }
                
                  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
                    bool
                    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		_II2);
                
                  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
                    bool
                    __equal_aux(_II1, _II1,
                		const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);
                
                  template<typename _II1, typename _Seq1, typename _Cat1,
                	   typename _II2, typename _Seq2, typename _Cat2>
                    bool
                    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);
                
                  template<typename, typename>
                    struct __lc_rai
                    {
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static _II1
                	__newlast1(_II1, _II1 __last1, _II2, _II2)
                	{ return __last1; }
                
                      template<typename _II>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	__cnd2(_II __first, _II __last)
                	{ return __first != __last; }
                    };
                
                  template<>
                    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                    {
                      template<typename _RAI1, typename _RAI2>
                	_GLIBCXX20_CONSTEXPR
                	static _RAI1
                	__newlast1(_RAI1 __first1, _RAI1 __last1,
                		   _RAI2 __first2, _RAI2 __last2)
                	{
                	  const typename iterator_traits<_RAI1>::difference_type
                	    __diff1 = __last1 - __first1;
                	  const typename iterator_traits<_RAI2>::difference_type
                	    __diff2 = __last2 - __first2;
                	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                	}
                
                      template<typename _RAI>
                	static _GLIBCXX20_CONSTEXPR bool
                	__cnd2(_RAI, _RAI)
                	{ return true; }
                    };
                
                  template<typename _II1, typename _II2, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2,
                				   _Compare __comp)
                    {
                      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
                
                      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	   ++__first1, (void)++__first2)
                	{
                	  if (__comp(__first1, __first2))
                	    return true;
                	  if (__comp(__first2, __first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  template<bool _BoolType>
                    struct __lexicographical_compare
                    {
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                	{
                	  using __gnu_cxx::__ops::__iter_less_iter;
                	  return std::__lexicographical_compare_impl(__first1, __last1,
                						     __first2, __last2,
                						     __iter_less_iter());
                	}
                
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static int
                	__3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                	{
                	  while (__first1 != __last1)
                	    {
                	      if (__first2 == __last2)
                		return +1;
                	      if (*__first1 < *__first2)
                		return -1;
                	      if (*__first2 < *__first1)
                		return +1;
                	      ++__first1;
                	      ++__first2;
                	    }
                	  return int(__first2 == __last2) - 1;
                	}
                    };
                
                  template<>
                    struct __lexicographical_compare<true>
                    {
                      template<typename _Tp, typename _Up>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	__lc(const _Tp* __first1, const _Tp* __last1,
                	     const _Up* __first2, const _Up* __last2)
                	{ return __3way(__first1, __last1, __first2, __last2) < 0; }
                
                      template<typename _Tp, typename _Up>
                	_GLIBCXX20_CONSTEXPR
                	static ptrdiff_t
                	__3way(const _Tp* __first1, const _Tp* __last1,
                	       const _Up* __first2, const _Up* __last2)
                	{
                	  const size_t __len1 = __last1 - __first1;
                	  const size_t __len2 = __last2 - __first2;
                	  if (const size_t __len = std::min(__len1, __len2))
                	    if (int __result = std::__memcmp(__first1, __first2, __len))
                	      return __result;
                	  return ptrdiff_t(__len1 - __len2);
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple =
                	(__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
                	 && __is_pointer<_II1>::__value
                	 && __is_pointer<_II2>::__value
                #if __cplusplus > 201703L && __cpp_lib_concepts
                	 // For C++20 iterator_traits<volatile T*>::value_type is non-volatile
                	 // so __is_byte<T> could be true, but we can't use memcmp with
                	 // volatile data.
                	 && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>
                	 && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>
                #endif
                	 );
                
                      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                							    __first2, __last2);
                    }
                
                  template<typename _Tp1, typename _Ref1, typename _Ptr1,
                	   typename _Tp2>
                    bool
                    __lexicographical_compare_aux1(
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_Tp2*, _Tp2*);
                
                  template<typename _Tp1,
                	   typename _Tp2, typename _Ref2, typename _Ptr2>
                    bool
                    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
                
                  template<typename _Tp1, typename _Ref1, typename _Ptr1,
                	   typename _Tp2, typename _Ref2, typename _Ptr2>
                    bool
                    __lexicographical_compare_aux1(
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                				  _II2 __first2, _II2 __last2)
                    {
                      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
                						 std::__niter_base(__last1),
                						 std::__niter_base(__first2),
                						 std::__niter_base(__last2));
                    }
                
                  template<typename _Iter1, typename _Seq1, typename _Cat1,
                	   typename _II2>
                    bool
                    __lexicographical_compare_aux(
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		_II2, _II2);
                
                  template<typename _II1,
                	   typename _Iter2, typename _Seq2, typename _Cat2>
                    bool
                    __lexicographical_compare_aux(
                		_II1, _II1,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);
                
                  template<typename _Iter1, typename _Seq1, typename _Cat1,
                	   typename _Iter2, typename _Seq2, typename _Cat2>
                    bool
                    __lexicographical_compare_aux(
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the first position in which @a val could be inserted
                   *         without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @a val, or end() if every element is less than
                   *                  @a val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val());
                    }
                
                  /// This is a helper function for the sort routines and for random.tcc.
                  //  Precondition: __n > 0.
                  inline _GLIBCXX_CONSTEXPR int
                  __lg(int __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __lg(unsigned __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long
                  __lg(long __n)
         300 ->   { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __lg(unsigned long __n)
                  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __lg(long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __lg(unsigned long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_can_increment_range(__first1, __last1, __first2);
                
                      return std::__equal_aux(__first1, __last1, __first2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return true;
                    }
                
                #if __cplusplus >= 201103L
                  // 4-iterator version of std::equal<It1, It2> for use in C++11.
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!(*__first1 == *__first2))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                
                  // 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.
                  template<typename _II1, typename _II2, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
                				       __binary_pred);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                #endif // C++11
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_robust_nonmodifying_seq_ops 201304
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2,
                				      __binary_pred);
                    }
                #endif // C++14
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  <em>Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                #endif
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_aux(__first1, __last1,
                						__first2, __last2);
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexicographical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _II1, typename _II2, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_impl
                	(__first1, __last1, __first2, __last2,
                	 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cpp_lib_three_way_comparison
                  // Iter points to a contiguous range of unsigned narrow character type
                  // or std::byte, suitable for comparison by memcmp.
                  template<typename _Iter>
                    concept __is_byte_iter = contiguous_iterator<_Iter>
                      && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;
                
                  // Return a struct with two members, initialized to the smaller of x and y
                  // (or x if they compare equal) and the result of the comparison x <=> y.
                  template<typename _Tp>
                    constexpr auto
                    __min_cmp(_Tp __x, _Tp __y)
                    {
                      struct _Res {
                	_Tp _M_min;
                	decltype(__x <=> __y) _M_cmp;
                      };
                      auto __c = __x <=> __y;
                      if (__c > 0)
                	return _Res{__y, __c};
                      return _Res{__x, __c};
                    }
                
                  /**
                   *  @brief Performs dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The comparison category that `__comp(*__first1, *__first2)`
                   *		returns.
                  */
                  template<typename _InputIter1, typename _InputIter2, typename _Comp>
                    constexpr auto
                    lexicographical_compare_three_way(_InputIter1 __first1,
                				      _InputIter1 __last1,
                				      _InputIter2 __first2,
                				      _InputIter2 __last2,
                				      _Comp __comp)
                    -> decltype(__comp(*__first1, *__first2))
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                #if __cpp_lib_is_constant_evaluated
                      using _Cat = decltype(__comp(*__first1, *__first2));
                      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);
                
                      if (!std::is_constant_evaluated())
                	if constexpr (same_as<_Comp, __detail::_Synth3way>
                		      || same_as<_Comp, compare_three_way>)
                	  if constexpr (__is_byte_iter<_InputIter1>)
                	    if constexpr (__is_byte_iter<_InputIter2>)
                	      {
                		const auto [__len, __lencmp] = _GLIBCXX_STD_A::
                		  __min_cmp(__last1 - __first1, __last2 - __first2);
                		if (__len)
                		  {
                		    const auto __c
                		      = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;
                		    if (__c != 0)
                		      return __c;
                		  }
                		return __lencmp;
                	      }
                #endif // is_constant_evaluated
                      while (__first1 != __last1)
                	{
                	  if (__first2 == __last2)
                	    return strong_ordering::greater;
                	  if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
                	    return __cmp;
                	  ++__first1;
                	  ++__first2;
                	}
                      return (__first2 == __last2) <=> true; // See PR 94006
                    }
                
                  template<typename _InputIter1, typename _InputIter2>
                    constexpr auto
                    lexicographical_compare_three_way(_InputIter1 __first1,
                				      _InputIter1 __last1,
                				      _InputIter2 __first2,
                				      _InputIter2 __last2)
                    {
                      return _GLIBCXX_STD_A::
                	lexicographical_compare_three_way(__first1, __last1, __first2, __last2,
                					  compare_three_way{});
                    }
                #endif // three_way_comparison
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                	__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                #if __cplusplus > 201103L
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __first2 != __last2
                	     && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_ALGO
                
                  /// This is an overload used by find algos for the Input Iterator case.
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    __find_if(_InputIterator __first, _InputIterator __last,
                	      _Predicate __pred, input_iterator_tag)
                    {
                      while (__first != __last && !__pred(__first))
                	++__first;
                      return __first;
                    }
                
                  /// This is an overload used by find algos for the RAI case.
                  template<typename _RandomAccessIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
                    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	      _Predicate __pred, random_access_iterator_tag)
                    {
                      typename iterator_traits<_RandomAccessIterator>::difference_type
                	__trip_count = (__last - __first) >> 2;
                
                      for (; __trip_count > 0; --__trip_count)
                	{
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	}
                
                      switch (__last - __first)
                	{
                	case 3:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	  // FALLTHRU
                	case 2:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	  // FALLTHRU
                	case 1:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	  // FALLTHRU
                	case 0:
                	default:
                	  return __last;
                	}
                    }
                
                  template<typename _Iterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
                    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
                    {
                      return __find_if(__first, __last, __pred,
                		       std::__iterator_category(__first));
                    }
                
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
                    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    {
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      for (; __first != __last; ++__first)
                	if (__pred(__first))
                	  ++__n;
                      return __n;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		     _ForwardIterator2 __first2, _BinaryPredicate __pred)
                    {
                      // Efficiently compare identical prefixes:  O(N) if sequences
                      // have the same elements in the same order.
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!__pred(__first1, __first2))
                	  break;
                
                      if (__first1 == __last1)
                	return true;
                
                      // Establish __last2 assuming equal ranges by iterating over the
                      // rest of the list.
                      _ForwardIterator2 __last2 = __first2;
                      std::advance(__last2, std::distance(__first1, __last1));
                      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                	{
                	  if (__scan != std::__find_if(__first1, __scan,
                			  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                	    continue; // We've seen this one before.
                
                	  auto __matches
                	    = std::__count_if(__first2, __last2,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
                	  if (0 == __matches ||
                	      std::__count_if(__scan, __last1,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
                	      != __matches)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __first2 + (__last1 - __first1)), beginning with
                   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
                   *          returns true; otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                		typename iterator_traits<_ForwardIterator1>::value_type,
                		typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__is_permutation(__first1, __last1, __first2,
                				   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                #endif // C++11
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                // NB: This file is included within many other C++ includes, as a way
                // of getting the base algorithms. So, make sure that parallel bits
                // come in too if requested.
                #ifdef _GLIBCXX_PARALLEL
                # include <parallel/algobase.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      313   10489615
      420    5125557
      486    5125557
      521    5125557
      527    5125557
      611    5125557
      230    3102080
      335    2803615
      328    2322560
      254    1281040

Execution Summary:

       22   Executable lines in this file
       22   Lines executed
   100.00   Percent of the file executed

 48383935   Total number of line executions
2199269.77   Average executions per line


*** File /usr/include/c++/11/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard.
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef _Tp        value_type;
                      typedef std::size_t     size_type;
                      typedef std::ptrdiff_t  difference_type;
                #if __cplusplus <= 201703L
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef new_allocator<_Tp1> other; };
                #endif
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
                      _GLIBCXX20_CONSTEXPR
     1263004 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      _GLIBCXX20_CONSTEXPR
     5247230 ->       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
                	new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
                #if __cplusplus <= 201703L
     6510234 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                #endif
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      _GLIBCXX_NODISCARD _Tp*
     9841987 ->       allocate(size_type __n, const void* = static_cast<const void*>(0))
                      {
                	if (__builtin_expect(__n > this->_M_max_size(), false))
                	  {
                	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	    // 3190. allocator::allocate sometimes returns too little storage
                	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
                	      std::__throw_bad_array_new_length();
                	    std::__throw_bad_alloc();
                	  }
                
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
                	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
                	  }
                #endif
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
     9841987 ->       deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
                      {
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    ::operator delete(__p,
                # if __cpp_sized_deallocation
                			      __t * sizeof(_Tp),
                # endif
                			      std::align_val_t(alignof(_Tp)));
                	    return;
                	  }
                #endif
                	::operator delete(__p
                #if __cpp_sized_deallocation
                			  , __t * sizeof(_Tp)
                #endif
                			 );
                      }
                
                #if __cplusplus <= 201703L
                      size_type
     2922080 ->       max_size() const _GLIBCXX_USE_NOEXCEPT
                      { return _M_max_size(); }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                	void
    16380392 -> 	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
     5397332 -> 	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void
                      construct(pointer __p, const _Tp& __val)
                      { ::new((void *)__p) _Tp(__val); }
                
                      void
                      destroy(pointer __p) { __p->~_Tp(); }
                #endif
                #endif // ! C++20
                
                      template<typename _Up>
                	friend _GLIBCXX20_CONSTEXPR bool
                	operator==(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return true; }
                
                #if __cpp_impl_three_way_comparison < 201907L
                      template<typename _Up>
                	friend _GLIBCXX20_CONSTEXPR bool
                	operator!=(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return false; }
                #endif
                
                    private:
                      _GLIBCXX_CONSTEXPR size_type
    12764067 ->       _M_max_size() const _GLIBCXX_USE_NOEXCEPT
                      {
                #if __PTRDIFF_MAX__ < __SIZE_MAX__
                	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
                #else
                	return std::size_t(-1) / sizeof(_Tp);
                #endif
                      }
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      154   16380392
      191   12764067
      103    9841987
      126    9841987
       89    6510234
      160    5397332
       82    5247230
      148    2922080
       79    1263004

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

 70168313   Total number of line executions
7796479.22   Average executions per line


*** File /usr/include/c++/11/bits/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/alloc_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOC_TRAITS_H
                #define _ALLOC_TRAITS_H 1
                
                #include <bits/stl_construct.h>
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                # include <bits/allocator.h>
                # include <bits/ptr_traits.h>
                # include <ext/numeric_traits.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201103L
                #define __cpp_lib_allocator_traits_is_always_equal 201411
                
                  struct __allocator_traits_base
                  {
                    template<typename _Tp, typename _Up, typename = void>
                      struct __rebind : __replace_first_arg<_Tp, _Up> { };
                
                    template<typename _Tp, typename _Up>
                      struct __rebind<_Tp, _Up,
                		      __void_t<typename _Tp::template rebind<_Up>::other>>
                      { using type = typename _Tp::template rebind<_Up>::other; };
                
                  protected:
                    template<typename _Tp>
                      using __pointer = typename _Tp::pointer;
                    template<typename _Tp>
                      using __c_pointer = typename _Tp::const_pointer;
                    template<typename _Tp>
                      using __v_pointer = typename _Tp::void_pointer;
                    template<typename _Tp>
                      using __cv_pointer = typename _Tp::const_void_pointer;
                    template<typename _Tp>
                      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
                    template<typename _Tp>
                      using __pocma = typename _Tp::propagate_on_container_move_assignment;
                    template<typename _Tp>
                      using __pocs = typename _Tp::propagate_on_container_swap;
                    template<typename _Tp>
                      using __equal = typename _Tp::is_always_equal;
                  };
                
                  template<typename _Alloc, typename _Up>
                    using __alloc_rebind
                      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
                
                  /**
                   * @brief  Uniform interface to all allocator types.
                   * @ingroup allocators
                  */
                  template<typename _Alloc>
                    struct allocator_traits : __allocator_traits_base
                    {
                      /// The allocator type
                      typedef _Alloc allocator_type;
                      /// The allocated type
                      typedef typename _Alloc::value_type value_type;
                
                      /**
                       * @brief   The allocator's pointer type.
                       *
                       * @c Alloc::pointer if that type exists, otherwise @c value_type*
                      */
                      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;
                
                    private:
                      // Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>
                      template<template<typename> class _Func, typename _Tp, typename = void>
                	struct _Ptr
                	{
                	  using type = typename pointer_traits<pointer>::template rebind<_Tp>;
                	};
                
                      template<template<typename> class _Func, typename _Tp>
                	struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
                	{
                	  using type = _Func<_Alloc>;
                	};
                
                      // Select _A2::difference_type or pointer_traits<_Ptr>::difference_type
                      template<typename _A2, typename _PtrT, typename = void>
                	struct _Diff
                	{ using type = typename pointer_traits<_PtrT>::difference_type; };
                
                      template<typename _A2, typename _PtrT>
                	struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
                	{ using type = typename _A2::difference_type; };
                
                      // Select _A2::size_type or make_unsigned<_DiffT>::type
                      template<typename _A2, typename _DiffT, typename = void>
                	struct _Size : make_unsigned<_DiffT> { };
                
                      template<typename _A2, typename _DiffT>
                	struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
                	{ using type = typename _A2::size_type; };
                
                    public:
                      /**
                       * @brief   The allocator's const pointer type.
                       *
                       * @c Alloc::const_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
                      */
                      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
                
                      /**
                       * @brief   The allocator's void pointer type.
                       *
                       * @c Alloc::void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<void> </tt>
                      */
                      using void_pointer = typename _Ptr<__v_pointer, void>::type;
                
                      /**
                       * @brief   The allocator's const void pointer type.
                       *
                       * @c Alloc::const_void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
                      */
                      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
                
                      /**
                       * @brief   The allocator's difference type
                       *
                       * @c Alloc::difference_type if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::difference_type </tt>
                      */
                      using difference_type = typename _Diff<_Alloc, pointer>::type;
                
                      /**
                       * @brief   The allocator's size type
                       *
                       * @c Alloc::size_type if that type exists, otherwise
                       * <tt> make_unsigned<difference_type>::type </tt>
                      */
                      using size_type = typename _Size<_Alloc, difference_type>::type;
                
                      /**
                       * @brief   How the allocator is propagated on copy assignment
                       *
                       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_copy_assignment
                	= __detected_or_t<false_type, __pocca, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on move assignment
                       *
                       * @c Alloc::propagate_on_container_move_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_move_assignment
                	= __detected_or_t<false_type, __pocma, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on swap
                       *
                       * @c Alloc::propagate_on_container_swap if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_swap
                	= __detected_or_t<false_type, __pocs, _Alloc>;
                
                      /**
                       * @brief   Whether all instances of the allocator type compare equal.
                       *
                       * @c Alloc::is_always_equal if that type exists,
                       * otherwise @c is_empty<Alloc>::type
                      */
                      using is_always_equal
                	= __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
                
                      template<typename _Tp>
                	using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
                      template<typename _Tp>
                	using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
                
                    private:
                      template<typename _Alloc2>
                	static constexpr auto
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
                	-> decltype(__a.allocate(__n, __hint))
                	{ return __a.allocate(__n, __hint); }
                
                      template<typename _Alloc2>
                	static constexpr pointer
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
                	{ return __a.allocate(__n); }
                
                      template<typename _Tp, typename... _Args>
                	struct __construct_helper
                	{
                	  template<typename _Alloc2,
                	    typename = decltype(std::declval<_Alloc2*>()->construct(
                		  std::declval<_Tp*>(), std::declval<_Args>()...))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Tp, typename... _Args>
                	using __has_construct
                	  = typename __construct_helper<_Tp, _Args...>::type;
                
                      template<typename _Tp, typename... _Args>
                	static _GLIBCXX14_CONSTEXPR _Require<__has_construct<_Tp, _Args...>>
                	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      template<typename _Tp, typename... _Args>
                	static _GLIBCXX14_CONSTEXPR
                	_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
                			       is_constructible<_Tp, _Args...>>>
                	_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
                	{
                #if __cplusplus <= 201703L
                	  ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
                #else
                	  std::construct_at(__p, std::forward<_Args>(__args)...);
                #endif
                	}
                
                      template<typename _Alloc2, typename _Tp>
                	static _GLIBCXX14_CONSTEXPR auto
                	_S_destroy(_Alloc2& __a, _Tp* __p, int)
                	noexcept(noexcept(__a.destroy(__p)))
                	-> decltype(__a.destroy(__p))
                	{ __a.destroy(__p); }
                
                      template<typename _Alloc2, typename _Tp>
                	static _GLIBCXX14_CONSTEXPR void
                	_S_destroy(_Alloc2&, _Tp* __p, ...)
                	noexcept(std::is_nothrow_destructible<_Tp>::value)
                	{ std::_Destroy(__p); }
                
                      template<typename _Alloc2>
                	static constexpr auto
                	_S_max_size(_Alloc2& __a, int)
                	-> decltype(__a.max_size())
                	{ return __a.max_size(); }
                
                      template<typename _Alloc2>
                	static constexpr size_type
                	_S_max_size(_Alloc2&, ...)
                	{
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 2466. allocator_traits::max_size() default behavior is incorrect
                	  return __gnu_cxx::__numeric_traits<size_type>::__max
                	    / sizeof(value_type);
                	}
                
                      template<typename _Alloc2>
                	static constexpr auto
                	_S_select(_Alloc2& __a, int)
                	-> decltype(__a.select_on_container_copy_construction())
                	{ return __a.select_on_container_copy_construction(); }
                
                      template<typename _Alloc2>
                	static constexpr _Alloc2
                	_S_select(_Alloc2& __a, ...)
                	{ return __a; }
                
                    public:
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
                      allocate(_Alloc& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
                       *  well-formed, otherwise returns @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
                      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
                      { return _S_allocate(__a, __n, __hint, 0); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static _GLIBCXX20_CONSTEXPR void
                      deallocate(_Alloc& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type `_Tp`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                       *  if that expression is well-formed, otherwise uses placement-new
                       *  to construct an object of type @a _Tp at location @a __p from the
                       *  arguments @a __args...
                      */
                      template<typename _Tp, typename... _Args>
                	static _GLIBCXX20_CONSTEXPR auto
                	construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(_S_construct(__a, __p,
                				       std::forward<_Args>(__args)...)))
                	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
                	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Tp
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p) if that expression is well-formed,
                       *  otherwise calls @c __p->~_Tp()
                      */
                      template<typename _Tp>
                	static _GLIBCXX20_CONSTEXPR void
                	destroy(_Alloc& __a, _Tp* __p)
                	noexcept(noexcept(_S_destroy(__a, __p, 0)))
                	{ _S_destroy(__a, __p, 0); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
                       *
                       *  Returns @c __a.max_size() if that expression is well-formed,
                       *  otherwise returns @c numeric_limits<size_type>::max()
                      */
                      static _GLIBCXX20_CONSTEXPR size_type
                      max_size(const _Alloc& __a) noexcept
                      { return _S_max_size(__a, 0); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
                       *
                       *  Returns @c __rhs.select_on_container_copy_construction() if that
                       *  expression is well-formed, otherwise returns @a __rhs
                      */
                      static _GLIBCXX20_CONSTEXPR _Alloc
                      select_on_container_copy_construction(const _Alloc& __rhs)
                      { return _S_select(__rhs, 0); }
                    };
                
                #if __cplusplus > 201703L
                # define __cpp_lib_constexpr_dynamic_alloc 201907L
                #endif
                
                  /// Partial specialization for std::allocator.
                  template<typename _Tp>
                    struct allocator_traits<allocator<_Tp>>
                    {
                      /// The allocator type
                      using allocator_type = allocator<_Tp>;
                
                      /// The allocated type
                      using value_type = _Tp;
                
                      /// The allocator's pointer type.
                      using pointer = _Tp*;
                
                      /// The allocator's const pointer type.
                      using const_pointer = const _Tp*;
                
                      /// The allocator's void pointer type.
                      using void_pointer = void*;
                
                      /// The allocator's const void pointer type.
                      using const_void_pointer = const void*;
                
                      /// The allocator's difference type
                      using difference_type = std::ptrdiff_t;
                
                      /// The allocator's size type
                      using size_type = std::size_t;
                
                      /// How the allocator is propagated on copy assignment
                      using propagate_on_container_copy_assignment = false_type;
                
                      /// How the allocator is propagated on move assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      /// How the allocator is propagated on swap
                      using propagate_on_container_swap = false_type;
                
                      /// Whether all instances of the allocator type compare equal.
                      using is_always_equal = true_type;
                
                      template<typename _Up>
                	using rebind_alloc = allocator<_Up>;
                
                      template<typename _Up>
                	using rebind_traits = allocator_traits<allocator<_Up>>;
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
     9841987 ->       allocate(allocator_type& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt>
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
                      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
                      {
                #if __cplusplus <= 201703L
                	return __a.allocate(__n, __hint);
                #else
                	return __a.allocate(__n);
                #endif
                      }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static _GLIBCXX20_CONSTEXPR void
     9841987 ->       deallocate(allocator_type& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type `_Up`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for
                       *	       an object of type `_Up`.
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`
                       *  in C++11, C++14 and C++17. Changed in C++20 to call
                       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.
                      */
                      template<typename _Up, typename... _Args>
                	static _GLIBCXX20_CONSTEXPR void
    16380392 -> 	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
                		  _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{
                #if __cplusplus <= 201703L
                	  __a.construct(__p, std::forward<_Args>(__args)...);
                #else
                	  std::construct_at(__p, std::forward<_Args>(__args)...);
                #endif
                	}
                
                      /**
                       *  @brief  Destroy an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p).
                      */
                      template<typename _Up>
                	static _GLIBCXX20_CONSTEXPR void
     5397332 -> 	destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
                	noexcept(is_nothrow_destructible<_Up>::value)
                	{
                #if __cplusplus <= 201703L
                	  __a.destroy(__p);
                #else
                	  std::destroy_at(__p);
                #endif
                	}
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size()
                      */
                      static _GLIBCXX20_CONSTEXPR size_type
     2922080 ->       max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
                      {
                #if __cplusplus <= 201703L
                	return __a.max_size();
                #else
                	return size_t(-1) / sizeof(value_type);
                #endif
                      }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs
                      */
                      static _GLIBCXX20_CONSTEXPR allocator_type
     2263615 ->       select_on_container_copy_construction(const allocator_type& __rhs)
                      { return __rhs; }
                    };
                
                #if __cplusplus < 201703L
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
                    { __one = __two; }
                
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
                    { }
                #endif
                
                  template<typename _Alloc>
                    _GLIBCXX14_CONSTEXPR inline void
       ##### ->     __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
                #if __cplusplus >= 201703L
                      if constexpr (__pocca::value)
                	__one = __two;
                #else
                      __do_alloc_on_copy(__one, __two, __pocca());
                #endif
                    }
                
                  template<typename _Alloc>
                    constexpr _Alloc
                    __alloc_on_copy(const _Alloc& __a)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      return __traits::select_on_container_copy_construction(__a);
                    }
                
                #if __cplusplus < 201703L
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
                    { __one = std::move(__two); }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
                    { }
                #endif
                
                  template<typename _Alloc>
                    _GLIBCXX14_CONSTEXPR inline void
                    __alloc_on_move(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_move_assignment __pocma;
                #if __cplusplus >= 201703L
                      if constexpr (__pocma::value)
                	__one = std::move(__two);
                #else
                      __do_alloc_on_move(__one, __two, __pocma());
                #endif
                    }
                
                #if __cplusplus < 201703L
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
                    {
                      using std::swap;
                      swap(__one, __two);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
                    { }
                #endif
                
                  template<typename _Alloc>
                    _GLIBCXX14_CONSTEXPR inline void
                    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_swap __pocs;
                #if __cplusplus >= 201703L
                      if constexpr (__pocs::value)
                	{
                	  using std::swap;
                	  swap(__one, __two);
                	}
                #else
                      __do_alloc_on_swap(__one, __two, __pocs());
                #endif
                    }
                
                  template<typename _Alloc, typename _Tp,
                	   typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
                	   typename = void>
                    struct __is_alloc_insertable_impl
                    : false_type
                    { };
                
                  template<typename _Alloc, typename _Tp, typename _ValueT>
                    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
                      __void_t<decltype(allocator_traits<_Alloc>::construct(
                		   std::declval<_Alloc&>(), std::declval<_ValueT*>(),
                		   std::declval<_Tp>()))>>
                    : true_type
                    { };
                
                  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_copy_insertable
                    : __is_alloc_insertable_impl<_Alloc,
                				 typename _Alloc::value_type const&>::type
                    { };
                
                  // std::allocator<_Tp> just requires CopyConstructible
                  template<typename _Tp>
                    struct __is_copy_insertable<allocator<_Tp>>
                    : is_copy_constructible<_Tp>
                    { };
                
                  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_move_insertable
                    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
                    { };
                
                  // std::allocator<_Tp> just requires MoveConstructible
                  template<typename _Tp>
                    struct __is_move_insertable<allocator<_Tp>>
                    : is_move_constructible<_Tp>
                    { };
                
                  // Trait to detect Allocator-like types.
                  template<typename _Alloc, typename = void>
                    struct __is_allocator : false_type { };
                
                  template<typename _Alloc>
                    struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type,
                	       decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
                    : true_type { };
                
                  template<typename _Alloc>
                    using _RequireAllocator
                      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
                
                  template<typename _Alloc>
                    using _RequireNotAllocator
                      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
                
                #if __cpp_concepts >= 201907L
                  template<typename _Alloc>
                    concept __allocator_like = requires (_Alloc& __a) {
                      typename _Alloc::value_type;
                      __a.deallocate(__a.allocate(1u), 1u);
                    };
                #endif
                #endif // C++11
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * non-default allocators we do not optimize away invocation of
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      for (; __first != __last; ++__first)
                #if __cplusplus < 201103L
                	__alloc.destroy(std::__addressof(*__first));
                #else
                	allocator_traits<_Allocator>::destroy(__alloc,
                					      std::__addressof(*__first));
                #endif
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
     6208601 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                #endif // _ALLOC_TRAITS_H


Top 10 Lines:

     Line      Count

      507   16380392
      459    9841987
      491    9841987
      743    6208601
      527    5397332
      543    2922080
      558    2263615

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

 52855994   Total number of line executions
6606999.25   Average executions per line


*** File /usr/include/c++/11/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _STL_ITERATOR_H
                #define _STL_ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <bits/stl_iterator_base_types.h>
                #include <ext/type_traits.h>
                #include <bits/move.h>
                #include <bits/ptr_traits.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                
                #if __cplusplus > 201703L
                # define __cpp_lib_array_constexpr 201811L
                # define __cpp_lib_constexpr_iterator 201811L
                #elif __cplusplus == 201703L
                # define __cpp_lib_array_constexpr 201803L
                #endif
                
                #if __cplusplus > 201703L
                # include <compare>
                # include <new>
                # include <bits/exception_defines.h>
                # include <bits/iterator_concepts.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                  namespace __detail
                  {
                    // Weaken iterator_category _Cat to _Limit if it is derived from that,
                    // otherwise use _Otherwise.
                    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
                      using __clamp_iter_cat
                	= conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
                  }
                #endif
                
                  // 24.4.1 Reverse iterators
                  /**
                   *  Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  <em>This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array.</em> [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                      template<typename _Iter>
                	friend class reverse_iterator;
                
                #if __cpp_lib_concepts
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>
                      template<typename _Iter>
                	static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
                	    && convertible_to<const _Iter&, _Iterator>;
                #endif
                
                    protected:
                      _Iterator current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      typedef typename __traits_type::pointer		pointer;
                      typedef typename __traits_type::reference		reference;
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      using iterator_concept
                	= conditional_t<random_access_iterator<_Iterator>,
                			random_access_iterator_tag,
                			bidirectional_iterator_tag>;
                      using iterator_category
                	= __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
                				     random_access_iterator_tag>;
                #endif
                
                      /**
                       *  The default constructor value-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      // 1012. reverse_iterator default ctor should value initialize
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit _GLIBCXX17_CONSTEXPR
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                #if __cplusplus >= 201103L
                      reverse_iterator& operator=(const reverse_iterator&) = default;
                #endif
                
                      /**
                       *  A %reverse_iterator across other types can be copied if the
                       *  underlying %iterator can be converted to the type of @c current.
                      */
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                #endif
                	_GLIBCXX17_CONSTEXPR
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.current) { }
                
                #if __cplusplus >= 201103L
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                	  && assignable_from<_Iterator&, const _Iter&>
                #endif
                	_GLIBCXX17_CONSTEXPR
                	reverse_iterator&
                	operator=(const reverse_iterator<_Iter>& __x)
                	{
                	  current = __x.current;
                	  return *this;
                	}
                #endif
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      _GLIBCXX17_CONSTEXPR iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  A reference to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                       *
                       *  @warning This implementation requires that for an iterator of the
                       *           underlying iterator type, @c x, a reference obtained by
                       *           @c *x remains valid after @c x has been modified or
                       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  A pointer to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                      */
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                #if __cplusplus > 201703L && __cpp_concepts >= 201907L
                      requires is_pointer_v<_Iterator>
                	|| requires(const _Iterator __i) { __i.operator->(); }
                #endif
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 1052. operator-> should also support smart pointers
                	_Iterator __tmp = current;
                	--__tmp;
                	return _S_to_pointer(__tmp);
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  The original value of @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator with the previous value of @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator backwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator forwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  The value at @c current - @a __n - 1
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      friend constexpr iter_rvalue_reference_t<_Iterator>
                      iter_move(const reverse_iterator& __i)
                      noexcept(is_nothrow_copy_constructible_v<_Iterator>
                	       && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))
                      {
                	auto __tmp = __i.base();
                	return ranges::iter_move(--__tmp);
                      }
                
                      template<indirectly_swappable<_Iterator> _Iter2>
                	friend constexpr void
                	iter_swap(const reverse_iterator& __x,
                		  const reverse_iterator<_Iter2>& __y)
                	noexcept(is_nothrow_copy_constructible_v<_Iterator>
                		 && is_nothrow_copy_constructible_v<_Iter2>
                		 && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),
                					       --std::declval<_Iter2&>())))
                	{
                	  auto __xtmp = __x.base();
                	  auto __ytmp = __y.base();
                	  ranges::iter_swap(--__xtmp, --__ytmp);
                	}
                #endif
                
                    private:
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR _Tp*
                	_S_to_pointer(_Tp* __p)
                        { return __p; }
                
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR pointer
                	_S_to_pointer(_Tp __t)
                        { return __t.operator->(); }
                    };
                
                  ///@{
                  /**
                   *  @param  __x  A %reverse_iterator.
                   *  @param  __y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward comparisons to their underlying base()
                   *  iterators.
                   *
                  */
                #if __cplusplus <= 201703L || ! defined __cpp_lib_concepts
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() > __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() != __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() >= __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() <= __y.base(); }
                #else // C++20
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }
                    { return __x.base() != __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }
                    { return __x.base() > __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }
                    { return __x.base() >= __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }
                    { return __x.base() <= __y.base(); }
                
                  template<typename _IteratorL,
                	   three_way_comparable_with<_IteratorL> _IteratorR>
                    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
                    operator<=>(const reverse_iterator<_IteratorL>& __x,
                		const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() <=> __x.base(); }
                #endif // C++20
                  ///@}
                
                #if __cplusplus < 201103L
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() - __x.base(); }
                #else
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 685. reverse_iterator/move_iterator difference has invalid signatures
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    -> decltype(__y.base() - __x.base())
                    { return __y.base() - __x.base(); }
                #endif
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                #if __cplusplus >= 201103L
                  // Same as C++14 make_reverse_iterator but used in C++11 mode too.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    __make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                
                # if __cplusplus >= 201402L
                #  define __cpp_lib_make_reverse_iterator 201402
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 2285. make_reverse_iterator
                  /// Generator function for reverse_iterator.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                
                #  if __cplusplus > 201703L && defined __cpp_lib_concepts
                  template<typename _Iterator1, typename _Iterator2>
                    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
                    inline constexpr bool
                    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
                			       reverse_iterator<_Iterator2>> = true;
                #  endif // C++20
                # endif // C++14
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    auto
                    __niter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
                    { return __make_reverse_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<reverse_iterator<_Iterator> >
                      : __is_move_iterator<_Iterator>
                    { };
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    auto
                    __miter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
                    { return __make_reverse_iterator(__miter_base(__it.base())); }
                #endif // C++11
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                #if __cplusplus > 201703L
                      using difference_type = ptrdiff_t;
                
                      constexpr back_insert_iterator() noexcept : container(nullptr) { }
                #endif
                
                      /// The only way to create this %iterator is with a container.
                      explicit _GLIBCXX20_CONSTEXPR
                      back_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                #if __cplusplus < 201103L
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                #else
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_back(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                #if __cplusplus > 201703L
                      using difference_type = ptrdiff_t;
                
                      constexpr front_insert_iterator() noexcept : container(nullptr) { }
                #endif
                
                      /// The only way to create this %iterator is with a container.
                      explicit _GLIBCXX20_CONSTEXPR
                      front_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                #if __cplusplus < 201103L
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                #else
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_front(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                #if __cplusplus > 201703L && defined __cpp_lib_concepts
                      using _Iter = std::__detail::__range_iter_t<_Container>;
                
                    protected:
                      _Container* container = nullptr;
                      _Iter iter = _Iter();
                #else
                      typedef typename _Container::iterator		_Iter;
                
                    protected:
                      _Container* container;
                      _Iter iter;
                #endif
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                #if __cplusplus > 201703L && defined __cpp_lib_concepts
                      using difference_type = ptrdiff_t;
                
                      insert_iterator() = default;
                #endif
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator(_Container& __x, _Iter __i)
                      : container(std::__addressof(__x)), iter(__i) {}
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                #if __cplusplus < 201103L
                      insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                #else
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	iter = container->insert(iter, std::move(__value));
                	++iter;
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param __x  A container of arbitrary type.
                   *  @param __i  An iterator into the container.
                   *  @return  An instance of insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                #if __cplusplus > 201703L && defined __cpp_lib_concepts
                  template<typename _Container>
                    constexpr insert_iterator<_Container>
                    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)
                    { return insert_iterator<_Container>(__x, __i); }
                #else
                  template<typename _Container>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, typename _Container::iterator __i)
                    { return insert_iterator<_Container>(__x, __i); }
                #endif
                
                  /// @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // This iterator adapter is @a normal in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef std::iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type 	difference_type;
                      typedef typename __traits_type::reference 	reference;
                      typedef typename __traits_type::pointer   	pointer;
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      using iterator_concept = std::__detail::__iter_concept<_Iterator>;
                #endif
                
                      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
                      : _M_current(_Iterator()) { }
                
                      explicit _GLIBCXX20_CONSTEXPR
    22429990 ->       __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
                      : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        _GLIBCXX20_CONSTEXPR
                        __normal_iterator(const __normal_iterator<_Iter,
                			  typename __enable_if<
                      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      _GLIBCXX20_CONSTEXPR
                      reference
    21525272 ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *_M_current; }
                
                      _GLIBCXX20_CONSTEXPR
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
    12782173 ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	++_M_current;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
                      operator++(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
     2132368 ->       operator--() _GLIBCXX_NOEXCEPT
                      {
                	--_M_current;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
                      operator--(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      _GLIBCXX20_CONSTEXPR
                      reference
                      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return _M_current[__n]; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
                      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current += __n; return *this; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
     3135299 ->       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current + __n); }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
                      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current -= __n; return *this; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
      330407 ->       operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current - __n); }
                
                      _GLIBCXX20_CONSTEXPR
                      const _Iterator&
    45478318 ->       base() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                #if __cpp_lib_three_way_comparison
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    requires requires (_IteratorL __lhs, _IteratorR __rhs)
                    { { __lhs == __rhs } -> std::convertible_to<bool>; }
                    constexpr bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    noexcept(noexcept(__lhs.base() == __rhs.base()))
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
                    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                		const __normal_iterator<_IteratorR, _Container>& __rhs)
                    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
                    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
                #else
                   // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
         300 ->     operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
    11941083 ->     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
      517840 ->     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                #endif // three-way comparison
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                #if __cplusplus >= 201103L
                    // DR 685.
                    _GLIBCXX20_CONSTEXPR
                    inline auto
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
                    -> decltype(__lhs.base() - __rhs.base())
                #else
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                #endif
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline typename __normal_iterator<_Iterator, _Container>::difference_type
     1550161 ->     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    _GLIBCXX_NOEXCEPT
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    _Iterator
    14897470 ->     __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it.base(); }
                
                #if __cplusplus >= 201103L
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                  template<semiregular _Sent>
                    class move_sentinel
                    {
                    public:
                      constexpr
                      move_sentinel()
                      noexcept(is_nothrow_default_constructible_v<_Sent>)
                      : _M_last() { }
                
                      constexpr explicit
                      move_sentinel(_Sent __s)
                      noexcept(is_nothrow_move_constructible_v<_Sent>)
                      : _M_last(std::move(__s)) { }
                
                      template<typename _S2> requires convertible_to<const _S2&, _Sent>
                	constexpr
                	move_sentinel(const move_sentinel<_S2>& __s)
                	noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
                	: _M_last(__s.base())
                	{ }
                
                      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
                	constexpr move_sentinel&
                	operator=(const move_sentinel<_S2>& __s)
                	noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
                	{
                	  _M_last = __s.base();
                	  return *this;
                	}
                
                      constexpr _Sent
                      base() const
                      noexcept(is_nothrow_copy_constructible_v<_Sent>)
                      { return _M_last; }
                
                    private:
                      _Sent _M_last;
                    };
                #endif // C++20
                
                  namespace __detail
                  {
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    template<typename _Iterator>
                      struct __move_iter_cat
                      { };
                
                    template<typename _Iterator>
                      requires requires { typename iterator_traits<_Iterator>::iterator_category; }
                      struct __move_iter_cat<_Iterator>
                      {
                	using iterator_category
                	  = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category,
                			     random_access_iterator_tag>;
                      };
                #endif
                  }
                
                  // 24.4.3  Move iterators
                  /**
                   *  Class template move_iterator is an iterator adapter with the same
                   *  behavior as the underlying iterator except that its dereference
                   *  operator implicitly converts the value returned by the underlying
                   *  iterator's dereference operator to an rvalue reference.  Some
                   *  generic algorithms can be called with move iterators to replace
                   *  copying with moving.
                   */
                  template<typename _Iterator>
                    class move_iterator
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      : public __detail::__move_iter_cat<_Iterator>
                #endif
                    {
                      _Iterator _M_current;
                
                      using __traits_type = iterator_traits<_Iterator>;
                #if ! (__cplusplus > 201703L && __cpp_lib_concepts)
                      using __base_ref = typename __traits_type::reference;
                #endif
                
                      template<typename _Iter2>
                	friend class move_iterator;
                
                #if __cpp_lib_concepts
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>
                      template<typename _Iter2>
                	static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
                	    && convertible_to<const _Iter2&, _Iterator>;
                #endif
                
                    public:
                      using iterator_type = _Iterator;
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      using iterator_concept = input_iterator_tag;
                      // iterator_category defined in __move_iter_cat
                      using value_type = iter_value_t<_Iterator>;
                      using difference_type = iter_difference_t<_Iterator>;
                      using pointer = _Iterator;
                      using reference = iter_rvalue_reference_t<_Iterator>;
                #else
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      // NB: DR 680.
                      typedef _Iterator					pointer;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2106. move_iterator wrapping iterators returning prvalues
                      typedef typename conditional<is_reference<__base_ref>::value,
                			 typename remove_reference<__base_ref>::type&&,
                			 __base_ref>::type		reference;
                #endif
                
                      _GLIBCXX17_CONSTEXPR
                      move_iterator()
                      : _M_current() { }
                
                      explicit _GLIBCXX17_CONSTEXPR
                      move_iterator(iterator_type __i)
                      : _M_current(std::move(__i)) { }
                
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                #endif
                	_GLIBCXX17_CONSTEXPR
                	move_iterator(const move_iterator<_Iter>& __i)
                	: _M_current(__i._M_current) { }
                
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                	  && assignable_from<_Iterator&, const _Iter&>
                #endif
                	_GLIBCXX17_CONSTEXPR
                	move_iterator& operator=(const move_iterator<_Iter>& __i)
                	{
                	  _M_current = __i._M_current;
                	  return *this;
                	}
                
                #if __cplusplus <= 201703L
                      _GLIBCXX17_CONSTEXPR iterator_type
                      base() const
                      { return _M_current; }
                #else
                      constexpr iterator_type
                      base() const &
                #if __cpp_lib_concepts
                	requires copy_constructible<iterator_type>
                #endif
                      { return _M_current; }
                
                      constexpr iterator_type
                      base() &&
                      { return std::move(_M_current); }
                #endif
                
                      _GLIBCXX17_CONSTEXPR reference
                      operator*() const
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      { return ranges::iter_move(_M_current); }
                #else
                      { return static_cast<reference>(*_M_current); }
                #endif
                
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                      { return _M_current; }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator++(int)
                      {
                	move_iterator __tmp = *this;
                	++_M_current;
                	return __tmp;
                      }
                
                #if __cpp_lib_concepts
                      constexpr void
                      operator++(int) requires (!forward_iterator<_Iterator>)
                      { ++_M_current; }
                #endif
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator--(int)
                      {
                	move_iterator __tmp = *this;
                	--_M_current;
                	return __tmp;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator+(difference_type __n) const
                      { return move_iterator(_M_current + __n); }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator+=(difference_type __n)
                      {
                	_M_current += __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator-(difference_type __n) const
                      { return move_iterator(_M_current - __n); }
                    
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator-=(difference_type __n)
                      { 
                	_M_current -= __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      { return ranges::iter_move(_M_current + __n); }
                #else
                      { return std::move(_M_current[__n]); }
                #endif
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      template<sentinel_for<_Iterator> _Sent>
                	friend constexpr bool
                	operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
                	{ return __x.base() == __y.base(); }
                
                      template<sized_sentinel_for<_Iterator> _Sent>
                	friend constexpr iter_difference_t<_Iterator>
                	operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
                	{ return __x.base() - __y.base(); }
                
                      template<sized_sentinel_for<_Iterator> _Sent>
                	friend constexpr iter_difference_t<_Iterator>
                	operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
                	{ return __x.base() - __y.base(); }
                
                      friend constexpr iter_rvalue_reference_t<_Iterator>
                      iter_move(const move_iterator& __i)
                      noexcept(noexcept(ranges::iter_move(__i._M_current)))
                      { return ranges::iter_move(__i._M_current); }
                
                      template<indirectly_swappable<_Iterator> _Iter2>
                	friend constexpr void
                	iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
                	noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
                	{ return ranges::iter_swap(__x._M_current, __y._M_current); }
                #endif // C++20
                    };
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
                #endif
                    { return __x.base() == __y.base(); }
                
                #if __cpp_lib_three_way_comparison
                  template<typename _IteratorL,
                	   three_way_comparable_with<_IteratorL> _IteratorR>
                    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
                    operator<=>(const move_iterator<_IteratorL>& __x,
                		const move_iterator<_IteratorR>& __y)
                    { return __x.base() <=> __y.base(); }
                #else
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                #endif
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
                #endif
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }
                #endif
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }
                #endif
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
                #endif
                    { return !(__x < __y); }
                
                #if ! (__cplusplus > 201703L && __cpp_lib_concepts)
                  // Note: See __normal_iterator operators note from Gaby to understand
                  // why we have these extra overloads for some move_iterator operators.
                
                  // These extra overloads are not needed in C++20, because the ones above
                  // are constrained with a requires-clause and so overload resolution will
                  // prefer them to greedy unconstrained function templates.
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                #endif // ! C++20
                
                  // DR 685.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    operator+(typename move_iterator<_Iterator>::difference_type __n,
                	      const move_iterator<_Iterator>& __x)
                    { return __x + __n; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    make_move_iterator(_Iterator __i)
                    { return move_iterator<_Iterator>(std::move(__i)); }
                
                  template<typename _Iterator, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond
                      <typename iterator_traits<_Iterator>::value_type>::value,
                                _Iterator, move_iterator<_Iterator>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
                    __make_move_if_noexcept_iterator(_Iterator __i)
                    { return _ReturnType(__i); }
                
                  // Overload for pointers that matches std::move_if_noexcept more closely,
                  // returning a constant iterator when we don't want to move.
                  template<typename _Tp, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
                			   const _Tp*, move_iterator<_Tp*>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
         160 ->     __make_move_if_noexcept_iterator(_Tp* __i)
                    { return _ReturnType(__i); }
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                  // [iterators.common] Common iterators
                
                  namespace __detail
                  {
                    template<typename _It>
                      concept __common_iter_has_arrow = indirectly_readable<const _It>
                	&& (requires(const _It& __it) { __it.operator->(); }
                	    || is_reference_v<iter_reference_t<_It>>
                	    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
                
                    template<typename _It>
                      concept __common_iter_use_postfix_proxy
                	= (!requires (_It& __i) { { *__i++ } -> __can_reference; })
                	  && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>;
                  } // namespace __detail
                
                  /// An iterator/sentinel adaptor for representing a non-common range.
                  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
                    requires (!same_as<_It, _Sent>) && copyable<_It>
                  class common_iterator
                  {
                    template<typename _Tp, typename _Up>
                      static constexpr bool
                      _S_noexcept1()
                      {
                	if constexpr (is_trivially_default_constructible_v<_Tp>)
                	  return is_nothrow_assignable_v<_Tp, _Up>;
                	else
                	  return is_nothrow_constructible_v<_Tp, _Up>;
                      }
                
                    template<typename _It2, typename _Sent2>
                      static constexpr bool
                      _S_noexcept()
                      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }
                
                    class __arrow_proxy
                    {
                      iter_value_t<_It> _M_keep;
                
                      __arrow_proxy(iter_reference_t<_It>&& __x)
                      : _M_keep(std::move(__x)) { }
                
                      friend class common_iterator;
                
                    public:
                      const iter_value_t<_It>*
                      operator->() const
                      { return std::__addressof(_M_keep); }
                    };
                
                    class __postfix_proxy
                    {
                      iter_value_t<_It> _M_keep;
                
                      __postfix_proxy(iter_reference_t<_It>&& __x)
                      : _M_keep(std::move(__x)) { }
                
                      friend class common_iterator;
                
                    public:
                      const iter_value_t<_It>&
                      operator*() const
                      { return _M_keep; }
                    };
                
                  public:
                    constexpr
                    common_iterator()
                    noexcept(is_nothrow_default_constructible_v<_It>)
                    : _M_it(), _M_index(0)
                    { }
                
                    constexpr
                    common_iterator(_It __i)
                    noexcept(is_nothrow_move_constructible_v<_It>)
                    : _M_it(std::move(__i)), _M_index(0)
                    { }
                
                    constexpr
                    common_iterator(_Sent __s)
                    noexcept(is_nothrow_move_constructible_v<_Sent>)
                    : _M_sent(std::move(__s)), _M_index(1)
                    { }
                
                    template<typename _It2, typename _Sent2>
                      requires convertible_to<const _It2&, _It>
                	&& convertible_to<const _Sent2&, _Sent>
                      constexpr
                      common_iterator(const common_iterator<_It2, _Sent2>& __x)
                      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
                      : _M_valueless(), _M_index(__x._M_index)
                      {
                	if (_M_index == 0)
                	  {
                	    if constexpr (is_trivially_default_constructible_v<_It>)
                	      _M_it = std::move(__x._M_it);
                	    else
                	      ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
                	  }
                	else if (_M_index == 1)
                	  {
                	    if constexpr (is_trivially_default_constructible_v<_Sent>)
                	      _M_sent = std::move(__x._M_sent);
                	    else
                	      ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
                	  }
                      }
                
                    constexpr
                    common_iterator(const common_iterator& __x)
                    noexcept(_S_noexcept<const _It&, const _Sent&>())
                    : _M_valueless(), _M_index(__x._M_index)
                    {
                      if (_M_index == 0)
                	{
                	  if constexpr (is_trivially_default_constructible_v<_It>)
                	    _M_it = std::move(__x._M_it);
                	  else
                	    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
                	}
                      else if (_M_index == 1)
                	{
                	  if constexpr (is_trivially_default_constructible_v<_Sent>)
                	    _M_sent = std::move(__x._M_sent);
                	  else
                	    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
                	}
                    }
                
                    common_iterator&
                    operator=(const common_iterator& __x)
                    noexcept(is_nothrow_copy_assignable_v<_It>
                	     && is_nothrow_copy_assignable_v<_Sent>
                	     && is_nothrow_copy_constructible_v<_It>
                	     && is_nothrow_copy_constructible_v<_Sent>)
                    {
                      return this->operator=<_It, _Sent>(__x);
                    }
                
                    template<typename _It2, typename _Sent2>
                      requires convertible_to<const _It2&, _It>
                	&& convertible_to<const _Sent2&, _Sent>
                	&& assignable_from<_It&, const _It2&>
                	&& assignable_from<_Sent&, const _Sent2&>
                      common_iterator&
                      operator=(const common_iterator<_It2, _Sent2>& __x)
                      noexcept(is_nothrow_constructible_v<_It, const _It2&>
                	       && is_nothrow_constructible_v<_Sent, const _Sent2&>
                	       && is_nothrow_assignable_v<_It, const _It2&>
                	       && is_nothrow_assignable_v<_Sent, const _Sent2&>)
                      {
                	switch(_M_index << 2 | __x._M_index)
                	  {
                	  case 0b0000:
                	    _M_it = __x._M_it;
                	    break;
                	  case 0b0101:
                	    _M_sent = __x._M_sent;
                	    break;
                	  case 0b0001:
                	    _M_it.~_It();
                	    _M_index = -1;
                	    [[fallthrough]];
                	  case 0b1001:
                	    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
                	    _M_index = 1;
                	    break;
                	  case 0b0100:
                	    _M_sent.~_Sent();
                	    _M_index = -1;
                	    [[fallthrough]];
                	  case 0b1000:
                	    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
                	    _M_index = 0;
                	    break;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __builtin_unreachable();
                	  }
                	return *this;
                      }
                
                    ~common_iterator()
                    {
                      switch (_M_index)
                	{
                	case 0:
                	  _M_it.~_It();
                	  break;
                	case 1:
                	  _M_sent.~_Sent();
                	  break;
                	}
                    }
                
                    decltype(auto)
                    operator*()
                    {
                      __glibcxx_assert(_M_index == 0);
                      return *_M_it;
                    }
                
                    decltype(auto)
                    operator*() const requires __detail::__dereferenceable<const _It>
                    {
                      __glibcxx_assert(_M_index == 0);
                      return *_M_it;
                    }
                
                    decltype(auto)
                    operator->() const requires __detail::__common_iter_has_arrow<_It>
                    {
                      __glibcxx_assert(_M_index == 0);
                      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
                	return _M_it;
                      else if constexpr (is_reference_v<iter_reference_t<_It>>)
                	{
                	  auto&& __tmp = *_M_it;
                	  return std::__addressof(__tmp);
                	}
                      else
                	return __arrow_proxy{*_M_it};
                    }
                
                    common_iterator&
                    operator++()
                    {
                      __glibcxx_assert(_M_index == 0);
                      ++_M_it;
                      return *this;
                    }
                
                    decltype(auto)
                    operator++(int)
                    {
                      __glibcxx_assert(_M_index == 0);
                      if constexpr (forward_iterator<_It>)
                	{
                	  common_iterator __tmp = *this;
                	  ++*this;
                	  return __tmp;
                	}
                      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
                	return _M_it++;
                      else
                	{
                	  __postfix_proxy __p(**this);
                	  ++*this;
                	  return __p;
                	}
                    }
                
                    template<typename _It2, sentinel_for<_It> _Sent2>
                      requires sentinel_for<_Sent, _It2>
                      friend bool
                      operator==(const common_iterator& __x,
                		 const common_iterator<_It2, _Sent2>& __y)
                      {
                	switch(__x._M_index << 2 | __y._M_index)
                	  {
                	  case 0b0000:
                	  case 0b0101:
                	    return true;
                	  case 0b0001:
                	    return __x._M_it == __y._M_sent;
                	  case 0b0100:
                	    return __x._M_sent == __y._M_it;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __glibcxx_assert(__y._M_has_value());
                	    __builtin_unreachable();
                	  }
                      }
                
                    template<typename _It2, sentinel_for<_It> _Sent2>
                      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
                      friend bool
                      operator==(const common_iterator& __x,
                		 const common_iterator<_It2, _Sent2>& __y)
                      {
                	switch(__x._M_index << 2 | __y._M_index)
                	  {
                	  case 0b0101:
                	    return true;
                	  case 0b0000:
                	    return __x._M_it == __y._M_it;
                	  case 0b0001:
                	    return __x._M_it == __y._M_sent;
                	  case 0b0100:
                	    return __x._M_sent == __y._M_it;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __glibcxx_assert(__y._M_has_value());
                	    __builtin_unreachable();
                	  }
                      }
                
                    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
                      requires sized_sentinel_for<_Sent, _It2>
                      friend iter_difference_t<_It2>
                      operator-(const common_iterator& __x,
                		const common_iterator<_It2, _Sent2>& __y)
                      {
                	switch(__x._M_index << 2 | __y._M_index)
                	  {
                	  case 0b0101:
                	    return 0;
                	  case 0b0000:
                	    return __x._M_it - __y._M_it;
                	  case 0b0001:
                	    return __x._M_it - __y._M_sent;
                	  case 0b0100:
                	    return __x._M_sent - __y._M_it;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __glibcxx_assert(__y._M_has_value());
                	    __builtin_unreachable();
                	  }
                      }
                
                    friend iter_rvalue_reference_t<_It>
                    iter_move(const common_iterator& __i)
                    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
                    requires input_iterator<_It>
                    {
                      __glibcxx_assert(__i._M_index == 0);
                      return ranges::iter_move(__i._M_it);
                    }
                
                    template<indirectly_swappable<_It> _It2, typename _Sent2>
                      friend void
                      iter_swap(const common_iterator& __x,
                		const common_iterator<_It2, _Sent2>& __y)
                      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
                					  std::declval<const _It2&>())))
                      {
                	__glibcxx_assert(__x._M_index == 0);
                	__glibcxx_assert(__y._M_index == 0);
                	return ranges::iter_swap(__x._M_it, __y._M_it);
                      }
                
                  private:
                    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
                      friend class common_iterator;
                
                    bool _M_has_value() const noexcept { return _M_index < 2; }
                
                    union
                    {
                      _It _M_it;
                      _Sent _M_sent;
                      unsigned char _M_valueless;
                    };
                    unsigned char _M_index; // 0==_M_it, 1==_M_sent, 2==valueless
                  };
                
                  template<typename _It, typename _Sent>
                    struct incrementable_traits<common_iterator<_It, _Sent>>
                    {
                      using difference_type = iter_difference_t<_It>;
                    };
                
                  template<input_iterator _It, typename _Sent>
                    struct iterator_traits<common_iterator<_It, _Sent>>
                    {
                    private:
                      template<typename _Iter>
                	struct __ptr
                	{
                	  using type = void;
                	};
                
                      template<typename _Iter>
                	requires __detail::__common_iter_has_arrow<_Iter>
                	struct __ptr<_Iter>
                	{
                	  using _CIter = common_iterator<_Iter, _Sent>;
                	  using type = decltype(std::declval<const _CIter&>().operator->());
                	};
                
                      static auto
                      _S_iter_cat()
                      {
                	using _Traits = iterator_traits<_It>;
                	if constexpr (requires { requires derived_from<typename _Traits::iterator_category,
                						       forward_iterator_tag>; })
                	  return forward_iterator_tag{};
                	else
                	  return input_iterator_tag{};
                      }
                
                    public:
                      using iterator_concept = conditional_t<forward_iterator<_It>,
                	    forward_iterator_tag, input_iterator_tag>;
                      using iterator_category = decltype(_S_iter_cat());
                      using value_type = iter_value_t<_It>;
                      using difference_type = iter_difference_t<_It>;
                      using pointer = typename __ptr<_It>::type;
                      using reference = iter_reference_t<_It>;
                    };
                
                  // [iterators.counted] Counted iterators
                
                  namespace __detail
                  {
                    template<typename _It>
                      struct __counted_iter_value_type
                      { };
                
                    template<indirectly_readable _It>
                      struct __counted_iter_value_type<_It>
                      { using value_type = iter_value_t<_It>; };
                
                    template<typename _It>
                      struct __counted_iter_concept
                      { };
                
                    template<typename _It>
                      requires requires { typename _It::iterator_concept; }
                      struct __counted_iter_concept<_It>
                      { using iterator_concept = typename _It::iterator_concept; };
                
                    template<typename _It>
                      struct __counted_iter_cat
                      { };
                
                    template<typename _It>
                      requires requires { typename _It::iterator_category; }
                      struct __counted_iter_cat<_It>
                      { using iterator_category = typename _It::iterator_category; };
                  }
                
                  /// An iterator adaptor that keeps track of the distance to the end.
                  template<input_or_output_iterator _It>
                    class counted_iterator
                      : public __detail::__counted_iter_value_type<_It>,
                	public __detail::__counted_iter_concept<_It>,
                	public __detail::__counted_iter_cat<_It>
                    {
                    public:
                      using iterator_type = _It;
                      // value_type defined in __counted_iter_value_type
                      using difference_type = iter_difference_t<_It>;
                      // iterator_concept defined in __counted_iter_concept
                      // iterator_category defined in __counted_iter_cat
                
                      constexpr counted_iterator() = default;
                
                      constexpr
                      counted_iterator(_It __i, iter_difference_t<_It> __n)
                      : _M_current(std::move(__i)), _M_length(__n)
                      { __glibcxx_assert(__n >= 0); }
                
                      template<typename _It2>
                	requires convertible_to<const _It2&, _It>
                	constexpr
                	counted_iterator(const counted_iterator<_It2>& __x)
                	: _M_current(__x._M_current), _M_length(__x._M_length)
                	{ }
                
                      template<typename _It2>
                	requires assignable_from<_It&, const _It2&>
                	constexpr counted_iterator&
                	operator=(const counted_iterator<_It2>& __x)
                	{
                	  _M_current = __x._M_current;
                	  _M_length = __x._M_length;
                	  return *this;
                	}
                
                      constexpr _It
                      base() const &
                      noexcept(is_nothrow_copy_constructible_v<_It>)
                      requires copy_constructible<_It>
                      { return _M_current; }
                
                      constexpr _It
                      base() &&
                      noexcept(is_nothrow_move_constructible_v<_It>)
                      { return std::move(_M_current); }
                
                      constexpr iter_difference_t<_It>
                      count() const noexcept { return _M_length; }
                
                      constexpr decltype(auto)
                      operator*()
                      noexcept(noexcept(*_M_current))
                      {
                	__glibcxx_assert( _M_length > 0 );
                	return *_M_current;
                      }
                
                      constexpr decltype(auto)
                      operator*() const
                      noexcept(noexcept(*_M_current))
                      requires __detail::__dereferenceable<const _It>
                      {
                	__glibcxx_assert( _M_length > 0 );
                	return *_M_current;
                      }
                
                      constexpr auto
                      operator->() const noexcept
                      requires contiguous_iterator<_It>
                      { return std::to_address(_M_current); }
                
                      constexpr counted_iterator&
                      operator++()
                      {
                	__glibcxx_assert(_M_length > 0);
                	++_M_current;
                	--_M_length;
                	return *this;
                      }
                
                      decltype(auto)
                      operator++(int)
                      {
                	__glibcxx_assert(_M_length > 0);
                	--_M_length;
                	__try
                	  {
                	    return _M_current++;
                	  } __catch(...) {
                	    ++_M_length;
                	    __throw_exception_again;
                	  }
                
                      }
                
                      constexpr counted_iterator
                      operator++(int) requires forward_iterator<_It>
                      {
                	auto __tmp = *this;
                	++*this;
                	return __tmp;
                      }
                
                      constexpr counted_iterator&
                      operator--() requires bidirectional_iterator<_It>
                      {
                	--_M_current;
                	++_M_length;
                	return *this;
                      }
                
                      constexpr counted_iterator
                      operator--(int) requires bidirectional_iterator<_It>
                      {
                	auto __tmp = *this;
                	--*this;
                	return __tmp;
                      }
                
                      constexpr counted_iterator
                      operator+(iter_difference_t<_It> __n) const
                	requires random_access_iterator<_It>
                      { return counted_iterator(_M_current + __n, _M_length - __n); }
                
                      friend constexpr counted_iterator
                      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
                      requires random_access_iterator<_It>
                      { return __x + __n; }
                
                      constexpr counted_iterator&
                      operator+=(iter_difference_t<_It> __n)
                      requires random_access_iterator<_It>
                      {
                	__glibcxx_assert(__n <= _M_length);
                	_M_current += __n;
                	_M_length -= __n;
                	return *this;
                      }
                
                      constexpr counted_iterator
                      operator-(iter_difference_t<_It> __n) const
                      requires random_access_iterator<_It>
                      { return counted_iterator(_M_current - __n, _M_length + __n); }
                
                      template<common_with<_It> _It2>
                	friend constexpr iter_difference_t<_It2>
                	operator-(const counted_iterator& __x,
                		  const counted_iterator<_It2>& __y)
                	{ return __y._M_length - __x._M_length; }
                
                      friend constexpr iter_difference_t<_It>
                      operator-(const counted_iterator& __x, default_sentinel_t)
                      { return -__x._M_length; }
                
                      friend constexpr iter_difference_t<_It>
                      operator-(default_sentinel_t, const counted_iterator& __y)
                      { return __y._M_length; }
                
                      constexpr counted_iterator&
                      operator-=(iter_difference_t<_It> __n)
                      requires random_access_iterator<_It>
                      {
                	__glibcxx_assert(-__n <= _M_length);
                	_M_current -= __n;
                	_M_length += __n;
                	return *this;
                      }
                
                      constexpr decltype(auto)
                      operator[](iter_difference_t<_It> __n) const
                      noexcept(noexcept(_M_current[__n]))
                      requires random_access_iterator<_It>
                      {
                	__glibcxx_assert(__n < _M_length);
                	return _M_current[__n];
                      }
                
                      template<common_with<_It> _It2>
                	friend constexpr bool
                	operator==(const counted_iterator& __x,
                		   const counted_iterator<_It2>& __y)
                	{ return __x._M_length == __y._M_length; }
                
                      friend constexpr bool
                      operator==(const counted_iterator& __x, default_sentinel_t)
                      { return __x._M_length == 0; }
                
                      template<common_with<_It> _It2>
                	friend constexpr strong_ordering
                	operator<=>(const counted_iterator& __x,
                		    const counted_iterator<_It2>& __y)
                	{ return __y._M_length <=> __x._M_length; }
                
                      friend constexpr iter_rvalue_reference_t<_It>
                      iter_move(const counted_iterator& __i)
                      noexcept(noexcept(ranges::iter_move(__i._M_current)))
                      requires input_iterator<_It>
                      {
                	__glibcxx_assert( __i._M_length > 0 );
                	return ranges::iter_move(__i._M_current);
                      }
                
                      template<indirectly_swappable<_It> _It2>
                	friend constexpr void
                	iter_swap(const counted_iterator& __x,
                		  const counted_iterator<_It2>& __y)
                	noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
                	{
                	  __glibcxx_assert( __x._M_length > 0 && __y._M_length > 0 );
                	  ranges::iter_swap(__x._M_current, __y._M_current);
                	}
                
                    private:
                      template<input_or_output_iterator _It2> friend class counted_iterator;
                
                      _It _M_current = _It();
                      iter_difference_t<_It> _M_length = 0;
                    };
                
                  template<input_iterator _It>
                    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
                    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
                    {
                      using pointer = conditional_t<contiguous_iterator<_It>,
                				    add_pointer_t<iter_reference_t<_It>>,
                				    void>;
                    };
                #endif // C++20
                
                  /// @} group iterators
                
                  template<typename _Iterator>
                    auto
                    __niter_base(move_iterator<_Iterator> __it)
                    -> decltype(make_move_iterator(__niter_base(__it.base())))
                    { return make_move_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<move_iterator<_Iterator> >
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<typename _Iterator>
                    auto
                    __miter_base(move_iterator<_Iterator> __it)
                    -> decltype(__miter_base(__it.base()))
                    { return __miter_base(__it.base()); }
                
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                  std::__make_move_if_noexcept_iterator(_Iter)
                #else
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                #endif // C++11
                
                #if __cpp_deduction_guides >= 201606
                  // These helper traits are used for deduction guides
                  // of associative containers.
                  template<typename _InputIterator>
                    using __iter_key_t = remove_const_t<
                    typename iterator_traits<_InputIterator>::value_type::first_type>;
                
                  template<typename _InputIterator>
                    using __iter_val_t =
                    typename iterator_traits<_InputIterator>::value_type::second_type;
                
                  template<typename _T1, typename _T2>
                    struct pair;
                
                  template<typename _InputIterator>
                    using __iter_to_alloc_t =
                    pair<add_const_t<__iter_key_t<_InputIterator>>,
                	 __iter_val_t<_InputIterator>>;
                #endif // __cpp_deduction_guides
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #ifdef _GLIBCXX_DEBUG
                # include <debug/stl_iterator.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

     1085   45478318
     1007   22429990
     1022   21525272
     1254   14897470
     1032   12782173
     1142   11941083
     1070    3135299
     1046    2132368
     1231    1550161
     1158     517840

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

136720841   Total number of line executions
10516987.77   Average executions per line


*** File /usr/include/c++/11/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                #define __cpp_lib_incomplete_container_elements 201505
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef void        value_type;
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                #if __cplusplus <= 201703L
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                #else
                      allocator() = default;
                
                      template<typename _Up>
                	constexpr
                	allocator(const allocator<_Up>&) { }
                #endif // ! C++20
                
                #if __cplusplus >= 201103L && __cplusplus <= 201703L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                
                      typedef true_type is_always_equal;
                
                      template<typename _Up, typename... _Args>
                	void
                	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
                	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #endif // C++11 to C++17
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator : public __allocator_base<_Tp>
                    {
                    public:
                      typedef _Tp        value_type;
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                #if __cplusplus <= 201703L
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                #endif
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                
                      typedef true_type is_always_equal;
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3035. std::allocator's constructors should be constexpr
                      _GLIBCXX20_CONSTEXPR
     1263004 ->       allocator() _GLIBCXX_NOTHROW { }
                
                      _GLIBCXX20_CONSTEXPR
     5247230 ->       allocator(const allocator& __a) _GLIBCXX_NOTHROW
                      : __allocator_base<_Tp>(__a) { }
                
                #if __cplusplus >= 201103L
                      // Avoid implicit deprecation.
                      allocator& operator=(const allocator&) = default;
                #endif
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
                	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
                
                #if __cpp_constexpr_dynamic_alloc
                      constexpr
                #endif
     6510234 ->       ~allocator() _GLIBCXX_NOTHROW { }
                
                #if __cplusplus > 201703L
                      [[nodiscard,__gnu__::__always_inline__]]
                      constexpr _Tp*
                      allocate(size_t __n)
                      {
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                #endif
                	return __allocator_base<_Tp>::allocate(__n, 0);
                      }
                
                      [[__gnu__::__always_inline__]]
                      constexpr void
                      deallocate(_Tp* __p, size_t __n)
                      {
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  {
                	    ::operator delete(__p);
                	    return;
                	  }
                #endif
                	  __allocator_base<_Tp>::deallocate(__p, __n);
                      }
                #endif // C++20
                
                      friend _GLIBCXX20_CONSTEXPR bool
                      operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return true; }
                
                #if __cpp_impl_three_way_comparison < 201907L
                      friend _GLIBCXX20_CONSTEXPR bool
       ##### ->       operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return false; }
                #endif
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX20_CONSTEXPR bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return true; }
                
                #if __cpp_impl_three_way_comparison < 201907L
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX20_CONSTEXPR bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return false; }
                #endif
                
                  // Invalid allocator<cv T> partial specializations.
                  // allocator_traits::rebind_alloc can be used to form a valid allocator type.
                  template<typename _Tp>
                    class allocator<const _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<const volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) noexcept { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c) noexcept
                      {
                #if __cpp_exceptions
                	try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	catch(...)
                	  { return false; }
                #else
                	return false;
                #endif
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      162    6510234
      147    5247230
      144    1263004

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

 13020468   Total number of line executions
3255117.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                #if __cplusplus > 201703L
                # include <compare>
                #endif
                
                #include <debug/assertions.h>
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                extern "C" void
                __sanitizer_annotate_contiguous_container(const void*, const void*,
                					  const void*, const void*);
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
                      struct _Vector_impl_data
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
     3346619 -> 	_Vector_impl_data() _GLIBCXX_NOEXCEPT
                	: _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
                	: _M_start(__x._M_start), _M_finish(__x._M_finish),
                	  _M_end_of_storage(__x._M_end_of_storage)
                	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
                #endif
                
                	void
                	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
                	{
                	  _M_start = __x._M_start;
                	  _M_finish = __x._M_finish;
                	  _M_end_of_storage = __x._M_end_of_storage;
                	}
                
                	void
                	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
                	{
                	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
                	  // information used by TBAA.
                	  _Vector_impl_data __tmp;
                	  __tmp._M_copy_data(*this);
                	  _M_copy_data(__x);
                	  __x._M_copy_data(__tmp);
                	}
                      };
                
     3346619 ->       struct _Vector_impl
                	: public _Tp_alloc_type, public _Vector_impl_data
                      {
      723004 -> 	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
                	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
                	: _Tp_alloc_type()
                	{ }
                
     2623615 -> 	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a)
                	{ }
                
                #if __cplusplus >= 201103L
                	// Not defaulted, to enforce noexcept(true) even when
                	// !is_nothrow_move_constructible<_Tp_alloc_type>.
                	_Vector_impl(_Vector_impl&& __x) noexcept
                	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
                	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
                	{ }
                #endif
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                	template<typename = _Tp_alloc_type>
                	  struct _Asan
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    static void _S_shrink(_Vector_impl&, size_type) { }
                	    static void _S_on_dealloc(_Vector_impl&) { }
                
                	    typedef _Vector_impl& _Reinit;
                
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl&, size_type) { }
                	      void _M_grew(size_type) { }
                	    };
                	  };
                
                	// Enable ASan annotations for memory obtained from std::allocator.
                	template<typename _Up>
                	  struct _Asan<allocator<_Up> >
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to
                	    // mark end of valid region as __curr instead of __prev.
                	    static void
                	    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)
                	    {
                	      __sanitizer_annotate_contiguous_container(__impl._M_start,
                		  __impl._M_end_of_storage, __prev, __curr);
                	    }
                
                	    static void
                	    _S_grow(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }
                
                	    static void
                	    _S_shrink(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }
                
                	    static void
                	    _S_on_dealloc(_Vector_impl& __impl)
                	    {
                	      if (__impl._M_start)
                		_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);
                	    }
                
                	    // Used on reallocation to tell ASan unused capacity is invalid.
                	    struct _Reinit
                	    {
                	      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)
                	      {
                		// Mark unused capacity as valid again before deallocating it.
                		_S_on_dealloc(_M_impl);
                	      }
                
                	      ~_Reinit()
                	      {
                		// Mark unused capacity as invalid after reallocation.
                		if (_M_impl._M_start)
                		  _S_adjust(_M_impl, _M_impl._M_end_of_storage,
                			    _M_impl._M_finish);
                	      }
                
                	      _Vector_impl& _M_impl;
                
                #if __cplusplus >= 201103L
                	      _Reinit(const _Reinit&) = delete;
                	      _Reinit& operator=(const _Reinit&) = delete;
                #endif
                	    };
                
                	    // Tell ASan when unused capacity is initialized to be valid.
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl& __impl, size_type __n)
                	      : _M_impl(__impl), _M_n(__n)
                	      { _S_grow(_M_impl, __n); }
                
                	      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }
                
                	      void _M_grew(size_type __n) { _M_n -= __n; }
                
                #if __cplusplus >= 201103L
                	      _Grow(const _Grow&) = delete;
                	      _Grow& operator=(const _Grow&) = delete;
                #endif
                	    private:
                	      _Vector_impl& _M_impl;
                	      size_type _M_n;
                	    };
                	  };
                
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT \
                  typename _Base::_Vector_impl::template _Asan<>::_Reinit const \
                	__attribute__((__unused__)) __reinit_guard(this->_M_impl)
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \
                  typename _Base::_Vector_impl::template _Asan<>::_Grow \
                	__attribute__((__unused__)) __grow_guard(this->_M_impl, (n))
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \
                  _Base::_Vector_impl::template _Asan<>::_S_shrink(this->_M_impl, n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \
                  _Base::_Vector_impl::template _Asan<>::_S_on_dealloc(this->_M_impl)
                #else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
                #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                      };
                
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
    11934296 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      const _Tp_alloc_type&
     4825695 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
      723004 ->       _Vector_base() = default;
                #else
                      _Vector_base() { }
                #endif
                
                      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _M_impl(__a) { }
                
                      // Kept for ABI compatibility.
                #if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                #endif
                
     2623615 ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Vector_base&&) = default;
                
                      // Kept for ABI compatibility.
                # if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(_Tp_alloc_type&& __a) noexcept
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                # endif
                
                      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
                      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
                      { }
                #endif
                
     3346619 ->       ~_Vector_base() _GLIBCXX_NOEXCEPT
                      {
                	_M_deallocate(_M_impl._M_start,
                		      _M_impl._M_end_of_storage - _M_impl._M_start);
                      }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
     4444655 ->       _M_allocate(size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
                      }
                
                      void
     5167659 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	if (__p)
                	  _Tr::deallocate(_M_impl, __p, __n);
                      }
                
                    protected:
                      void
     2623615 ->       _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // Concept requirements.
                      typedef typename _Alloc::value_type		_Alloc_value_type;
                # if __cplusplus < 201103L
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                # endif
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                #endif
                
                #if __cplusplus >= 201103L
                      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
                	  "std::vector must have a non-const, non-volatile value_type");
                # if __cplusplus > 201703L || defined __STRICT_ANSI__
                      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
                	  "std::vector must have the same value_type as its allocator");
                # endif
                #endif
                
                      typedef _Vector_base<_Tp, _Alloc>			_Base;
                      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
                
                    public:
                      typedef _Tp					value_type;
                      typedef typename _Base::pointer			pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                      typedef size_t					size_type;
                      typedef ptrdiff_t					difference_type;
                      typedef _Alloc					allocator_type;
                
                    private:
                #if __cplusplus >= 201103L
                      static constexpr bool
                      _S_nothrow_relocate(true_type)
                      {
                	return noexcept(std::__relocate_a(std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<_Tp_alloc_type&>()));
                      }
                
                      static constexpr bool
                      _S_nothrow_relocate(false_type)
                      { return false; }
                
                      static constexpr bool
                      _S_use_relocate()
                      {
                	// Instantiating std::__relocate_a might cause an error outside the
                	// immediate context (in __relocate_object_a's noexcept-specifier),
                	// so only do it if we know the type can be move-inserted into *this.
                	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
                      }
                
                      static pointer
     2562000 ->       _S_do_relocate(pointer __first, pointer __last, pointer __result,
                		     _Tp_alloc_type& __alloc, true_type) noexcept
                      {
                	return std::__relocate_a(__first, __last, __result, __alloc);
                      }
                
                      static pointer
                      _S_do_relocate(pointer, pointer, pointer __result,
                		     _Tp_alloc_type&, false_type) noexcept
                      { return __result; }
                
                      static pointer
     2562000 ->       _S_relocate(pointer __first, pointer __last, pointer __result,
                		  _Tp_alloc_type& __alloc) noexcept
                      {
                	using __do_it = __bool_constant<_S_use_relocate()>;
                	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
                      }
                #endif // C++11
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       */
                #if __cplusplus >= 201103L
      723004 ->       vector() = default;
                #else
                      vector() { }
                #endif
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
      360000 ->       vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x  will not be copied
                       *  (i.e. capacity() == size() in the new %vector).
                       *
                       *  The newly-created %vector uses a copy of the allocator object used
                       *  by @a __x (unless the allocator traits dictate a different object).
                       */
     2263615 ->       vector(const vector& __x)
                      : _Base(__x.size(),
                	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *
                       *  The newly-created %vector contains the exact contents of the
                       *  moved instance.
                       *  The contents of the moved instance are a valid, but unspecified
                       *  %vector.
                       */
                      vector(vector&&) noexcept = default;
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                    private:
                      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
                      : _Base(__m, std::move(__rv))
                      { }
                
                      vector(vector&& __rv, const allocator_type& __m, false_type)
                      : _Base(__m)
                      {
                	if (__rv.get_allocator() == __m)
                	  this->_M_impl._M_swap_data(__rv._M_impl);
                	else if (!__rv.empty())
                	  {
                	    this->_M_create_storage(__rv.size());
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                    public:
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      noexcept( noexcept(
                	vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
                	       std::declval<typename _Alloc_traits::is_always_equal>())) )
                      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
                      { }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
                      vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #else
                      template<typename _InputIterator>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
     3346619 ->       ~vector() _GLIBCXX_NOEXCEPT
                      {
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
                      }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x will not be copied.
                       *
                       *  Whether the allocator is copied depends on the allocator traits.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  Afterwards @a __x is a valid, but unspecified %vector.
                       *
                       *  Whether the allocator is moved depends on the allocator traits.
                       */
                      vector&
                      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	constexpr bool __move_storage =
                	  _Alloc_traits::_S_propagate_on_move_assign()
                	  || _Alloc_traits::_S_always_equal();
                	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{ _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
     4626585 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
     5125557 ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
     3786585 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
     5425557 ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
    42360945 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
     2562080 ->       max_size() const _GLIBCXX_NOEXCEPT
                      { return _S_max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
     2861942 ->       capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
   111128049 ->       operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
    35700000 ->       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                    protected:
                      /// Safety check used only from at().
                      void
    28494664 ->       _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
    28494664 ->       at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
      300000 ->       front() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
      300000 ->       back() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                      _Tp*
                      data() _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      const _Tp*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
    10983060 ->       push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), __x);
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                #if __cplusplus > 201402L
                	reference
                #else
                	void
                #endif
                	emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                	iterator
                	emplace(const_iterator __position, _Args&&... __args)
                	{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return _M_insert_rval(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, initializer_list<value_type> __l)
                      {
                	auto __offset = __position - cbegin();
                	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),
                			std::random_access_iterator_tag());
                	return begin() + __offset;
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(begin() + __offset, __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                	insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(begin() + __offset,
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                	void
                	insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                      { return _M_erase(begin() + (__position - cbegin())); }
                #else
                      erase(iterator __position)
                      { return _M_erase(__position); }
                #endif
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                      {
                	const auto __beg = begin();
                	const auto __cbeg = cbegin();
                	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
                      }
                #else
                      erase(iterator __first, iterator __last)
                      { return _M_erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       *
                       *  Whether the allocators are swapped depends on the allocator traits.
                       */
                      void
                      swap(vector& __x) _GLIBCXX_NOEXCEPT
                      {
                #if __cplusplus >= 201103L
                	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
                			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
                #endif
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                				  __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
       ##### ->       clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                	pointer
      540000 -> 	_M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                	{
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                #if __cplusplus < 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                	{
                	  this->_M_impl._M_start = _M_allocate(_S_check_init_len(
                		static_cast<size_type>(__n), _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #endif
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_initialize(_InputIterator __first, _InputIterator __last,
                			    std::input_iterator_tag)
                	{
                	  __try {
                	    for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	      emplace_back(*__first);
                #else
                	      push_back(*__first);
                #endif
                	  } __catch(...) {
                	    clear();
                	    __throw_exception_again;
                	  }
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                			    std::forward_iterator_tag)
                	{
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start
                	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                					_M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
      360000 ->       _M_default_initialize(size_type __n)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
                					   _M_get_Tp_allocator());
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                	{ _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                	{ _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                	{
                	  _M_range_insert(__pos, __first, __last,
                			  std::__iterator_category(__first));
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                #if __cplusplus < 201103L
                      // Called by insert(p,x)
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                
                      void
                      _M_realloc_insert(iterator __position, const value_type& __x);
                #else
                      // A value_type object constructed with _Alloc_traits::construct()
                      // and destroyed with _Alloc_traits::destroy().
                      struct _Temporary_value
                      {
                	template<typename... _Args>
                	  explicit
                	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
                	  {
                	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
                				     std::forward<_Args>(__args)...);
                	  }
                
                	~_Temporary_value()
                	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
                
                	value_type&
                	_M_val() { return *_M_ptr(); }
                
                      private:
                	_Tp*
                	_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }
                
                	vector* _M_this;
                	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
                      };
                
                      // Called by insert(p,x) and other functions when insertion needs to
                      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
                      template<typename _Arg>
                	void
                	_M_insert_aux(iterator __position, _Arg&& __arg);
                
                      template<typename... _Args>
                	void
                	_M_realloc_insert(iterator __position, _Args&&... __args);
                
                      // Either move-construct at the end, or forward to _M_insert_aux.
                      iterator
                      _M_insert_rval(const_iterator __position, value_type&& __v);
                
                      // Try to emplace at the end, otherwise forward to _M_insert_aux.
                      template<typename... _Args>
                	iterator
                	_M_emplace_aux(const_iterator __position, _Args&&... __args);
                
                      // Emplacing an rvalue of the correct type can use _M_insert_rval.
                      iterator
                      _M_emplace_aux(const_iterator __position, value_type&& __v)
                      { return _M_insert_rval(__position, std::move(__v)); }
                #endif
                
                      // Called by _M_fill_insert, _M_insert_aux etc.
                      size_type
     1281040 ->       _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + (std::max)(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Called by constructors to check initial size.
                      static size_type
      360000 ->       _S_check_init_len(size_type __n, const allocator_type& __a)
                      {
                	if (__n > _S_max_size(_Tp_alloc_type(__a)))
                	  __throw_length_error(
                	      __N("cannot create std::vector larger than max_size()"));
                	return __n;
                      }
                
                      static size_type
     2922080 ->       _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
                      {
                	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
                	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
                	// (even if std::allocator_traits::max_size says we can).
                	const size_t __diffmax
                	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
                	const size_t __allocmax = _Alloc_traits::max_size(__a);
                	return (std::min)(__diffmax, __allocmax);
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
       ##### ->       _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
                      {
                	if (size_type __n = this->_M_impl._M_finish - __pos)
                	  {
                	    std::_Destroy(__pos, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    this->_M_impl._M_finish = __pos;
                	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
                	  }
                      }
                
                      iterator
                      _M_erase(iterator __position);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
                      _M_move_assign(vector&& __x, true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__x._M_impl);
                	__tmp._M_impl._M_swap_data(__x._M_impl);
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->_M_assign_aux(std::make_move_iterator(__x.begin()),
                			        std::make_move_iterator(__x.end()),
                				std::random_access_iterator_tag());
                	    __x.clear();
                	  }
                      }
                #endif
                
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                #if __cplusplus >= 201103L
                      template<typename _Ptr>
                	typename std::pointer_traits<_Ptr>::element_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? nullptr : std::__to_address(__ptr); }
                #else
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                      template<typename _Ptr>
                	value_type*
                	_M_data_ptr(_Ptr __ptr)
                	{ return empty() ? (value_type*)0 : __ptr.operator->(); }
                
                      template<typename _Ptr>
                	const value_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? (const value_type*)0 : __ptr.operator->(); }
                #endif
                    };
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _InputIterator, typename _ValT
                	     = typename iterator_traits<_InputIterator>::value_type,
                	   typename _Allocator = allocator<_ValT>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
                      -> vector<_ValT, _Allocator>;
                #endif
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                #if __cpp_lib_three_way_comparison
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A `vector`.
                   *  @param  __y  A `vector` of the same type as `__x`.
                   *  @return  A value indicating whether `__x` is less than, equal to,
                   *           greater than, or incomparable with `__y`.
                   *
                   *  See `std::lexicographical_compare_three_way()` for how the determination
                   *  is made. This operator is used to synthesize relational operators like
                   *  `<` and `>=` etc.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline __detail::__synth3way_t<_Tp>
                    operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    {
                      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),
                						    __y.begin(), __y.end(),
                						    __detail::__synth3way);
                    }
                #else
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                #endif // three-way comparison
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // vector into a variant, but only if move assignment cannot throw.
                    template<typename _Tp, typename _Alloc>
                      struct _Never_valueless_alt<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      : std::is_nothrow_move_assignable<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

     1043  111128049
      918   42360945
     1061   35700000
     1070   28494664
     1092   28494664
      276   11934296
     1187   10983060
      838    5425557
      350    5167659
      820    5125557

Execution Summary:

       39   Executable lines in this file
       39   Lines executed
   100.00   Percent of the file executed

345159061   Total number of line executions
8850232.33   Average executions per line


*** File /usr/include/c++/11/bits/predefined_ops.h:
                // Default predicates for internal use -*- C++ -*-
                
                // Copyright (C) 2013-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file predefined_ops.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _GLIBCXX_PREDEFINED_OPS_H
                #define _GLIBCXX_PREDEFINED_OPS_H	1
                
                #include <bits/move.h>
                
                namespace __gnu_cxx
                {
                namespace __ops
                {
                  struct _Iter_less_iter
                  {
                    template<typename _Iterator1, typename _Iterator2>
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(_Iterator1 __it1, _Iterator2 __it2) const
                      { return *__it1 < *__it2; }
                  };
                
                  _GLIBCXX14_CONSTEXPR
                  inline _Iter_less_iter
                  __iter_less_iter()
                  { return _Iter_less_iter(); }
                
                  struct _Iter_less_val
                  {
                #if __cplusplus >= 201103L
                    constexpr _Iter_less_val() = default;
                #else
                    _Iter_less_val() { }
                #endif
                
                    _GLIBCXX20_CONSTEXPR
                    explicit
                    _Iter_less_val(_Iter_less_iter) { }
                
                    template<typename _Iterator, typename _Value>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Iterator __it, _Value& __val) const
                      { return *__it < __val; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_less_val
                  __iter_less_val()
                  { return _Iter_less_val(); }
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_less_val
                  __iter_comp_val(_Iter_less_iter)
                  { return _Iter_less_val(); }
                
                  struct _Val_less_iter
                  {
                #if __cplusplus >= 201103L
                    constexpr _Val_less_iter() = default;
                #else
                    _Val_less_iter() { }
                #endif
                
                    _GLIBCXX20_CONSTEXPR
                    explicit
                    _Val_less_iter(_Iter_less_iter) { }
                
                    template<typename _Value, typename _Iterator>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Value& __val, _Iterator __it) const
                      { return __val < *__it; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Val_less_iter
                  __val_less_iter()
                  { return _Val_less_iter(); }
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Val_less_iter
                  __val_comp_iter(_Iter_less_iter)
                  { return _Val_less_iter(); }
                
                  struct _Iter_equal_to_iter
                  {
                    template<typename _Iterator1, typename _Iterator2>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Iterator1 __it1, _Iterator2 __it2) const
                      { return *__it1 == *__it2; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_equal_to_iter
                  __iter_equal_to_iter()
                  { return _Iter_equal_to_iter(); }
                
                  struct _Iter_equal_to_val
                  {
                    template<typename _Iterator, typename _Value>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Iterator __it, _Value& __val) const
                      { return *__it == __val; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_equal_to_val
                  __iter_equal_to_val()
                  { return _Iter_equal_to_val(); }
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_equal_to_val
                  __iter_comp_val(_Iter_equal_to_iter)
                  { return _Iter_equal_to_val(); }
                
                  template<typename _Compare>
                    struct _Iter_comp_iter
                    {
                      _Compare _M_comp;
                
                      explicit _GLIBCXX14_CONSTEXPR
         300 ->       _Iter_comp_iter(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      template<typename _Iterator1, typename _Iterator2>
                        _GLIBCXX14_CONSTEXPR
                        bool
     2437696 ->         operator()(_Iterator1 __it1, _Iterator2 __it2)
                        { return bool(_M_comp(*__it1, *__it2)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Iter_comp_iter<_Compare>
         300 ->     __iter_comp_iter(_Compare __comp)
                    { return _Iter_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    struct _Iter_comp_val
                    {
                      _Compare _M_comp;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_comp_val(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
                	: _M_comp(__comp._M_comp)
                      { }
                
                #if __cplusplus >= 201103L
                      _GLIBCXX20_CONSTEXPR
                      explicit
       ##### ->       _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
                	: _M_comp(std::move(__comp._M_comp))
                      { }
                #endif
                
                      template<typename _Iterator, typename _Value>
                	_GLIBCXX20_CONSTEXPR
                	bool
       ##### -> 	operator()(_Iterator __it, _Value& __val)
                	{ return bool(_M_comp(*__it, __val)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_comp_val<_Compare>
                    __iter_comp_val(_Compare __comp)
                    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_comp_val<_Compare>
                    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
                    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    struct _Val_comp_iter
                    {
                      _Compare _M_comp;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Val_comp_iter(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
                	: _M_comp(__comp._M_comp)
                      { }
                
                #if __cplusplus >= 201103L
                      _GLIBCXX20_CONSTEXPR
                      explicit
      299082 ->       _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
                	: _M_comp(std::move(__comp._M_comp))
                      { }
                #endif
                
                      template<typename _Value, typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
     1013588 -> 	operator()(_Value& __val, _Iterator __it)
                	{ return bool(_M_comp(__val, *__it)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Val_comp_iter<_Compare>
                    __val_comp_iter(_Compare __comp)
                    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Val_comp_iter<_Compare>
      299082 ->     __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
                    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Value>
                    struct _Iter_equals_val
                    {
                      _Value& _M_value;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_equals_val(_Value& __value)
                	: _M_value(__value)
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return *__it == _M_value; }
                    };
                
                  template<typename _Value>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_equals_val<_Value>
                    __iter_equals_val(_Value& __val)
                    { return _Iter_equals_val<_Value>(__val); }
                
                  template<typename _Iterator1>
                    struct _Iter_equals_iter
                    {
                      _Iterator1 _M_it1;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_equals_iter(_Iterator1 __it1)
                	: _M_it1(__it1)
                      { }
                
                      template<typename _Iterator2>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator2 __it2)
                	{ return *__it2 == *_M_it1; }
                    };
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_equals_iter<_Iterator>
                    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
                    { return _Iter_equals_iter<_Iterator>(__it); }
                
                  template<typename _Predicate>
                    struct _Iter_pred
                    {
                      _Predicate _M_pred;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_pred(_Predicate __pred)
                	: _M_pred(_GLIBCXX_MOVE(__pred))
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return bool(_M_pred(*__it)); }
                    };
                
                  template<typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_pred<_Predicate>
                    __pred_iter(_Predicate __pred)
                    { return _Iter_pred<_Predicate>(_GLIBCXX_MOVE(__pred)); }
                
                  template<typename _Compare, typename _Value>
                    struct _Iter_comp_to_val
                    {
                      _Compare _M_comp;
                      _Value& _M_value;
                
                      _GLIBCXX20_CONSTEXPR
                      _Iter_comp_to_val(_Compare __comp, _Value& __value)
                	: _M_comp(_GLIBCXX_MOVE(__comp)), _M_value(__value)
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return bool(_M_comp(*__it, _M_value)); }
                    };
                
                  template<typename _Compare, typename _Value>
                    _Iter_comp_to_val<_Compare, _Value>
                    _GLIBCXX20_CONSTEXPR
                    __iter_comp_val(_Compare __comp, _Value &__val)
                    {
                      return _Iter_comp_to_val<_Compare, _Value>(_GLIBCXX_MOVE(__comp), __val);
                    }
                
                  template<typename _Compare, typename _Iterator1>
                    struct _Iter_comp_to_iter
                    {
                      _Compare _M_comp;
                      _Iterator1 _M_it1;
                
                      _GLIBCXX20_CONSTEXPR
                      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
                	: _M_comp(_GLIBCXX_MOVE(__comp)), _M_it1(__it1)
                      { }
                
                      template<typename _Iterator2>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator2 __it2)
                	{ return bool(_M_comp(*__it2, *_M_it1)); }
                    };
                
                  template<typename _Compare, typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_comp_to_iter<_Compare, _Iterator>
                    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
                    {
                      return _Iter_comp_to_iter<_Compare, _Iterator>(
                	  _GLIBCXX_MOVE(__comp._M_comp), __it);
                    }
                
                  template<typename _Predicate>
                    struct _Iter_negate
                    {
                      _Predicate _M_pred;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_negate(_Predicate __pred)
                	: _M_pred(_GLIBCXX_MOVE(__pred))
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return !bool(_M_pred(*__it)); }
                    };
                
                  template<typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_negate<_Predicate>
                    __negate(_Iter_pred<_Predicate> __pred)
                    { return _Iter_negate<_Predicate>(_GLIBCXX_MOVE(__pred._M_pred)); }
                
                } // namespace __ops
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

      157    2437696
      239    1013588
      231     299082
      252     299082
      150        300
      164        300

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

  4050048   Total number of line executions
506256.00   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/./Genetic-Algorithm/Path_representation.cpp:
                #include "Path_representation.hpp"
                #include <iostream>
                #include <algorithm>
                #include <cstdlib>
                #include <utility>
                #include <vector>
                
                using std::vector;
                using std::pair;
                using std::cout;
                using std::endl;
                
                /* Takes the number of points to be visited &
                 * generates a random order to visit those points
                 *
                 */
        3000 -> PathRepresentation::PathRepresentation( const int numPoints) {
                  for(int i = 0 ; i < numPoints; ++i)
                    genome.push_back(i);
                
                  std::random_shuffle(genome.begin(), genome.end());
                  fitnessScore = -1;
                }
                
                
                /*
                 * Initializes the genome from the specified visit order.
                 */
      540000 -> PathRepresentation::PathRepresentation(const vector<int>&order)
                {
                  genome = order;
                  fitnessScore = -1;
                }
                
     1906612 -> PathRepresentation::~PathRepresentation()
                {
                  /*Nothing to do here*/
                }
                
                /*
                 * Computes the fitness score (path length) of the genome.
                 */
      300000 -> double PathRepresentation::fitness_score(const vector<Point> &points) {
                  size_t numPoints = genome.size();
                
                  for(size_t i = 0, j = 1; i < numPoints -1; ++i, ++j)
                    fitnessScore += points[genome.at(i)].distance_to(points[j]);
                
                  // TS has to go back to the startting position.
                  fitnessScore+= points[genome.front()].distance_to(points.back());
                
                  return fitnessScore;
                }
                
                
                /*
                 * Returns the visit order.
                 */
      540003 -> vector<int> PathRepresentation::get_order() const {
                  return genome;
                }
                
                /*
                 * Returns the fitness score
                 */
     7442601 -> double PathRepresentation::get_fitness_score() const {
                  return fitnessScore;
                }
                
                /*
                 * Mutates the genome by swapping two random
                 * values in the order vector.
                 */
      270000 -> void PathRepresentation::mutate(){
                  unsigned indexA;
                  unsigned indexB;
                
                  indexA = rand() % genome.size();
                  do {
                    indexB = rand()% genome.size();
                  } while(indexB == indexA);
                
                  std::iter_swap(genome.begin() + indexA, genome.begin() + indexB);
                }
                
                PathRepresentation run_genetic_algorithm(const std::vector<Point> &points,
                                                         Crossover *CrossoverObject,
                                                         size_t populationSize, size_t numGenerations,
                                                         size_t keepPopulation, size_t numMutations)
           3 -> {
                  // Generate an initial population of random genes
                  vector<PathRepresentation> population;
                  size_t numPoints = points.size();
                  
                  for(unsigned i = 0 ; i < populationSize; ++i) {
                    PathRepresentation genome(numPoints);
                    population.push_back(genome);
                  }
                
                  for(unsigned gen = 0; gen < numGenerations * 10; ++gen) {
                    
                    // Compute fitness score of each genome.
                    for(PathRepresentation& genome:population){
                      genome.fitness_score(points);
                    }
                
                    // sort the genomes by fitness.
                    std::sort(population.begin(), population.end(), compare_paths);
                
                    // Keep the top N fittest memebrs of the population &
                    // replace the remaining memebrs with new genomes produced
                    // by crosslinking.
                
                    for(unsigned i = keepPopulation; i < populationSize; ++i){
                      unsigned indexA;
                      unsigned indexB;
                
                      // range [0 . . . keepPopulation - 1]
                      indexA = rand() % keepPopulation;
                      do {
                        indexB = rand() % keepPopulation;
                         } while( indexA == indexB);
                
                        pair<PathRepresentation, PathRepresentation>  offsprings= 
                          CrossoverObject->crosslink(population[indexA], population[indexB]); 
                
                      if (compare_paths(offsprings.first, offsprings.second) )
                        population[i] = offsprings.first;
                      else
                        population[i] = offsprings.second;
                    }
                
                    //Mutate random genes
                    for(unsigned i = 0; i < numMutations; ++i){
                      unsigned randomIndex;
                      randomIndex = 1 + rand() %( populationSize - 1);
                      population[randomIndex].mutate();
                    }
                
                    if(gen % 10 == 0){
                      cout<<" Generation "<<gen/10<<" : shortest path found "
                        <<population[0].get_fitness_score()<<endl;
                    }
                    }
                  return population[0];
                }
                
     3721284 -> bool compare_paths(const PathRepresentation &A, const PathRepresentation &B){
                  double fitnessA = A.get_fitness_score();
                  double fitnessB = B.get_fitness_score();
                  if(fitnessA < fitnessB)
                    return true;
                  else
                    return false;
           2 -> }


Top 10 Lines:

     Line      Count

       66    7442601
      148    3721284
       35    1906612
       59     540003
       29     540000
       43     300000
       74     270000
       17       3000
       90          3
      155          2

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

 14723505   Total number of line executions
1472350.50   Average executions per line


*** File /home/exterminate/Documents/HPC_PROJECT/main.cpp:
                #include "Point/point.hpp"
                #include "Genetic-Algorithm/Path_representation.hpp"
                #include "Genetic-Algorithm/Crossover/crossover_base.hpp"
                #include "Genetic-Algorithm/Crossover/random_crossover.hpp"
                #include "Genetic-Algorithm/Crossover/partially_mapped_crossover.hpp"
                #include "Genetic-Algorithm/Crossover/uniform_partially_mapped_crossover.hpp"
                #include <iostream>
                #include <cstdlib>  	// srand(), atoi()
                #include <ctime> 		// time()
                #include <getopt.h>
                
                using std::cin;
                using std::cout;
                using std::endl;
                using std::vector;
                
                void help();
                
                
       ##### -> int main(int argc, char **argv) {
                
                
                	// Parsing Arguments
                
                	int populationSize, numGenerations,
                			keepPopulation, numMutations;
                
                	int c;
                
                	while(1) {
                		static struct option long_options[] = {
                			{"population",	required_argument,	0,	'p'},
                			{"generation",	required_argument,	0,	'g'},
                			{"keep",	required_argument,	0,	'k'},
                			{"mutation",	required_argument,	0,	'm'},
                			{"help",		no_argument,	0,	'h'},
                			{0, 0, 0, 0}
                		};
                
                		/* getopt_long stores the option index here. */
                		int option_index = 0;
                
                		c = getopt_long (argc, argv, "p:g:k:m:h",
                                       long_options, &option_index);
                		/* Detect the end of the options. */
                    	if (c == -1)
                    	break;
                
                    	switch(c)
                    		{
                    		case 'p':
                    			populationSize = atoi(optarg); break;
                    		case 'g':
                    			numGenerations = atoi(optarg); break;
                    		case 'k':
                    			keepPopulation = atoi(optarg); break;
                    		case 'm':
                    			numMutations = atoi(optarg); break;
                    		case 'h':
                    			help(); exit(0);
                    		default :
                    			abort ();
                    		}
                    	}
                
                    if(argc != 9) {
                    	help();
                    }
                
                	// Setting Input
                
                	srand (unsigned (time (0)));
                
                	int pointsNumber;
                	double inputX, inputY, inputZ;
                	vector<Point> pointsCluster;
                
                	// Points Input
                
                  //cout<<"Enter the number of cities:";
                	cin >> pointsNumber;
                
                	for(int i = 0; i < pointsNumber; i++) {
                    //cout<<"Enter city co-ordinates: ";
                		cin >> inputX >> inputY >> inputZ ;
                		Point inputPoint {inputX, inputY, inputZ};
                		pointsCluster.push_back(inputPoint);
                		 
                	}
                
                	// Run Genetic Algorithm with random_crossover & partially_mapped_crossover
                  RandomCrossover random_crosslink;
                  PartiallyMappedCrossover pmc_crosslink;
                  UniformPartiallyMappedCrossover upmc_crosslink;
                  Crossover* CrossoverObject[3] = {&random_crosslink, &pmc_crosslink, &upmc_crosslink};
                  
                
                  for(unsigned i = 0 ; i < 3; ++i)
                  {
                    cout<<endl;
                    if( i == 0)
                      cout<<" Running Genetic Algorithm with Random Crossover"<<endl;
                    else if (i == 1)
                      cout<<" Running Genetic Algorithm with Partially Mapped Crossover"<<endl;
                    else
                      cout<<" Running Genetic Algorithm with Uniform Partially Mapped Crossover"<<endl;
                
                    PathRepresentation bestGenome = run_genetic_algorithm(pointsCluster, CrossoverObject[i],
                        populationSize,numGenerations,
                        keepPopulation, numMutations);
                    vector<int> shortestPathFound = bestGenome.get_order();
                    double pathLength = bestGenome.get_fitness_score();
                
                    cout << "Shortest Path Found : [";
                    for(const auto& genome : shortestPathFound) {
                      cout << " " << genome;
                    }
                    cout << "]\nLength is : " << pathLength << endl;
                  }
                	return 0;
                }
                
       ##### -> void help() {
                    	cout <<
                    		"ALL OPTIONS ARE REQUIRED\n"
                    		"where options are :\n"
                    		"-p <value>, --population <value>\n"
                    		"population is a positive integer specifying the population size.\n\n"
                
                    		"-g <value>, --generation <value>\n"
                    		"generations is a positive integer specifying how many generations to run the GA for.\n\n"
                
                    		"-k <value>, --keep <value>\n"
                    		"the number of the population that should be preserved from generation to generation.\n\n"
                
                    		"-m <value>, --mutation <value>\n"
                    		"specifies how many mutations to apply to each member of the population."
                
                    		<< endl;
           2 -> }


Top 10 Lines:

     Line      Count

      140          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line
